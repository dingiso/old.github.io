[{"title":"如何判断结构化程序","date":"2021-03-11T07:52:19.000Z","path":"2021/03/11/如何判断结构化程序/","text":"","link":"","tags":[]},{"title":"Question","date":"2021-03-07T12:07:05.000Z","path":"2021/03/07/Question/","text":"本文主要是用于询问软件工程问题 问题老师我想问一下课后题的 11.2 老师您上课给的答案如下 我对于 4 结点与 9 结点有点问题，4 结点我认为应该是两个结点，9结点在代码上没有实际的代码行对应 我做的结果详细的是下图 回答控制流图应该尽量简洁，便于计算环形复杂度，顺序结构能合并的应该尽量合并，同时需要注意的是这样的合并并不会改变环形复杂度 4 结点是 合并后的结果 - 结点数 - 1 ，边 - 1 不影响环形复杂度 9 结点是 为了画图更清晰 - 结点数 + 1 ，边 + 1 不影响环形复杂度 更改的图例如下","link":"","tags":[{"name":"Question","slug":"Question","permalink":"https://dingiso.github.io/tags/Question/"}]},{"title":"在QEMU中定制RISCV指令并测试","date":"2021-02-13T04:05:34.000Z","path":"2021/02/13/在QEMU中定制RISCV指令并测试/","text":"本文主要是介绍 通过QEMU中提供的Decode Tree 的方法定义指令编码 定义指令的转义和指令的基础逻辑 利用二进制的方式定义测试程序并测试 使用 P扩展(Packed SIMD) 作为示例 QEMU 下载为了更改QEMU的源码，我们需要正确下载源代码并自行进行编译，QEMU提供了两种方式方便我们下载。 通过 git 的方式下载 QEMU 的最新源码 - 该方式可能需要一个稳定的 “科学的” 网络 1234git clone https://gitlab.com/qemu-project/qemu.gitcd qemugit submodule initgit submodule update --recursive 同样的，我们可以直接选择下载官网打包好的最新稳定版的QEMU源码，这能让你更稳定，快速的得到代码，但可能不是 git 同步的最新版本 - QEMU-5.2.0 123wget https://download.qemu.org/qemu-5.2.0.tar.xztar xvJf qemu-5.2.0.tar.xzcd qemu-5.2.0 通过以上方式下载过后，我们可以开始进行指令的添加了 指令编码 - Decode Tree为了方便开发者和编译检查，QEMU 中的指令的二进制指令编码都是以Decode Tree 方式进行定义的，QEMU的内部程序在编译时会将其自动解析为 c 语言。 特别地，像 RISC-V 这种拥有固定指令格式的 ISA 特别契合 Decode Tree。因为各个指令段都在固定的位置。各个段的重复性要高很多，足以节省很多代码空间 下面我们已一种最常用的三参数指令的P扩展add16作为例子： 1234#！target/riscv/insn*.decode# 31:25 24:20 19:15 14:12 11:7 6:0add16 0100000 ..... ..... 000 ..... 1110111 @r# funct7 Rs2 Rs1 funct3 Rd opcode 12345678# 其中用到的各个定义如下# Formats 32:@r ....... ..... ..... ... ..... ....... &amp;r %rs2 %rs1 %rd# Fields:%rs2 20:5%rs1 15:5%rd 7:5 一个指令的定义有以下几个过程 找到官方文件对于指令编码的定义，将指令名称add16和二进制编码0100000 ..... ..... 000 ..... 1110111填入 通过指令对于参数的定义，选取合适的Format，例如 @r ，就顺序包含了两个输入寄存器rs1 &amp; rs2 和输出寄存器rd 如果没有，就需要自己定义 有关decoder tree 的具体内容，接下来的博客可能会进行阐述， 但是有的 blogs 已经有了详细的阐述，qemu 官方也有，下面给出链接，大家可以参阅 QEMU官方： Decode Tree的定义 其他博客的定义：Part-1，Part-2 指令转译 - transQEMU在执行时，会将 target instructions(e.g. RISC-V instructions) 转译成 TCG ops，而TCG ops则会再转译为host instructions(e.g. x86 instruction)。而trans_add16() 实际执行了 add16 指令对应的 TCG ops 12345#！ QEMU dynamic instructions translation+---------------------+ +---------+ +-------------------+| Target Instructions | ---&gt; | TCG ops | ---&gt; | Host instructions |+---------------------+ +---------+ +-------------------+ (e.g. RISC-V) (e.g. x86) 关于 TCG 的说明，可以参考 QEMU 的 documentations Translator Internals，TCG Readme 为了方便定义和区分，新建一个文件./target/riscv/insn_trans/trans_rvp.inc.c来定义P Extension指令的trans_xx()函数 1234567891011121314151617#！ ./target/riscv/insn_trans/trans_rvb.c.inc/* * RISC-V translation routines for the RVP Standard Extension. */static bool trans_add16(DisasContext *ctx, arg_pcnt *a) &#123; if (a-&gt;rd != 0) &#123; TCGv t0 = tcg_temp_new(); gen_get_gpr(t0, a-&gt;rs1); TCGv t1 = tcg_temp_new(); gen_get_gpr(t1, a-&gt;rs2); gen_helper_add16(cpu_gpr[a-&gt;rd], t0, t1); tcg_temp_free(t0); tcg_temp_free(t1); &#125; return true;&#125; 由于对x0(zero register)的写入都会被忽略，因此首先判断rd是否为0，若为0则不做任何事情 接着声明两个TCG variable：t0和t1，利用gen_get_gpr()将rs1,rs2寄存器的值存入变量 利用新声明的变量调用gen_helper_add16()函数转向helper function，该函数计算完成后，会将结果保存在rd(i.e. cpu_gpr[a-&gt;rd])寄存器中。 P.S. 其实这里可以简单的直接将cpu_gpr[a-&gt;rs1]传入，省略TCG variable: t0,t1 的声明： 1234567891011#! ./target/riscv/insn_trans/trans_rvp.c.inc/* * RISC-V translation routines for the RVB Standard Extension. */static bool trans_add16(DisasContext *ctx, arg_pcnt *a) &#123; if (a-&gt;rd != 0) &#123; gen_helper_add16(cpu_gpr[a-&gt;rd], cpu_gpr[a-&gt;rs1], cpu_gpr[a-&gt;rs2]); &#125; return true;&#125; 指令的逻辑 - helper function123#define DEF_HELPER_2(name, ret, t1, t2) \\ DEF_HELPER_FLAGS_2(name, 0, ret, t1, t2)//DEF_HELPER_FLAGS_2(name,flag,ret,t1,t2) 为了方便QEMU对于helper function的调用和定义，我们需要定义一个函数DEF_HELPER_x = DEF_HELPER_FLAGS_x 对QEMU声明函数的名称和参数, x代表该指令需要的参数-(自变量），不带 _FLAGS 的函数会利用命令自动将 FLAGS参数置为0。 name ：指令的名称，连接成 HELPER(name) / helper_name 的形式作为 helper function flag : 函数权限位，TCG调用的权限，全局不读/写，返回值无用，无返回值。tcg.h ret : helper function返回值 t1- tn ：helper function的参数 ret 和 t1-tn 的类型可以是， 类型 意义 tl target_ulong - QEMU中保存寄存器值得基本单位 env environment - CPUXXSTATE 保存CPU状态寄存器的值 i64 integer-64 - 64位整型可用于浮点数指令 add16的 helper function 定义如下: 1234#! ./target/riscv/helper.h/* Packed-SIMD Extension */DEF_HELPER_2(add16, tl, tl, tl)DEF_HELPER_FLAGS_3(add16, 0, tl, tl, tl) 两种定义意义相同 1234567891011121314151617181920212223242526272829#! ./target/riscv/bitmanip_helper.c/* * RISC-V P Extension Helpers for QEMU. */#include &quot;qemu/osdep.h&quot;#include &quot;cpu.h&quot;#include &quot;exec/exec-all.h&quot;#include &quot;exec/helper-proto.h&quot;#define u16p uint16_t *#if defined(TARGET_RISCV32)const uint32_t LC_16BIT = 2;#elseconst uint32_t LC_16BIT = 4;#endif// target_ulong HELPER(add16)(target_ulong rs1, target_ulong rs2) target_ulong helper_add16 (target_ulong rs1, target_ulong rs2) &#123; target_ulong rd = 0; u16p rs1_p = (u16p)&amp;rs1; u16p rs2_p = (u16p)&amp;rs2; u16p rd_p = (u16p)&amp;rd; for (unsigned i = 0; i &lt; LC_16BIT; i++) rd_p[i] = rs1_p[i] + rs2_p[i]; return rd;&#125; 该函数就是add16的实际逻辑函数，helper function 接受两个 target_ulong 类型的 rs1&amp;rs2, 并将结果返回，存储在 rd 寄存器 add16 指令的内容，是将寄存器分为多个16位数并分别计算，因此我们将rs1/2 变为16位的数组(指针)并分别进行加法运算，得到结果然后返回。 补充为了使指令成功执行，我们还需要填写以下代码 12345#! ./target/riscv/meson.buildriscv_ss.add(files( &#x27;psimd_helper.c&#x27;,)) 1234#! ./target/riscv/translate.c/* Include insn module translation function */#include &quot;insn_trans/trans_rvp.c.inc&quot; 指令的测试在我们了解了指令的添加流程后，我们要对添加后的指令进行测试以确保指令的正确性。 为了成功编译，你需要事先安装riscv64-unknown-elf-gcc来编译测试程序，你可以通过 riscv-gnu-toolchain 进行编译安装 下面我将介绍一下QEMU的编译过程，鉴于我们只需要QEMU的用户态测试程序，我们执行以下命令在你保存qemu的文件夹下： 1234mkdir buildcd build../configure --target-list=riscv64-linux-usermake build 文件夹用于保存你的编译结果，你也可以自由选择想要保存的文件夹。 接着我们创建一个 p_test 文件夹保存测试程序并进行测试, 因为原有的工具链并不含有新添加的指令，没办法编译成合适的二进制编码，所以我们使用内联汇编为其提供二进制编码，省去更改工具链的麻烦。 123456789101112131415161718192021#! ./build/p_test/add16.c#include&lt;stdio.h&gt;__attribute__((noinline))int mac_asm(int a,int b,int c) &#123; asm __volatile__ (&quot;.word 0x40c58577\\n&quot;); asm __volatile__ (&quot;mv %0,a0\\n&quot; : &quot;=r&quot;(a) : :); printf(&quot;a=%d\\n&quot;,a); return a;&#125;int main()&#123; int a=5,b=0xFFFEFFFF,c=0xFFFEFFFF; printf(&quot;add16:=0x%x\\n add:=0x%x\\n&quot;,mac_asm(a,b,c),b+c); return 0;&#125; RISC-V 会将函数的参数放入 a0-a7 寄存器中，并将 a0 寄存器中的值返回 a0-a7 对应 x10-x17 和二进制编码 10-17 ， 因此最后的指令编码如下 12345678910111213# Encoding used for &quot;add16 a0, a1, a2&quot;0x40c58577 [base 16]==# Group by related bit chunks:0100000 01100 01011 000 01010 1110111 [base 2]^ ^ ^ ^ ^ ^| | | | | || | | | | opcode (6..2=0x1D 1..0=3)| | | | dest (10 : a0)| | | funct3 (14..12=0)| | src1 (11 : a1)| src2 (12 : a2)funct7 (31..25=0x40) 为了防止在编译过程中，编译器会对寄存器进行优化，将返回值存入其他寄存器，我们使用 mv 指令强制将变量 a 的值赋给 a0 寄存器,这样就能成功将值返回。 12riscv64-unknown-elf-gcc -o x x.c../qemu-riscv64 xx 我们利用以上指令执行，返回正确的结果 12add16:=0xfffcfffe add:=0xfffdfffe add16 由于每16位进行计算，所以无后16位的进位，中间位是c，而add由于有进位，所以是d 在QEMU中定制指令的流程大致如同本文的介绍，但是由于 add16 仅涉及数值的计算，而没有像 csr 相关指令涉及 CPURISCVState 的更新，以及像jal指令涉及DisasContext的判断，因此相对简单，对于其他指令，需要在好好的研究以下 Refrences: QEMU-使用 Decodetree新增 RISC-V 指令 RISC-V: custom instruction and its simulation riscv-p-spec 感谢在学习过程中，老师们的指导，非常感谢！！","link":"","tags":[{"name":"QEMU","slug":"QEMU","permalink":"https://dingiso.github.io/tags/QEMU/"},{"name":"RISC-V","slug":"RISC-V","permalink":"https://dingiso.github.io/tags/RISC-V/"}]},{"title":"Hello World","date":"2021-02-01T08:06:43.407Z","path":"2021/02/01/hello-world/","text":"Welcome to my blog !在这里我将分享一些技术细节和相关过程，不断更新中 欢迎来我的博客 - 建设程度 10/100","link":"","tags":[]}]